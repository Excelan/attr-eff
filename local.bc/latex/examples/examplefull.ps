%!PS-Adobe-2.0
%%Creator: dvips(k) 5.995 Copyright 2015 Radical Eye Software
%%Title: examplefull.dvi
%%CreationDate: Tue Jan 26 15:06:55 2016
%%Pages: 1
%%PageOrder: Ascend
%%BoundingBox: 0 0 612 792
%%DocumentFonts: LMRoman12-Bold LMRoman10-Regular LMRoman10-Bold
%%DocumentPaperSizes: Letter
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: dvips examplefull.dvi
%DVIPSParameters: dpi=600
%DVIPSSource:  TeX output 2016.01.26:1506
%%BeginProcSet: tex.pro 0 0
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/dir 0 def/dyy{/dir 0 def}B/dyt{/dir 1 def}B/dty{/dir 2 def}B/dtt{/dir 3
def}B/p{dir 2 eq{-90 rotate show 90 rotate}{dir 3 eq{-90 rotate show 90
rotate}{show}ifelse}ifelse}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0
N/Ry 0 N/V{}B/RV/v{/Ry X/Rx X V}B statusdict begin/product where{pop
false[(Display)(NeXT)(LaserWriter 16/600)]{A length product length le{A
length product exch 0 exch getinterval eq{pop true exit}if}{pop}ifelse}
forall}{false}ifelse end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{
BDot}imagemask grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat
{BDot}imagemask grestore}}ifelse B/QV{gsave newpath transform round exch
round exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0
rlineto fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B
/M{S p delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}
B/g{0 M}B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p
-3 w}B/n{p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{
0 S rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: pstricks.pro 0 0
% $Id: pstricks.pro 919 2014-05-19 18:42:47Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 1.23, 2014/07/31
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
% Define the follwing gs-functions if not known, eg when using distiller
%
systemdict /.setopacityalpha known not {/.setopacityalpha { pop } def } if
systemdict /.setblendmode known not {/.setblendmode { pop } def } if
systemdict /.setshapealpha known not {/.setshapealpha { pop } def } if
%
/tx@Dict 200 dict def 				% the main PSTricks dictionary
tx@Dict begin
/ADict 25 dict def				% The arrow dictionary
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Sqrt { dup 0 lt { pop 0 } { sqrt } ifelse } def  % return 0 for negative arguments 
/Atan { /atan load stopped { pop pop 0 } if } def % return 0 if atan not known
/ATAN1 {neg -1 atan 180 sub } def		% atan(x) (only one parameter)
/Div { dup 0 eq { pop } { div } ifelse } def  	% control the division
/Log { dup 1e-20 lt { pop -1e30 }{ log } ifelse } def % control the log
/tan { dup cos abs 1.e-10 lt 
  { pop 1.e10 } 				% return 1.e10 as infinit
  { dup sin exch cos div } ifelse 		% default sin/cos
} def
/Tan { dup sin exch cos Div } def 		% sin(x)/cos(x) x in degrees
/Acos {dup dup mul neg 1 add dup 0 lt {		% arc cos, returns 0 when negative root
  pop pop 0 }{ sqrt exch atan} ifelse } def
/Acos2 { 2 dict begin 
  /x ED /y ED
  y abs 1.0e-20 lt { 1.0e30 } if
  x y div 
  dup dup mul neg 1 add dup 0 lt {		% arc cos needs two values x,y
  pop pop 0 }{ sqrt exch atan} ifelse 
  y 0 lt { 180 add } if
} def
/NET { neg exch neg exch T } def	      	% change coordinate system to the negative one		
/Pyth { dup mul exch dup mul add sqrt } def   	% Pythagoras, expects 2 parameter
/Pyth2 {					% Pythagoras, xA yA xB yB
  3 -1 roll 		% xA xB yB yA
  sub			% xA xB yB-yA
  3 1 roll 		% yB-yA xA xB
  sub			% yB-yA xA-xB
  Pyth } def
/PtoC { 2 copy cos mul 3 1 roll sin mul } def % Polar to Cartesian
/PtoCab { dup cos 4 -1 roll mul 3 1 roll sin mul } def % Polar to Cartesian (Ellipse) a b phi-> x y 
%/Rand { rand 4294967295 div } def		% a real random number
/Rand { rand 2147483447 div } def		% a real random number between 0 and 1
%----------------- hv added 20050516 ---------------
/PiDiv2 1.57079632680 def
/Pi 3.14159265359 def 
/TwoPi 6.28318530718 def
/Euler 2.71828182846 def 
%/e Euler bind def
%
/RadtoDeg { 180 mul Pi div } bind def 		% convert from radian to degrees
/DegtoRad { Pi mul 180 div } bind def 		% viceversa
%
/startGlobal { true setglobal globaldict begin } bind def
/endGlobal { end false setglobal } bind def
/pssetRGBcolor /setrgbcolor load def
/pssetCMYKcolor /setcmykcolor load def
/pssetGraycolor /setgray load def
%
%----------------- hv end---------------------------
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def } def
%
/PathLength { 
  flattenpath /z 0 def 
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def }
  { /y ED /x ED PathLength@ } 
  {} 
  { /y y2 def /x x2 def PathLength@ }
  /pathforall load stopped { pop pop pop pop } if 
  z 
} def
%
/STP { .996264 dup scale } def			% BP/PT scaling
/STV { SDict begin normalscale end STP  } def	% 
%
/DashLine {
    dup 0 gt
    { /a .5 def PathLength exch div }
    { pop /a 1 def PathLength } ifelse
    /b ED % pattern should fit evenly in b
    dup /X ED % pattern array
    0 get /y ED % length of first black segment
    /z 0 X {add} forall def % length of the full pattern
    %% Computation of the scaling factor as described by van Zandt:
    b a .5 sub 2 mul y mul sub z Div round
    z mul a .5 sub 2 mul y mul add b exch Div
    %%%% scaling factor on stack.
    /z ED %% now, z is the scaling factor
    false % for the length test below
    X { z mul } forall X astore %% modification TN 04-08-07
    %%% Checking whether at least one dash in X has positive length:
    {0 gt or} forall
    { X 1 a sub y mul }
    { [ 1 0 ] 0 }
    ifelse
    setdash stroke
} def
%
/DotLine { 
  /b PathLength def 
  /a ED /z ED /y CLW def 
  /z y z add def 
  a 0 gt { 
    /b b a div def 
  }{ 
    a 0 eq { 
      /b b y sub def 
    }{ a -3 eq { 
      /b b y add def } if 
    } ifelse 
  } ifelse 
  [ 0 b b z Div round Div dup 0 le { pop 1 } if ] 
  a 0 gt { 0 }{ y 2 div a -2 gt { neg }if } ifelse 
  setdash 1 setlinecap stroke 
} def
%
/SymbolLine {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 div cvi /n ED     				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    %% for negative SymStep we calculate the distance 
    SymStep 0 lt 
      { %XYLength SymStep div abs cvi 
        /nSym SymStep abs cvi def } 
      { /nSym XYLength SymStep div cvi def }
    ifelse
    0.5 setflat
    /Shift Symbol stringwidth pop 2 div def 
    /deltaX XLength nSym div def
    /deltaY YLength nSym div def
    curveticks 
      { XA YA moveto }
      { XA Shift sub YA Shift sub moveto }
    ifelse 
    nSym { 
      gsave 
      curveticks 
        { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
          currentpoint translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
          Symbol show 
        }
      ifelse 
      grestore 
      deltaX deltaY rmoveto
    } repeat
    /YA YB def /XA XB def
  } repeat 
  curveticks 
    { XA YA moveto }
    { XA Shift sub YA Shift sub moveto }
  ifelse 
  gsave 
  curveticks 
    { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
      XA YA translate rotAngle rotate 
      0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
      SymbolLinewidth setlinewidth stroke
    }
    { 
      rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
    }
  ifelse 
  grestore
  pop 				% delete the mark symbol
} def
%
/LineFill { % hv ------------ patch 7 -------------
  gsave 
  abs /hatchWidthInc ED
  abs /hatchSepInc ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  2 setlinecap 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  x2 x1 sub 1 add { 
    x1 a mul y1 moveto 0 y2 rlineto stroke 
    /x1 x1 1 add 
      hatchWidthInc 0 gt { CLW add } if 
    def 
    hatchSepInc 0 gt hatchWidthInc 0 gt or { 
      /a a hatchSepInc add def
      CLW hatchWidthInc add SLW 
    } if
  } repeat 
  grestore 
  pop pop } def
%
/DotFill {%	 on stack: dot radius
  /dotRadius ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform 
  pathbbox % llx lly urx ury of smallest bounding box
  /y2 ED /x2 ED /y1 ED /x1 ED 
  y2 y1 sub a div 2 add cvi /Ny ED
  x2 x1 sub a div 2 add cvi /Nx ED
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  /yA y1 dotRadius add CLW add def
  /xA0 x1 dotRadius add CLW add def
  Ny {
     /xA xA0 def
     Nx { 
       newpath 
       xA yA dotRadius 0 360 arc 
       SolidDot { gsave fill grestore } if 
       stroke
       xA a add /xA ED
     } repeat
     yA a add /yA ED
  } repeat
  grestore
} def
%
/PenroseFill {%	 on stack: scaling factor
  /Scale ED
%  1 exch div round /penroseFactor ED 
%  a 0 dtransform round exch round exch
%  2 copy idtransform 
%  exch Atan rotate 
%  idtransform pop /a ED 
%  .25 .25 itransform pathbbox 
%  /y2 ED 
%  a Div ceiling cvi /x2 ED /y1 ED 
%  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
gsave
  220 150 translate
  Scale dup scale
  systemdict /setstrokeadjust known { true setstrokeadjust } if 
  /I/S/L/W/G/+/Z/F/E/D[/def/exch/for{E D}/add{s E get mul}
 { Z -36.2001 1 33 }{25 E S rlineto}{/q Z dup q G E q 1 + G}{Z 2 2}]{cvx def}forall
  [0 72 1008 {dup sin E cos }F ]1 setlinejoin/s W{/a W{/b I 10{/i I 4{/m I moveto
  i m +/j I 10{/l Z b m l + G a l G sub s m get div .2 + floor .3 + 25
  mul j l + S rmoveto}F i L j L stroke }F}F}F}F 
  grestore 
%  pop pop 
} def
%
/PenroseFillA {%  on stack: scaling factor, border color, kite color, dart color
  /Scale ED
  Scale dup scale
  /border_colour ED 
  /kite_colour ED 
  /dart_colour ED
  clip 
  newpath 
  gsave
  100 100 translate
  6 
  Scale 1 lt { 1 Scale dup add div mul cvi } if %%%%   Number of iterations
  10					%%%%   Long side length in millimeters
  /border_width { L 0.06 mul }def		%%%%   Choose the scalefactor for the borders
  /L exch 25.4 div 72 mul def		%%%%   Conversion: mm -> inches -> points
  /f{-1 5 sqrt add 2 div}bind def		%%%%   The reciprocal of the golden ratio
  /l{L f mul}bind def			%%%%   Short side length l = L*f
  /Ll{L l add}bind def			%%%%   Ll =  L + l
  /c{36 cos L mul}bind def		%%%%   c  =  L*cos(36)
  /s{36 sin L mul}bind def		%%%%   s  =  L*sin(36)
  /draw_tile { 0 0 moveto c s lineto 0 lineto gsave closepath gsave fill grestore
	     0 setlinewidth stroke grestore border_colour stroke } bind def
  /half_kite { dup dup 0 gt{ 1 sub gsave f f neg scale -36 rotate half_dart
			   Ll 0 translate 144 rotate kite grestore }
	      		 { kite_colour L draw_tile }ifelse
	     pop } bind def
  /half_dart { dup dup 0 gt{ 1 sub gsave f f scale half_kite
			   -144 rotate Ll neg 0 translate half_dart grestore }
	      		 { dart_colour l draw_tile }ifelse
  	     pop } bind def
  /kite{ gsave half_kite 1 -1 scale half_kite grestore }bind def
  border_width setlinewidth  1 setlinejoin  1 setlinecap
%  450 0 translate  
  dup f exch neg exp dup scale
  5 {kite 72 rotate } repeat stroke 
  grestore
} def
%
%
/TruchetFill { %	 on stack: scaling factor
  10 dict begin
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /ma a neg def
  /ha a 2 div def 
  /mha ha neg def
  /tile { 
    rand dup 2 idiv 2 mul eq { 90 rotate } if
    mha mha moveto ha mha lineto
    ha ha lineto mha ha lineto
%    closepath .1 setlinewidth stroke
    contents
  } def
  /contents{ 
    0 ha moveto ha 0 lineto
    0 mha moveto mha 0 lineto
%    1 setlinewidth stroke
  } def
  /dotiling {
    f ma mul a f a mul { 
      /i exch def
      f ma mul a f a mul { 
        /j exch def
        gsave i j translate
        tile stroke grestore
      } for
    } for
  } def
%
  /f 3 def 
  5 srand dotiling 
  end % local user dict
} def
%
/BeginArrow { 
  ADict begin 			% hold it local, for end see EndArrow
  /@mtrx CM def 
  gsave 
  2 copy T 
  2 index sub neg exch 
  3 index sub exch Atan 
  rotate newpath 
} def
%
/EndArrow { @mtrx setmatrix CP grestore end } def % end the ADict
%
/Arrow { 
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /a ED 
  { 0 h T 1 -1 scale } if 
  w neg h moveto 
  0 0 L w h L w neg a neg rlineto 
  gsave fill grestore 
} def
%
/ArrowD { % the sides are drawn as curves (hv 20071211)
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /Inset ED 
  { 0 h T 1 -1 scale } if % changes the direction
% we use y=w/h^2 * x^2 as equation for the control points
% for the coordinates the arrow is seen from top to bottom
% the bottom (tip) is (0;0)
  w neg h moveto % lower left of >
  w 9 div 4 mul neg h 3 div 2 mul
  w 9 div neg       h 3 div  
  0 0 curveto    % tip of >
  w 9 div        h 3 div  
  w 9 div 4 mul  h 3 div 2 mul
  w h curveto % upper left of >
  w neg Inset neg rlineto % move to x=0 and inset
  gsave fill grestore 
} def 
%
/Tbar { 
  CLW mul add /z ED 
  z -2 div CLW 2 div moveto 
  z 0 rlineto stroke 
  0 CLW moveto 
} def
%
/Bracket { 
  CLW mul add dup CLW sub 2 div 
  /x ED mul CLW add /y ED /z CLW 2 div def 
  x neg y moveto 
  x neg CLW 2 div L x CLW 2 div L x y L stroke 
  0 CLW moveto 
} def
%
/RoundBracket { 
  CLW mul add dup 2 div 
  /x ED mul /y ED /mtrx CM def 
  0 CLW 2 div T x y mul 0 ne { x y scale } if 
  1 1 moveto 
  .85 .5 .35 0 0 0 curveto 
  -.35 0 -.85 .5 -1 1 curveto 
  mtrx setmatrix stroke 0 CLW moveto 
} def
%
/SD { 0 360 arc fill } def
%
/EndDot { % DS is the dot size 
  { /z DS def } { /z 0 def } ifelse  	% outer or inner dimen 
  /b ED 				% the color definition
  0 z DS SD 
  b { 0 z DS CLW sub SD } if 
  0 DS z add CLW 4 div sub 
  moveto 
} def
%
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
  /closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
  load } if ] cvx newpath 3 1 roll T exec } def
%
/NArray { % holds the coordinates and on top of stack the showpoints boolean
  /showpoints ED 
  counttomark 2 div dup cvi /n ED  	% n 2 div on stack 
  n eq not { exch pop } if		% even numbers of points? delete one
  ] aload /Points ED 
  showpoints not { Points aload pop } if
%    { ] aload /Points ED } 
%    { n 2 mul 1 add -1 roll pop } ifelse	% delete the mark symbol 
} def
%
/Line { 
  NArray n 0 eq not 
    { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub def 
      n { Lineto } repeat 
      CP 4 2 roll ArrowB L pop pop 
    } if 
} def
%
/LineToYAxis {
  /Ox ED		% Save the x origin value 
  NArray            % all x-y pairs on stack
  n { 2 copy moveto % go to current point
    Ox exch Lineto   % line to y-axis
    pop             % delete old x-value
  } repeat
} def
%
/LineToXAxis{
  /Oy ED		% Save the y origin value 
  NArray		% all x-y pairs on stack
  n 0 eq not
    { n 1 eq { 0 0 /n 2 def } if
      ArrowA
      /n n 2 sub def
      CP 2 copy moveto pop Oy Lineto
      n { 2 copy moveto pop Oy Lineto } repeat
      CP
      4 2 roll
      ArrowB
      2 copy moveto pop Oy
      L
      pop pop } if
} def
%
/Arcto { 
  /a [ 6 -2 roll ] cvx def 
  a r 
  /arcto load stopped { 5 } { 4 } ifelse { pop } repeat 
  a 
} def
%
/CheckClosed { 
  dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
  and { pop pop /n n 1 sub def } if 
} def
%
/Polygon { 
  NArray n 2 eq { 0 0 /n 3 def } if 
  n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      n 2 mul -2 roll 
      /y0 ED /x0 ED /y1 ED /x1 ED  
      x1 y1 
      /x1 x0 x1 add 2 div def 
      /y1 y0 y1 add 2 div def 
      x1 y1 moveto 
      /n n 2 sub def 
      n { Lineto } repeat 
      x1 y1 x0 y0 6 4 roll Lineto
      Lineto pop pop closepath } ifelse 
} def
%
/SymbolPolygon {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 add /m ED
  2 copy m 2 roll				% copy last two
  m 2 div cvi /n ED    				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    /nSym XYLength SymStep Div cvi def
    /Shift Symbol stringwidth pop 2 Div def 
    /deltaX XLength nSym Div def
    /deltaY YLength nSym Div def
    XA Shift sub YA Shift sub moveto 
    nSym { 
      gsave rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
      grestore 
      deltaX deltaY rmoveto
    } repeat
%    XB Shift sub YB Shift sub moveto Symbol show
    /YA YB def /XA XB def
  } repeat 
  pop	% delete the mark symbol
} def
%
/Diamond { 
  /mtrx CM def 
  T rotate 
  /h ED 
  /w ED 
  dup 0 eq { pop } { CLW mul neg 
    /d ED 
    /a w h Atan def 
    /h d a sin Div h add def 
    /w d a cos Div w add def } ifelse 
  mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2 div 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false Line 
  closepath mtrx setmatrix } def
%
/Triangle { 
  /mtrx CM def 
  translate 
  rotate /h ED 2 div /w ED 
  dup CLW mul /d ED 
  /h h d w h Atan sin Div sub def 
  /w w d h w Atan 2 div dup cos exch sin Div mul sub def 
  mark 
  0 d w neg d 0 h w d 0 d 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false 
  Line 
  closepath 
  mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
  setmatrix pop 
} def
% DG/SR modification end
%
/CCA { 
  /y ED /x ED 
  2 copy y sub /dy1 ED 
  x sub /dx1 ED 
  /l1 dx1 dy1 Pyth def 
} def
%
/CC { 
  /l0 l1 def 
  /x1 x dx sub def 
  /y1 y dy sub def 
  /dx0 dx1 def 
  /dy0 dy1 def 
  CCA 
  /dx dx0 l1 c exp mul dx1 l0 c exp mul add def 
  /dy dy0 l1 c exp mul dy1 l0 c exp mul add def 
  /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos abs b exp a mul dx dy Pyth Div 2 div def 
  /x2 x l0 dx mul m mul sub def
  /y2 y l0 dy mul m mul sub def 
  /dx l1 dx mul m mul neg def 
  /dy l1 dy mul m mul neg def 
} def
%
/IC { 
  /c c 1 add def 
  c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if } ifelse 
  /a a 2 mul 3 div 45 cos b exp div def 
  CCA 
  /dx 0 def 
  /dy 0 def 
} def
%
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
%
/OpenCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { BOC /n n 3 sub def n { NC } repeat EOC } ifelse 
} def
%
/CurvePath { 
  %% for negative SymStep we calculate the distance 
  SymStep 0 lt { gsave PathLength SymStep div abs /SymStep ED grestore } if
  0.5 setflat
  flattenpath /z 0 def /z0 0 def
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def 
    x1 Shift sub y1 Shift sub moveto 
    gsave 
    curveticks 
      { x1 y1 translate startAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke      
      }
      { startAngle rotate Symbol show }
    ifelse 
    grestore /z0 z def }
  { /y ED /x ED PathLength@ z z0 sub SymStep ge {
      x Shift sub y Shift sub moveto 
      gsave 
      curveticks 
        { y yOld sub x xOld sub Atan 180 sub CorrAngle sub /rotAngle ED  
          x y translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
          Symbol show 
        }
      ifelse 
      grestore /z0 z def } if 
    /yOld y def /xOld x def } 
  {} %% the lineto part
  { /y y2 def /x x2 def PathLength@ 
    x Shift sub y Shift sub moveto 
    gsave
    curveticks 
      { y yOld sub x xOld sub Atan 180 sub /rotAngle ED  
        x y translate rotAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke
      }
      { 
        x Shift sub y Shift sub moveto 
        rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
        Symbol show 
      }
    ifelse 
    grestore
  }
  pathforall 
%  curveticks 
%   { gsave 
%     x y translate rotAngle rotate 
%     0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
%     SymbolLinewidth setlinewidth stroke grestore
%   } if
  z 
} def
%
/OpenSymbolCurve { 
  OpenCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/AltCurve { 
  { false NArray n 2 mul 2 roll 
    [ n 2 mul 3 sub 1 roll ] aload
    /Points ED 
    n 2 mul -2 roll } 
  { false NArray } ifelse 
  n 4 lt { n { pop pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse 
} def
%
/AltOpenSymbolCurve { 
  AltCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      6 copy n 2 mul 6 add 6 roll 
      IC CC x y moveto n { NC } repeat 
      closepath pop pop 
    } ifelse 
} def
%
/ClosedSymbolCurve { 
  ClosedCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/CalcBezierSpline {%  Christoph Bersch
  10 dict begin
  /getX { Points exch 2 mul get } def
  /getY { Points exch 2 mul 1 add get } def
  /n Points length 1 sub 2 idiv def
  /GetFirstControlPoints {
    /x n array def
    /tmp n array def
    /b 2 def
    x 0 rhs 0 get b div put
    1 1 n 1 sub {
      /i exch def
      tmp i 1 b div dup 4 1 roll put
      i n 1 sub lt { 4 }{ 3.5 } ifelse exch sub /b exch def
      x i rhs i get x i 1 sub get sub b div put
    } for
    1 1 n 1 sub {
      n exch sub
      dup dup x exch 1 sub 2 copy 6 2 roll
      get 3 1 roll tmp exch get
      exch x exch get mul sub
      put	
    } for
    x
  } def
  % 
  n 1 eq {
    0 getX 2 mul 1 getX add 3 div
    0 getY 2 mul 1 getY add 3 div
    exch dup 3 1 roll 2 mul 0 getX sub
    exch dup 3 1 roll 2 mul 0 getY sub
    [ 0 getX 0 getY 7 3 roll 1 getX 1 getY ] /outPoints exch def
  } {
    /outPoints 6 n mul 2 add array def
    0 1 n {
      dup dup 6 mul dup 1 add
      outPoints exch 5 -1 roll getY put
      outPoints exch 3 -1 roll getX put
    } for
    /rhs n array def
    1 1 n 2 sub {
      rhs exch dup dup getX 4 mul exch 1 add getX 2 mul add put
    } for
    rhs 0 0 getX 1 getX 2 mul add put
    rhs n 1 sub dup getX 8 mul n getX add 2 div put
    GetFirstControlPoints
    1 1 n 2 sub {
      rhs exch dup dup getY 4 mul exch 1 add getY 2 mul add put
    } for
    rhs 0 0 getY 1 getY 2 mul add put
    rhs n 1 sub dup getY 8 mul n getY add 2 div put
    GetFirstControlPoints
    0 1 n 1 sub {
      /i exch def
      2 copy
      i get outPoints 6 i mul 3 add 3 -1 roll put
      i get outPoints 6 i mul 2 add 3 -1 roll put
      2 copy
      i n 1 sub lt {
        i 1 add get i 1 add getY 2 mul exch sub outPoints 6 i mul 5 add 3 -1 roll put
        i 1 add get i 1 add getX 2 mul exch sub outPoints 6 i mul 4 add 3 -1 roll put
      }{
        n 1 sub get n getY add 2 div outPoints 6 n 1 sub mul 5 add 3 -1 roll put
        n 1 sub get n getX add 2 div outPoints 6 n 1 sub mul 4 add 3 -1 roll put
      } ifelse
    } for
    pop pop
  } ifelse
  outPoints
  end
} def
/Spline {
  /showpoints ED
  counttomark 2 div dup cvi /n ED
  n eq not { exch pop } if
  ] /Points ED
  n 1 gt {
    CalcBezierSpline
    mark exch aload pop
    ArrowA
    n 2 sub {
      6 2 roll 4 2 roll curveto
    } repeat
    6 2 roll 4 2 roll ArrowB curveto
  } if
} def
/OpenSymbolSpline {
  Spline
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def

%
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore } def
%
/FontDot { 
  DS 2 mul dup 
  matrix scale matrix concatmatrix exch matrix
  rotate matrix concatmatrix exch 
  findfont exch makefont setfont 
} def
%
/Rect { 
  x1 y1 y2 add 2 div moveto 
  x1 y2 lineto 
  x2 y2 lineto 
  x2 y1 lineto
  x1 y1 lineto 
  closepath 
} def
%
/OvalFrame { 
  x1 x2 eq y1 y2 eq or 
    { pop pop x1 y1 moveto x2 y2 L } 
    { y1 y2 sub abs x1 x2 sub abs 2 copy gt 
      { exch pop } { pop } ifelse 
      2 div exch { dup 3 1 roll mul exch } if 
      2 copy lt { pop } { exch pop } ifelse
      /b ED 
      x1 y1 y2 add 2 div moveto 
      x1 y2 x2 y2 b arcto 
      x2 y2 x2 y1 b arcto
      x2 y1 x1 y1 b arcto 
      x1 y1 x1 y2 b arcto 
      16 { pop } repeat 
      closepath 
    } ifelse 
} def
%
/Frame { 
  CLW mul /a ED 
  3 -1 roll 
  2 copy gt { exch } if 
  a sub /y2 ED 
  a add /y1 ED 
  2 copy gt { exch } if 
  a sub /x2 ED 
  a add /x1 ED 
  1 index 0 eq { pop pop Rect } { OvalFrame } ifelse 
} def
%
/BezierNArray { 
  /f ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if 
  n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat 
  f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
%
/OpenBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { ArrowA n 4 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      6 2 roll 4 2 roll ArrowB curveto } ifelse 
} def
%
/OpenSymbolBezier { 
  OpenBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { moveto n 1 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      closepath } ifelse 
} def
%
/ClosedSymbolBezier { 
  /f ED				 % save showpoints value 
  2 copy /yEnd ED /xEnd ED
  counttomark -2 roll 2 copy /yStart ED /xStart ED
  counttomark 2 roll
  f
  ClosedBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
  [ xEnd yEnd xStart yStart SymbolLine 
} def
%
/BezierShowPoints { 
  gsave 
  Points aload length 2 div cvi /n ED 
  moveto 
  n 1 sub { lineto } repeat 
  CLW 2 div SLW [ 4 4 ] 0 setdash stroke 
  grestore 
} def
%
/Parab { 
  /y0 ED /x0 ED /y1 ED /x1 ED 
  /dx x0 x1 sub 3 div def 
  /dy y0 y1 sub 3 div def 
  x0 dx sub y0 dy add x1 y1 ArrowA
  x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 x0 y0 x0 2 mul x1 sub y1 ] def 
} def
%
/Parab1 { % 1 end  |  0 SP
  /ySP ED /xSP ED /y1 ED /x1 ED 
  /dx xSP x1 sub 3 div def 
  /dy ySP y1 sub 3 div def 
  newpath x1 y1 moveto xSP y1 lineto xSP ySP lineto 
                       x1 ySP lineto closepath clip 
  currentpoint
  newpath moveto
  xSP dx sub ySP dy add x1 y1 ArrowA
  xSP dx add ySP dy add xSP 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 xSP ySP xSP 2 mul x1 sub y1 ] def 
} def
%
/Grid { 
  newpath 
  /a 4 string def 
  /b ED % 				psk@gridlabels in pt
  /c ED % 				{ \pst@usecolor\psgridlabelcolor }
  /n ED % 				psk@griddots
  cvi dup 1 lt { pop 1 } if 
  /s ED % 				\psk@subgriddiv
  s div dup 0 eq { pop 1 } if 
  /dy ED s div dup 0 eq { pop 1 } if %	\pst@number\psyunit abs
  /dx ED dy div round dy mul %		\pst@number\psxunit abs
  /y0 ED dx div round dx mul 
  /x0 ED dy div round cvi 
  /y2 ED dx div round cvi 
  /x2 ED dy div round cvi 
  /y1 ED dx div round cvi 
  /x1 ED 
  /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def 
  /w x2 x1 sub 0 gt { 1 } { -1 } ifelse def 
  b 0 gt { 
    /z1 b 4 div CLW 2 div add def
%    /Helvetica findfont b scalefont setfont 
    /b b .95 mul CLW 2 div add def } if 
  systemdict /setstrokeadjust known 
    { true setstrokeadjust /t { } def }
    { /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
       exch itransform } bind def } ifelse 
  gsave n 0 gt { 1 setlinecap [ 0 dy n div ] dy n div 2 div setdash } { 2 setlinecap } ifelse 
  /i x1 def 
  /f y1 dy mul n 0 gt { dy n div 2 div h mul sub } if def 
  /g y2 dy mul n 0 gt { dy n div 2 div h mul add } if def 
  x2 x1 sub w mul 1 add dup 1000 gt { pop 1000 } if 
  { i dx mul dup y0 moveto 
    b 0 gt 
      { gsave c i a cvs dup stringwidth pop 
        /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse 
	h 0 gt {b neg}{z1} ifelse 
        rmoveto show grestore } if 
    dup t f moveto 
    g t L stroke 
    /i i w add def 
  } repeat 
  grestore 
  gsave 
  n 0 gt
  % DG/SR modification begin - Nov. 7, 1997 - Patch 1
  %{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
    { 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
  % DG/SR modification end
    { 2 setlinecap } ifelse 
  /i y1 def 
  /f x1 dx mul n 0 gt { dx n div 2 div w mul sub } if def 
  /g x2 dx mul n 0 gt { dx n div 2 div w mul add } if def 
  y2 y1 sub h mul 1 add dup 1000 gt { pop 1000 } if 
  { newpath i dy mul dup x0 exch moveto 
    b 0 gt { gsave c i a cvs dup stringwidth pop 
      /z2 ED 
      w 0 gt {z1 z2 add neg} {z1} ifelse 
      h 0 gt {z1} {b neg} ifelse 
      rmoveto show grestore } if 
    dup f exch t moveto 
    g exch t L stroke 
    /i i h add def 
  } repeat 
  grestore 
} def
%
/ArcArrow { 
  /d ED /b ED /a ED 
  gsave 
  newpath 0 -1000 moveto clip 
  newpath 
  0 1 0 0 b 
  grestore 
  c mul 
  /e ED 
  pop pop pop r a e d PtoC y add exch x add
  exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
  mul neg d 
} def
%
%
/isbool { type (booleantype) cvn eq } def
%
/Ellipse { 
  dup isbool { /MoveToStart ED }{ /MoveToStart false def }ifelse  % false or true
  /rotAngle ED
  /mtrx CM def 
  T 
  rotAngle rotate
  scale 
  MoveToStart { 0 0 moveto 1 0 rmoveto } if  % move to the start position
  0 0 1 5 3 roll arc 
  mtrx setmatrix 
} def
%
/ArcAdjust { %%%% Vincent Guirardel
% given a target length (targetLength) and an initial angle (angle0) [in the stack],
% let  M(angle0)=(rx*cos(angle0),ry*sin(angle0))=(x0,y0).
% This computes an angle t such that (x0,y0) is at distance 
% targetLength from the point M(t)=(rx*cos(t),ry*sin(t)).
% NOTE: this an absolute angle, it does not have to be added or substracted to angle0
% contrary to TvZ's code.
% To achieve, this, one iterates the following process: start with some angle t,
% compute the point M' at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)].
% Now take t' (= new angle) so that (0,0) M(t') and M' are aligned.
%
% Another difference with TvZ's code is that we need d (=add/sub) to be defined.
% the value of d = add/sub is used to know on which side we have to move.
% It is only used in the initialisation of the angle before the iteration.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input stack:  1: target length 2: initial angle
% variables used : rx, ry, d (=add/sub)
%
  /targetLength ED /angle0 ED
  /x0 rx angle0 cos mul def
  /y0 ry angle0 sin mul def
% we are looking for an angle t such that (x0,y0) is at distance targetLength 
% from the point M(t)=(rx*cos(t),ry*sin(t)))
%initialisation of angle (using 1st order approx = TvZ's code)
  targetLength 57.2958 mul
  angle0 sin rx mul dup mul
  angle0 cos ry mul dup mul
  add sqrt div 
% if initialisation angle is two large (more than 90 degrees) set it to 90 degrees
% (if the ellipse is very curved at the point where we draw the arrow, %
% the value can be much more than 360 degrees !)
% this should avoid going on the wrong side (more than 180 degrees) or go near
% a bad attractive point (at 180 degrees)
  dup 90 ge { pop 90 } if 
  angle0 exch d % add or sub
% maximum number of times to iterate the iterative procedure:
% iterative procedure: takes an angle t on top of stack, computes a 
% better angle (and put it on top of stack)
  30 { dup
% compute distance D between (x0,y0) and M(t)
    dup cos rx mul x0 sub dup mul exch sin ry mul y0 sub dup mul add sqrt
% if D almost equals targetLength, we stop
    dup targetLength sub abs 1e-5 le { pop exit } if
% stack now contains D t
% compute the point M(t') at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]:
% M(t')= ( (x(t)-x0)*targetLength/d+x0 , (y(t)-y0)*targetLength/d+y0 )
    exch dup cos rx mul x0 sub  exch sin ry mul y0 sub
% stack contains:  y(t)-y0, x(t)-x0, d
    2 index Div targetLength mul y0 add ry Div exch
    2 index Div targetLength mul x0 add rx Div
% stack contains x(t')/rx , y(t')/ry , d
% now compute t', and remove D from stack
    atan exch pop
  } repeat
% we don't look at what happened... in particular, if targetLength is greater 
% than the diameter of the ellipse...
% the final angle will be around /angle0 + 180. maybe we should treat this pathological case...
% after iteration, stack contains an angle t such that M(t) is the tail of the arrow
% to give back the result as a an angle relative to angle0 we could add the following line:
% angle0 sub 0 exch d
%
% begin bug fix 2006-01-11
% we want to adjust the new angle t' by a multiple of 360 so that  | t'-angle0 | <= 180
%(we don't want to make the ellipse turn more or less than it should)...
dup angle0 sub dup abs 180 gt { 180 add 360 div floor 360 mul sub } { pop } ifelse
% end bug fix
} def
%
/EllipticArcArrow {
  /d ED      % is add or sub
  /b ED      % arrow procedure
  /a1 ED     % angle
  gsave
  newpath
  0 -1000 moveto
  clip                  % Set clippath far from arrow.
  newpath
  0 1 0 0 b             % Draw arrow to determine length.
  grestore
% Length of arrow is on top of stack. Next 3 numbers are junk.
%
  a1 exch ArcAdjust   % Angular position of base of arrow.
  /a2 ED
  pop pop pop
  a2 cos rx mul xOrig add % hv 2007-08-29   x->xOrig
  a2 sin ry mul yOrig add % hv 2007-08-29   y->yOrig
  a1 cos rx mul xOrig add % 
  a1 sin ry mul yOrig add % 
% Now arrow tip coor and base coor are on stack.
  b pop pop pop pop       % Draw arrow, and discard coordinates.
  a2 CLW 8 div
% change value of d (test it by looking if  `` 1 1 d '' gives 2 or not )
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse
  ArcAdjust
% resets original value of d
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse  % Adjust angle to give overlap.
} def
%%------------------ tvz/DG/hv (2004-05-10) end -------------------%%
%
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
%
/RotBegin { 
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
  /a ED 
  a Rot /RAngle [ RAngle dup a add ] cvx def 
} def
%
/RotEnd { 
  /TMatrix [ TMatrix setmatrix ] cvx def 
  /RAngle [ RAngle pop ] cvx def 
} def
%
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/Uput {
  /a ED 
  add 2 div /h ED 2 
  div /w ED 
  /s a sin def 
  /c a cos def 
  /b s abs c abs 2 copy gt dup 
    /q ED 
    { pop } { exch pop } ifelse def 
  /w1 c b div w mul def 
  /h1 s b div h mul def 
  q { w1 abs w sub dup c mul abs }{ h1 abs h sub dup s mul abs } ifelse 
} def
%
/UUput { 
  5 dict begin
  /z ED 
  abs /y ED 
  /x ED 
  q { x s div c mul abs y gt }{ x c div s mul abs y gt } ifelse 
    { x x mul y y mul sub z z mul add sqrt z add } 
    { q { x s div } { x c div } ifelse abs 
    } ifelse 
  a PtoC 
  h1 add exch 
  w1 add exch 
  end
} def
%
end
%-----------------------------------------------------------------------------%
%
% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-algparser.pro 0 0
% $Id: pst-algparser.pro 919 2014-05-19 18:42:47Z herbert $
%%
%% PostScript prologue for PSTricks algorithm parser
%% Version 0.07, 2014/08/01
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%%-----------------------------------------------------------------------------%
%
%currentdict /Pi known not { /Pi 3.14159265359 def } if
%
/AlgParser { tx@AlgToPs begin AlgToPs end } def  % Dominique Rodriguez
/I2P { AlgParser cvx exec } def  % Infix to Postfix
%
/tx@CoreAnalyzerDict 100 dict def tx@CoreAnalyzerDict begin
%
% PS ANALYZER FOR ALGEBRAIC EXPRESSION V1.13
%
% 09/2011 DR factorial with ! added
%
% E->T|E+T
% T->FS|T*FS
% FS -> F | +FS | -FS
% F->P|F^SF|P!
% P->(E)|literal
% literal->number|var|var[E]|func(params)
% params->E|E,param
% number->TOBEFINISHED
%
%% E expression, T term, SF signed factor, F factor, P power
%
%% parser
%
%% str
%
%% C->E<condition_operators>E
%% STR index -> STR index+lenExpr
/AnalyzeCond { AnalyzeExpr ReadCondOp AnalyzeExpr EvalCondOp  } def
%
%% analyze Expression List (separator , or | )
%% STR index -> STR index+lenExpr
%% /AnalyzeListOfE {
%%   { NextNonBlankChar pop AnalyzeExpr%%dup Strlen eq { exit } if NextNonBlankChar
%%     NextNonBlankChar dup 0 eq { pop exit } if
%%     dup 44 ne 1 index 124 ne and { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse } if
%%     pop NextNonBlankChar dup 0 eq { exit } if 124 ne { PROBLEMCONTACTBILLOU } if 1 add NextNonBlankChar 0 eq {toto} if } loop
%%   AnalyzeListOfEPostHook
%% } def
/AnalyzeListOfE {
  /NotFirst false def
  { NextNonBlankChar pop AnalyzeExpr
    NotFirst { EvalListOfExpr } { /NotFirst true def } ifelse
    dup Strlen eq { exit } if NextNonBlankChar
    dup 44 ne 1 index 124 ne and
    { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse }
    if  pop 1 add } loop
  AnalyzeListOfEPostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% E->T|E+T
%% STR index -> STR index+lenExpr
/AnalyzeExpr {
  AnalyzePreHook AnalyzeTerm IsEndingExpr
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeTerm PreEvalHook EvalAddSub IsEndingExpr { pop exit } if } loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% T->FS|T*FS
%% STR index
/AnalyzeTerm {
  AnalyzePreHook AnalyzeSignedFactor IsEndingTerm
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor PreEvalHook EvalMulDiv IsEndingTerm { pop exit } if} loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FS -> F | +FS | -FS
%% STR index
/AnalyzeSignedFactor {
  AnalyzePreHook 2 copy get dup IsUnaryOp
  { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor EvalUnaryOp }
  { pop AnalyzeFactor }
  ifelse AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% F->P|F^P|P!
%% STR index
/AnalyzeFactor {
  AnalyzePreHook AnalyzePower IsEndingFactor
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { dup 33 eq%% is there a ! DR 09/2011
      { pop 1 add NextNonBlankChar pop EvalFactorial }
      { RollOp 1 add NextNonBlankChar pop AnalyzePower PreEvalHook EvalPower }
      ifelse
      IsEndingFactor { pop exit } if } loop }
  ifelse  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% P->(E)|literal
%% STR index
/AnalyzePower {
  %% depending of first char either a number, or a literal
  2 copy get dup 40 eq%%an open par
  { pop 1 add NextNonBlankChar pop AnalyzeExpr 1 add NextNonBlankChar pop }
  { AnalyzeLiteral }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index STR[index] -> STR index
%/AnalyzeLiteral { IsNumber { EvalNumber } { EvalLiteral } ifelse } def
/AnalyzeLiteral { dup IsUnaryOp exch IsNumber or { EvalNumber } { EvalLiteral } ifelse } def%%dr 09102006
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% recognize + or -
%% chr -> T/F
/IsUnaryOp { dup 43 eq exch 45 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsNumber { dup 48 ge exch dup 57 le 3 -1 roll and exch 46 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadNumber {
  exch dup 3 -1 roll dup 3 1 roll
  %%read mantissa
  { 1 add  2 copy dup Strlen eq { pop pop 0 exit } if get dup IsNumber not { exit } if pop } loop
  dup 101 eq exch 69 eq or
  %%% there is a "e" or "E" -> read exponant
  { 1 add 2 copy get dup IsUnaryOp
    { pop 1 add 2 copy get } if
    { IsNumber not { exit } if 1 add 2 copy get } loop }
  if
  dup 4 1 roll
  3 -1 roll exch 1 index sub getinterval
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsCondOp { dup 30 eq exch dup 60 ge exch 62 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadCondOp {
  NextNonBlankChar 1 index 4 1 roll
  { IsCondOp not { exit } if 1 add  2 copy get } loop
  2 copy 5 -1 roll
  exch 1 index sub getinterval 3 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can contain only : 0123456789.
%% chr -> T/F
/IsLiteral {%
  dup 48 ge exch dup  57 le 3 -1 roll and exch
  dup 65 ge exch dup  90 le 3 -1 roll and 3 -1 roll or exch
  dup 97 ge exch     122 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can be of the form [a-zA-Z][a-zA-Z0-9]*\(\((Expression)\)|\(\[Expression\]\)\)?
%% STR index -> literal STR index' nextchr
/ReadLiteral {
  exch dup 3 -1 roll dup 3 1 roll
  %%read literal core
  { 2 copy dup Strlen eq { pop pop 0 exit } if get dup IsLiteral not { exit } if pop 1 add } loop
  4 1 roll dup 5 1 roll 3 -1 roll exch 1 index sub getinterval 4 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a clpar
%% STR index -> STR index STR[index] T/F
/IsEndingExpr {%
  2 copy dup Strlen eq
  %% if end of str is reached -> end !
  { pop pop 0 true }
  %% ending chr -> clpar, comma, |, <, >, =, !,
  {get dup  dup  41 eq
       exch dup 124 eq
       exch dup  93 eq
       exch dup  44 eq
       exch dup  30 eq
       exch dup  60 ge exch 62 le and or or or or or}
  ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a +-
%% STR index -> STR index STR[index] T/F
/IsEndingTerm { IsEndingExpr { true } { dup dup 43 eq exch 45 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or */
%% STR index -> STR index STR[index] T/F
/IsEndingFactor { IsEndingTerm { true } { dup dup 42 eq exch 47 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or ^
%% STR index -> STR index STR[index] T/F
/IsEndingPower { IsEndingFactor { true } { dup 94 eq } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index STR[index]
/NextNonBlankChar { { dup Strlen eq { 0 exit } if 2 copy get dup neBlkChar { exit } if pop 1 add } loop } bind def
/neBlkChar { dup 32 ne exch dup 10 ne exch 9 ne and and } bind def
%%%%%%%%%%%%%%%%%%%%%%%%
%% DEBUG
/BRK {false} def
/BRKtrue {/BRK true def} def
/BRKStop {BRK {BRKtoto} if } def
/BRKEvalStop {BRK exch if } def
/BRKBRK2true {BRK {BRK2true} if } def
/BRK2 {false} def
/BRK2true {/BRK2 true def} def
/BRK2Stop {BRK2 {BRK2toto} if } def/BRK {false} def
end
%
%-------------------------------------------------------------------------------%
%
/tx@AlgToPs 12 dict def tx@AlgToPs begin
%
%% algExpr -> PSVector
/AlgToPs { tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE pop pop EndingSequence end } def
/EndingSequence { ExpressionVector aload length /end cvx exch 1 add array astore } def
/InitParser { /ExpressionVector [ /tx@AddMathFunc cvx /begin cvx ] def dup length /Strlen exch def 0 } def
/Strlen 0 def
/EvalListOfExpr {} def%
/EvalNumber {%
    ReadNumber  cvr /ExpressionVector ExpressionVector aload length dup 3 add -1 roll cvx
    exch 1 add array astore def NextNonBlankChar pop } def
/EvalAddSub {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  43 eq { /add } { /sub } ifelse cvx exch 1 add array astore def
} def
/EvalMulDiv {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  42 eq { /mul } { /div } ifelse cvx exch 1 add array astore def
} def
/EvalPower {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  pop /exp cvx exch 1 add array astore def
} def
/EvalFactorial {% DR 09/2011
  /ExpressionVector ExpressionVector aload length
  /fact cvx exch 1 add array astore def
} def
/EvalLiteral {%
  ReadLiteral
  dup 40 eq%%% there is an open par -> function call
  { pop 2 index
    dup (Sum) eq { EvalSum }
    { dup (IfTE) eq { EvalCond }
      { dup (Derive) eq { pop EvalDerive }
	{ pop 1 add NextNonBlankChar pop AnalyzeListOfE 2 index TrigoFunc
          /ExpressionVector ExpressionVector aload length dup 5 add -1 roll cvn cvx
	  exch 1 add array astore def 1 add NextNonBlankChar pop } ifelse } ifelse} ifelse }
  { /ExpressionVector ExpressionVector aload length dup 6 add -1 roll cvn cvx exch 1 add array astore def
    dup 91 eq%%% there is an open bracket -> vector element
    { pop 1 add NextNonBlankChar pop AnalyzeExpr
      /ExpressionVector ExpressionVector aload length /cvi cvx exch /get cvx exch 2 add array astore def 1 add }
    { pop NextNonBlankChar pop }
    ifelse}
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% the derive function : Derive(n,f(x))
%% firstparindex lastparindex ->
/EvalDerive {
  %% manage the function descripiton
  1 add ReadNumber 3 1 roll NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  1 add NextNonBlankChar pop
  3 -1 roll cvi
  dup 0 eq
  { pop AnalyzeExpr 3 -1 roll pop 1 add }
  { 1 sub 3 1 roll (x)  exch tx@Derive begin DeriveIndexed end 4 -1 roll
    { (x) tx@Derive begin Derive end } repeat
    ExpressionVector exch /ExpressionVector [] def
    AlgToPs aload length
    /ExpressionVector 1 index 3 add -1 roll aload length dup 3 add -1 roll  /l2 exch def /l1 exch def
    l1 l2 add 1 add l2 neg roll l1 l2 add array astore def 3 -1 roll pop 1 add
    1 index length /Strlen exch def } ifelse
} def
/EvalSum {%
  pop 1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  /ExpressionVector ExpressionVector aload length dup 7 add -3 roll 0 4 1 roll
  5 -1 roll 4 add array astore def
  %% keep ExpressionVector for later and create a new one for internal Sum computation
  ExpressionVector 3 1 roll /ExpressionVector [ 6 -1 roll cvn /exch cvx /def cvx ] def
  1 add NextNonBlankChar pop AnalyzeExpr
  %% add each term
  /ExpressionVector ExpressionVector aload length 1 add /add cvx exch array astore def
  /ExpressionVector 4 -1 roll aload length ExpressionVector cvx /for cvx 3 -1 roll 2 add
  array astore def 3 -1 roll pop 1 add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length 3.1415926 /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
/EvalCond {%
  pop 1 add AnalyzeCond NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  ExpressionVector 3 1 roll /ExpressionVector [] def
  1 add AnalyzeExpr ExpressionVector 3 1 roll /ExpressionVector [] def
  NextNonBlankChar 44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add AnalyzeExpr
  NextNonBlankChar 41 ne { ANALYZER_ERROR_missing_ending parenthesis_in_IfTE } if
  ExpressionVector
  /ExpressionVector 6 -1 roll aload length dup
  6 add -1 roll cvx exch dup 4 add -1 roll cvx /ifelse cvx 3 -1 roll 3 add array astore def
  1 add 3 -1 roll pop
} def
%% CondOp STR index
/EvalCondOp {%
  3 -1 roll
  dup (=) eq  { /eq } {%
  dup (<) eq  { /lt } {%
  dup (>) eq  { /gt } {%
  dup (>=) eq { /ge } {%
  dup (<=) eq { /ge } {%
  dup (!=) eq { /ne } { ERROR_non_valid_conditional_operator }
  ifelse } ifelse } ifelse } ifelse } ifelse } ifelse
  cvx exch pop
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll exch 1 add array astore def } def
/EvalUnaryOp {
  3 -1 roll 45 eq { /ExpressionVector ExpressionVector aload length /neg cvx exch 1 add array astore def } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook {} bind def
/PreEvalHook {} bind def
/AnalyzeListOfEPostHook {} bind def
/AnalyzePostHook {} def
/RollOp { 3 1 roll } bind def
end   %tx@CoreAnalyzerDict
%
%--------------------------------------------------------------------%
%
/tx@Derive 41 dict def tx@Derive begin
%%increase ^^ for each function added
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable -> PSVector
/Derive {
  10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE end
} def
/Strlen 0 def
/InitParser { dup length /Strlen exch def 0 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable index -> PSVector
/DeriveIndexed {%
  3 1 roll 10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser pop 4 -1 roll AnalyzeExpr 4 -2 roll pop pop 4 -2 roll exch pop end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u,v)'=-(u',v')
/EvalListOfExpr {%
  4 2 roll 2 copy 9 -1 roll dup length 4 1 roll putinterval add AddPipe
           2 copy 7 -1 roll dup length 4 1 roll putinterval add
  6 -2 roll pop pop
  2 copy pop 0 6 2 roll GetIntervalNewStr 5 1 roll 2 copy 0 exch getinterval 6 1 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (-u)'=-(u')
/EvalUnaryOp {
  4 -2 roll 4 index (0) eq
  { (0) StrConcat 7 -1 roll pop }
  { 7 -1 roll 45 eq
    { AddSub AddOpPar true } { false } ifelse
    3 1 roll 5 index StrConcat 3 -1 roll { AddClPar } if } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  7 -2 roll pop pop 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (number)'=0
/EvalNumber { ReadNumber (0) 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u+v)'=u'+v'
/EvalAddSub {%
  7 index dup (0) eq
  { pop true }%% du=0 nothing added
  { dup length exch 5 index 5 index 3 -1 roll putinterval 4 -1 roll add 3 1 roll false }
  ifelse
  5 index dup (0) eq
  { pop { (0) } { 4 -2 roll 2 copy pop 0  6 2 roll GetIntervalNewStr } ifelse }%%dv=0
  { exch
    { 5 -2 roll 7 index 45 eq { AddSub } if false } %%nothing yet added
    { 5 -2 roll 7 index 43 eq%%something yet added
      { AddAdd false } { AddSub AddOpPar true } ifelse }
    ifelse 11 1 roll
    3 -1 roll StrConcat 10 -1 roll { AddClPar } if
    2 copy pop 0 6 2 roll GetIntervalNewStr }
  ifelse
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)' or (u/v)'
/EvalMulDiv { 6 index 42 eq {EvalMul} {EvalDiv} ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)'=u'*v+u*v'
/EvalMul {%
  4 -2 roll 7 index dup (0) eq
  { pop false }%%du=0
  { (1) eq%%du=1
    { false }
    { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
    3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if
    true }%%du!=0
  ifelse
  5 1 roll 5 index (0) eq
  { 5 -1 roll not { (0) StrConcat } if }%%dv=0
  { 5 -1 roll { AddAdd } if
    4 index (1) eq
    { 8 index StrConcat }
    { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
    ifelse
  }%%dv!=0
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u/v)'=(u'*v-u*v')/v^2
/EvalDiv {%
  4 -2 roll
  4 index (0) eq%%dv=0 -> u'/v
  { 7 index (0) eq { (0) StrConcat } { AddOpPar 7 index StrConcat AddClPar AddDiv 5 index StrConcat } ifelse }
  { 7 index dup (0) eq
    { pop }%%du=0
    { (1) eq%%du=1
      { false }
      { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
      3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if}%%du!=0
    ifelse
      AddSub
      4 index (1) eq
      { 8 index StrConcat }
      { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
      ifelse
    %}%%dv!=0
    2 copy GetIntervalNewStr 3 1 roll pop 0 AddOpPar 3 -1 roll StrConcat AddClPar
    AddDiv AddOpPar 5 index StrConcat AddClPar 2 copy (^2) putinterval 2 add }
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str1 index str2 -> str1 index
/StrConcat { dup length 4 2 roll 2 copy 6 -1 roll putinterval 3 -1 roll add } bind def
/GetIntervalNewStr { 0 exch getinterval dup length string copy } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u^v)'=(u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
/EvalPower {%
  4 -2 roll 7 index (0) eq
  {%%if du=0 then (u^v)'=v'ln(u)u^v
    4 index (0) eq
    { (0) StrConcat }%%if dv=0 then (u^v)'=0
    { 4 index (1) ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if
      8 index (e) ne { (ln\() StrConcat 8 index StrConcat (\)*) StrConcat } if
      AddOpPar 8 index StrConcat (\)^\() StrConcat 5 index StrConcat AddClPar } ifelse
  }
  {%%du!=0
    4 index (0) eq
    {%%if dv=0 then (u^v)'=vu'u^(v-1)
      5 index dup IsStrNumber
      { dup (0) eq
        { StrConcat }
        { dup dup (1) eq exch (1.0) eq or
          { StrConcat  }
	  { StrConcat
	    7 index dup (1) ne exch (1.0) ne and%%%dr 09102006 insert du if <> 1
	    { (*\() StrConcat 7 index StrConcat (\)) StrConcat } if%%%dr 09102006
            (*\() StrConcat 8 index StrConcat (\)) StrConcat
            5 index  dup dup (2) eq exch (2.0) eq or
	    { pop } { cvr 1 sub 20 string cvs 3 1 roll (^) StrConcat 3 -1 roll StrConcat } ifelse } ifelse } ifelse }
      { pop AddOpPar 5 index StrConcat (\)*\() StrConcat 8 index StrConcat (\)^\() StrConcat
        5 index StrConcat (-1\)) StrConcat } ifelse
    }
    {%%if dv!=0 and du!=0 then (u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
      7 index (1) ne { AddOpPar 7 index StrConcat (\)*) StrConcat } if
      AddOpPar 5 index StrConcat (\)*\() StrConcat
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (-1\)+\() StrConcat
      4 index (1) ne { 4 index StrConcat (\)*\() StrConcat } if
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (\)*ln\() StrConcat
      8 index StrConcat AddClPar
    } ifelse
  } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for factorial ! only cst => null derivative
/EvalFactorial {% DR 09/2011
  4 index (0) eq
  { (0) mark 8 -2 roll  cleartomark 2 index 7 index dup 4 index exch sub getinterval exch 6 2 roll }
  { DERIVATIVE_ENGINE_ERROR_no_variable_in_factorial } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str -> true/false
/IsStrNumber {%
  true exch
  { dup 48 lt exch dup 57 gt 3 -1 roll or
    exch dup 46 ne%%.
    exch dup 43 ne%%+
    exch 45 ne%%-
    and and and { pop false } if } forall
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalLiteral {%
  ReadLiteral dup 40 eq%%% there is an open par -> function call
  { pop (EvalFunc_             ) 9 4 index StrConcat 0 exch getinterval cvn cvx exec }
  { dup 91 eq%%% there is an open bracket -> vector element
    { DERIVATIVE_ENGINE_ERROR_vector_not_yet_implemented }
    { pop EvalVariable }
    ifelse }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% first last parpos Expr[first:parpos-1] ->
/EvalVariable { 2 index Variable eq { (1) } { (0) } ifelse 4 -1 roll exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (f(u))'=u'f'(u)
/EvalFunc {
  4 2 roll 4 index (1) ne
  { AddOpPar 4 index StrConcat (\)*) StrConcat } if
  (Eval             ) 4 8 index StrConcat 0 exch getinterval cvn cvx exec
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Func derivative -> Eval<func>
/EvalFunc_sin {%
  PreCommonFunc
  { (cos\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_cos {%
  PreCommonFunc
  { (\(-sin\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_tan {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/cos\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_asin {%
  PreCommonFunc
  { (1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_acos {%
  PreCommonFunc
  { (-1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_atg {%
  PreCommonFunc
  { (1/\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_floor {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ln {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_exp {%
  PreCommonFunc
  {  (exp\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_EXP {%
  PreCommonFunc
  {  (EXP\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_sqrt {%
  PreCommonFunc
  { dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\(2*sqrt\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Fact {%
  PreCommonFunc { DERIVATIVE_ENGINE_ERROR_no_variable_expression_in_Fact } if
  PostCommonFunc } def
/EvalFunc_sh {%
  PreCommonFunc
  { (ch\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ch {%
  PreCommonFunc
  { (sh\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_th {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/ch\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argsh {%
  PreCommonFunc
  { (1/sqrt\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argch {%
  PreCommonFunc
  { (1/sqrt\(\() StrConcat 5 index StrConcat (\)^2-1\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argth {%
  PreCommonFunc
  { (1/\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/PreCommonFunc {
  1 add NextNonBlankChar pop 3 -1 roll 5 1 roll AnalyzeExpr 1 add NextNonBlankChar pop
  4 2 roll 4 index (0) eq
  { (0) StrConcat false }
  { 4 index (1)  ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if true } ifelse
} def
/PostCommonFunc {
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
/EvalFunc_Derive {%
  1 add ReadNumber cvi 1 add dup cvr log 1 add cvi string cvs
  4 -1 roll pop 5 1 roll 1 add NextNonBlankChar pop AnalyzeExpr 1 add
  4 -2 roll (Derive\() StrConcat 7 -1 roll StrConcat (,) StrConcat 6 -1 roll StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr 6 -1 roll pop 2 index 6 index dup 4 index exch sub getinterval
  exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_Sum {%
  1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop 3 -1 roll pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_third_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_fourth_comma_in_Sum } if
  1 add NextNonBlankChar pop dup 6 1 roll 3 -1 roll pop AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 8 index dup 9 index exch sub getinterval StrConcat
  4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_IfTE {%
  3 -1 roll pop 1 add NextNonBlankChar pop SkipCond
  NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  1 add NextNonBlankChar pop dup 5 1 roll
  AnalyzeExpr NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add NextNonBlankChar pop
  AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 10 index dup 11 index exch sub getinterval StrConcat
  6 index StrConcat (,) StrConcat 4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% advance in str until a comma is found (no error detection!)
%% str index -> str index'
/SkipCond { { 1 add 2 copy get 44 eq {exit } if } loop } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for condition....
/EvalCondOp { 3 -1 roll pop } bind def
/PutIntervalOneAdd {putinterval 1 add} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddOpPar {2 copy (\() PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add close parenthesis in string at the given index
%% str index -> str index+1
/AddClPar {2 copy (\)) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add 0 in string at the given index
%% str index -> str index+1
/AddZero {2 copy (0) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddMul {2 copy (*) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddDiv {2 copy (/) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a plus sign in string at the given index
%% str index -> str index+1
/AddAdd {2 copy (+) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a minus sign in string at the given index
%% str index -> str index+1
/AddSub {2 copy (-) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a pipe sign in string at the given index
%% str index -> str index+1
/AddPipe {2 copy (|) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook { dup 5 1 roll } bind def
/PreEvalHook {} def
/AnalyzePostHook { 7 -1 roll pop } bind def
/AnalyzeListOfEPostHook { 6 -1 roll mark 6 1 roll cleartomark } bind def
/RollOp { 5 1 roll } bind def
end%%%tx@CoreAnalyzerDict
/tx@AddMathFunc 12 dict def tx@AddMathFunc begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NEW FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% function arcsine in radians asin(x)=atan(x/sqrt(1-x^2))
%% x -> theta
/asin {%
  dup abs 1 gt { EQDFasinrangeerror  } if
  dup dup dup mul 1 exch sub sqrt atan exch 0 lt { 360 sub } if DegtoRad
} def
%% function arccosine in radians acos(x)=atan(sqrt(1-x^2)/x)
%% x -> theta
/acos {%
  dup abs 1 gt { EQDFacosrangeerror  } if
  dup dup mul 1 exch sub sqrt exch atan DegtoRad
} def
%% function arctangent in radians
%% x -> theta
/atg { 1 atan dup 90 gt { 360 sub } if DegtoRad } bind def
%% HYPERBOLIC FUNCTIONS
/sh { dup Ex exch neg Ex sub 2 div } def
/ch { dup Ex exch neg Ex add 2 div } def
/th { dup sh exch ch div } def
/Argsh { dup dup mul 1 add sqrt add ln } def
/Argch { dup dup mul 1 sub sqrt add ln } def
/Argth { dup 1 add exch 1 exch sub div ln 2 div } def
%% modified exponential funtion for 0
%% x n -> x^n
/Exp { dup 0 eq { pop pop 1 } { exp } ifelse } bind def
%% modified exponential funtion for 0
%% x -> e^x
/Ex { Euler exch exp } bind def
%%
%% factorial function
%% n -> n!
/Fact { 1 exch 2 exch 1 exch { mul } for } bind def
/fact { Fact } bind def
/! { Fact } bind def
end
%
% END pst-algparser.pro

%%EndProcSet
%%BeginProcSet: pst-tools.pro 0 0
% $Id: pst-tools.pro 842 2013-10-26 10:25:41Z herbert $
%
%% PostScript tools prologue for pstricks.tex.
%% Version 0.04, 2013/10/26
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
/Pi2 1.57079632679489661925640 def
/factorial { % n on stack, returns n! 
  dup 0 eq { 1 }{ 
    dup 1 gt { dup 1 sub factorial mul } if }
  ifelse } def 
%
/MoverN { % m n on stack, returns the binomial coefficient m over n
  2 dict begin
  /n exch def /m exch def
  n 0 eq { 1 }{
    m n eq { 1 }{
      m factorial n factorial m n sub factorial mul div } ifelse } ifelse 
  end
} def
%
/ps@ReverseOrderOfPoints { % on stack [P1 P2 P3 ...Pn]=>[Pn,Pn-1,...,P2,P1]
  5 dict begin       % all local
  aload length /n ED % number of coors
  n 2 div cvi /m ED  % number of Points
  /n1 n def
  m { n1 2 roll /n1 n1 2 sub def } repeat
  n array astore
  end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% subroutines for complex numbers, given as an array [a b] 
% which is a+bi = Real+i Imag
%
/cxadd {		% [a1 b1] [a2 b2] = [a1+a2 b1+b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  3 -1 roll		% [a2 b2] a2 [a1 b1]
  dup 0 get		% [a2 b2] a2 [a1 b1] a1
  3 -1 roll		% [a2 b2] [a1 b1] a1 a2
  add			% [a2 b2] [a1 b1] a1+a2
  3 1 roll		% a1+a2 [a2 b2] [a1 b1]
  1 get			% a1+a2 [a2 b2] b1
  exch 1 get		% a1+a2 b1 b2
  add 2 array astore
} def
%
/cxneg {		% [a b]
  dup 1 get		% [a b] b
  exch 0 get		% b a
  neg exch neg		% -a -b
  2 array astore
} def
%
/cxsub { cxneg cxadd } def  % same as negative addition
%
% [a1 b1][a2 b2] = [a1a2-b1b2 a1b2+b1a2] = [a3 b3]
/cxmul {		% [a1 b1] [a2 b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  exch 1 get		% [a1 b1] a2 b2
  3 -1 roll		% a2 b2 [a1 b1]
  dup 0 get		% a2 b2 [a1 b1] a1
  exch 1 get		% a2 b2 a1 b1
  dup			% a2 b2 a1 b1 b1
  5 -1 roll dup		% b2 a1 b1 b1 a2 a2
  3 1 roll mul		% b2 a1 b1 a2 b1a2
  5 -2 roll dup		% b1 a2 b1a2 b2 a1 a1
  3 -1 roll dup		% b1 a2 b1a2 a1 a1 b2 b2
  3 1 roll mul		% b1 a2 b1a2 a1 b2 a1b2
  4 -1 roll add		% b1 a2 a1 b2 b3
  4 2 roll mul		% b1 b2 b3 a1a2
  4 2 roll mul sub	% b3 a3
  exch 2 array astore
} def
%
% [a b]^2 = [a^2-b^2 2ab] = [a2 b2]
/cxsqr {		% [a b]   square root
  dup 0 get exch 1 get	% a b
  dup dup mul		% a b b^2
  3 -1 roll		% b b^2 a
  dup dup mul 		% b b^2 a a^2
  3 -1 roll sub		% b a a2
  3 1 roll mul 2 mul	% a2 b2	
  2 array astore
} def
%
/cxsqrt {		% [a b]
%  dup cxnorm sqrt /r exch def
%  cxarg 2 div RadtoDeg dup cos r mul exch sin r mul cxmake2 
  cxlog 		% log[a b]
  2 cxrdiv 		% log[a b]/2
  aload pop exch	% b a
  2.781 exch exp	% b exp(a)
  exch cxconv exch	% [Re +iIm] exp(a)
  cxrmul		%
} def
%
/cxarg { 		% [a b] 
  aload pop 		% a b
  exch atan 		% arctan b/a
  DegtoRad 		% arg(z)=atan(b/a)
} def
%
% log[a b] = [a^2-b^2 2ab] = [a2 b2]
/cxlog {		% [a b]
  dup 			% [a b][a b]
  cxnorm 		% [a b] |z|
  log 			% [a b] log|z|
  exch 			% log|z|[a b]
  cxarg 		% log|z| Theta
  cxmake2 		% [log|z| Theta]
} def
%
% square of magnitude of complex number
/cxnorm2 {		% [a b]
  dup 0 get exch 1 get	% a b
  dup mul			% a b^2
  exch dup mul add	% a^2+b^2
} def
%
/cxnorm {		% [a b]
  cxnorm2 sqrt
} def
%
/cxconj {		% conjugent complex
  dup 0 get exch 1 get	% a b
  neg 2 array astore	% [a -b]
} def
%
/cxre { 0 get } def	% real value
/cxim { 1 get } def	% imag value
%
% 1/[a b] = ([a -b]/(a^2+b^2)
/cxrecip {		% [a b]
  dup cxnorm2 exch	% n2 [a b]
  dup 0 get exch 1 get	% n2 a b
  3 -1 roll		% a b n2
  dup			% a b n2 n2
  4 -1 roll exch div	% b n2 a/n2
  3 1 roll div		% a/n2 b/n2
  neg 2 array astore
} def
%
/cxmake1 { 0 2 array astore } def % make a complex number, real given
/cxmake2 { 2 array astore } def	  % dito, both given
%
/cxdiv { cxrecip cxmul } def
%
% multiplikation by a real number
/cxrmul {		% [a b] r
  exch aload pop	% r a b
  3 -1 roll dup		% a b r r
  3 1 roll mul		% a r b*r
  3 1 roll mul		% b*r a*r
  exch 2 array astore   % [a*r b*r]
} def
%
% division by a real number
/cxrdiv {		% [a b] r
  1 exch div		% [a b] 1/r
  cxrmul
} def
%
% exp(i theta) = cos(theta)+i sin(theta) polar<->cartesian
/cxconv {		% theta
  RadtoDeg dup sin exch cos cxmake2
} def

%%%%% ### bubblesort ###
%% syntax : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort { % on stack must be an array [ ... ]
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a % return the sorted array
end
} def
%
/concatstringarray{  %  [(a) (b) ... (z)] --> (ab...z)  20100422
  0 1 index { length add } forall 
  string     
  0 3 2 roll      
  { 3 copy putinterval length add }forall 
  pop  
} bind def
%
/dot2comma {% on stack a string (...) 
  2 dict begin
  /Output exch def
  0 1 Output length 1 sub { 
    /Index exch def 
    Output Index get 46 eq { Output Index 44 put } if 
  } for
  Output
  end
} def
%
/rightTrim { % on stack the string and the character number to be stripped  
  /charNo exch def
  dup
  length 1 sub -1 0 { 
    /i exch def dup i get charNo ne { exit } if 
  } for
  0 i 1 add getinterval
  dup length string copy
} bind def  % leaves the stripped string on the stack

/psStringwidth /stringwidth load def
/psShow /show load def

%/stringwidth{ 32 rightTrim psStringwidth } bind def

%/show { 32 rightTrim psShow } bind def
%-----------------------------------------------------------------------------%

/pgffunctions {
    /pgfsc{}bind def% stroke color is empty by default
    /pgffc{}bind def% fill color is empty by default
    /pgfstr{stroke}bind def%
    /pgffill{fill}bind def%
    /pgfeofill{eofill}bind def%
    /pgfe{a dup 0 rlineto exch 0 exch rlineto neg 0 rlineto closepath}bind def% rectangle
    /pgfw{setlinewidth}bind def% setlinewidth
    /pgfs{save pgfpd 72 Resolution div 72 VResolution div neg scale 
      magscale{1 DVImag div dup scale}if 
      pgfx neg pgfy neg translate pgffoa .setopacityalpha}bind def% save
    /pgfr{pgfsd restore}bind def %restore
    userdict begin%
    /pgfo{pgfsd /pgfx currentpoint /pgfy exch def def @beginspecial}bind def %open
    /pgfc{newpath @endspecial pgfpd}bind def %close
    /pgfsd{globaldict /pgfdelta /delta where {pop delta} {0} ifelse put}bind def% save delta
    /pgfpd{/delta globaldict /pgfdelta get def}bind def % put delta
    /.setopacityalpha where {pop} {/.setopacityalpha{pop}def} ifelse % install .setopacityalpha 
    /.pgfsetfillopacityalpha{/pgffoa exch def
      /pgffill{gsave pgffoa .setopacityalpha fill 1 .setopacityalpha newpath fill grestore newpath}bind def
      /pgfeofill{gsave pgffoa .setopacityalpha eofill 1 .setopacityalpha newpath eofill grestore newpath}bind def}bind def
    /.pgfsetstrokeopacityalpha{/pgfsoa exch def /pgfstr{gsave pgfsoa .setopacityalpha stroke grestore newpath}bind def}bind def
    /pgffoa 1 def
    /pgfsoa 1 def
    end
} def
%-----------------------------------------------------------------------------%
% END pst-tools.pro

%%EndProcSet
%%BeginProcSet: pst-dots.pro 0 0
% $Id: pst-dots.pro 801 2013-07-09 18:10:41Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 2.02,  2009/06/16
%%
%% For distribution, see pstricks.tex.
%%
%% Timothy Van Zandt <tvz@Princeton.EDU>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% Modified by Etienne Riga  - Dec. 16, 1999
%% Modified by Etienne Riga  - 2005/01/01 (er)
%% to add /Diamond, /SolidDiamond and /BoldDiamond
%% Modified by Herbert Voss (hv) - 2008/04/17 
%
10 dict dup begin			% hold local
  /FontType 3 def
  /FontMatrix [.001 0 0 .001 0 0] def
%  /FontBBox [-571.5 -742.5 571.5 742.5] def % changed to next line 20060616 hv
  /FontBBox [-1000 -1000 1000 1000] def  % See end of file in /BuildGlyph
  /Encoding 256 array def
  0 1 255 {Encoding exch /.notdef put} for % fill the array with /.notdef
  Encoding				   % replace with given dot names
    dup (b) 0 get /Bullet put		   % get the numerical position of b in ASCII
%					   % and save /Bullet at this place in Encoding 
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put	% 67
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
%%%		  
    dup (k) 0 get /Asterisk put
    dup (K) 0 get /BoldAsterisk put
    dup (J) 0 get /SolidAsterisk put
    dup (h) 0 get /Hexagon put
    dup (H) 0 get /BoldHexagon put
    dup (G) 0 get /SolidHexagon put
    dup (f) 0 get /Octogon put		% 2008-04-18 hv
    dup (F) 0 get /BoldOctogon put	% 2008-04-18 hv
    dup (g) 0 get /SolidOctogon put	% 2008-04-18 hv
    dup (a) 0 get /Add put
    dup (A) 0 get /BoldAdd put 		% 65
    dup (x) 0 get /Mul put
    dup (X) 0 get /BoldMul put
    dup (m) 0 get /Oplus put
    dup (M) 0 get /BOplus put
    dup (e) 0 get /SolidOplus put
    dup (n) 0 get /Otimes put
    dup (N) 0 get /BOtimes put
    dup (E) 0 get /SolidOtimes put
    dup (i) 0 get /Bar put
    dup (I) 0 get /BoldBar put
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
%%%  
/CharProcs 47 dict def
CharProcs begin
  /CirclePath {0 0 500 0 360 arc closepath} def
  /Bullet {CirclePath fill} def
  /Circle {CirclePath .9 .9 scale CirclePath eofill} def
  /BoldCircle {CirclePath .8 .8 scale CirclePath eofill} def
  /TrianglePath {0 660 moveto -571.5 -330 lineto 571.5 -330 lineto closepath} def
  /SolidTriangle {TrianglePath fill} def
  /Triangle {TrianglePath .85 .85 scale TrianglePath eofill} def
  /BoldTriangle {TrianglePath .7 .7 scale TrianglePath eofill} def
  /SquarePath {-450 450 moveto 450 450 lineto 450 -450 lineto -450 -450 lineto closepath} def
  /SolidSquare {SquarePath fill} def
  /Square {SquarePath .89 .89 scale SquarePath eofill} def
  /BoldSquare {SquarePath .78 .78 scale SquarePath eofill} def
  /PentagonPath {
    -337.8 -465 moveto 337.8 -465 lineto 546.6 177.6 lineto
    0 574.7 lineto -546.6 177.6 lineto closepath
  } def
  /SolidPentagon {PentagonPath fill} def
  /Pentagon {PentagonPath .89 .89 scale PentagonPath eofill} def
  /BoldPentagon {PentagonPath .78 .78 scale PentagonPath eofill} def
%-------------- hv begin 2004/07/25   from: er 2003/03/24
  /HexagonPath {
    0 550 moveto -476 275 lineto -476 -275 lineto
    0 -550 lineto 476 -275 lineto 476 275 lineto closepath
  } def
  /SolidHexagon {HexagonPath fill} def
  /Hexagon {HexagonPath .89 .89 scale HexagonPath eofill} def
  /BoldHexagon {HexagonPath .79 .79 scale HexagonPath eofill} def
%					2008-04-18 hv
  /OctogonPath { 
     550 dup 22.5 tan mul dup neg dup add /xMove exch def 
     exch moveto 7 { xMove 0 rlineto 45 rotate } repeat closepath } def 
  /SolidOctogon { OctogonPath fill                             } def
  /Octogon {      OctogonPath .89 .89 scale OctogonPath eofill } def
  /BoldOctogon {  OctogonPath .79 .79 scale OctogonPath eofill } def
%
  /AsteriskPath {
    20 0 moveto 10 250 180 500 0 500 curveto
    -180 500 -10 250 -20 0 curveto closepath
  } def
  /Asterisk {
    AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath
    60 rotate AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath fill
  } def
%
  /Basterp {50 250 220 500 0 500 curveto -220 500 -50 250 -50 30 cos 100 mul curveto} def
  /BoldAsteriskPath {
    50 30 cos 100 mul moveto  Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp closepath
  } def
  /BoldAsterisk {BoldAsteriskPath fill} def
  /SolidAsterisk {CirclePath .9 .9 scale BoldAsteriskPath eofill} def
  /CrossPath {
    40 550 moveto -40 550 lineto -40 40 lineto -550 40 lineto
    -550 -40 lineto -40 -40 lineto -40 -550 lineto 40 -550 lineto 
    40 -40 lineto 550 -40 lineto 550 40 lineto 40 40 lineto closepath
  } def
  /BoldCrossPath {80 550 moveto -80 550 lineto -80 80 lineto -550 80 lineto
    -550 -80 lineto -80 -80 lineto -80 -550 lineto 80 -550 lineto 
    80 -80 lineto 550 -80 lineto 550 80 lineto 80 80 lineto closepath
  } def
  /Add {CrossPath fill} def
  /Mul {45 rotate CrossPath fill} def
  /BoldAdd {BoldCrossPath fill} def
  /BoldMul {45 rotate BoldCrossPath fill} def
  /Oplus {CirclePath .9 .9 scale CirclePath eofill .775 .775 scale CrossPath fill } def 
  /SolidOplus {CirclePath .775 .775 scale BoldCrossPath eofill} def 
  /BOplus {CirclePath .8 .8 scale CirclePath eofill .775 .775 scale BoldCrossPath fill} def 
  /Otimes {CirclePath .9 .9 scale CirclePath eofill 45 rotate .775 .775 scale CrossPath fill} def 
  /BOtimes {CirclePath .8 .8 scale CirclePath eofill 45 rotate .775 .775 scale BoldCrossPath fill } def 
  /SolidOtimes {CirclePath 45 rotate .775 .775 scale BoldCrossPath eofill} def 
  /BarPath {40 660 moveto -40 660 lineto -40 -660 lineto 40 -660 lineto closepath} def
  /Bar {BarPath fill} def
  /BoldBarPath {80 660 moveto -80 660 lineto -80 -660 lineto 80 -660 lineto closepath} def
  /BoldBar {BoldBarPath fill} def
  /DiamondPath {0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto 428.5 0 lineto closepath} def
  /SolidDiamond {DiamondPath fill} def
  /Diamond {DiamondPath .865 .865 scale DiamondPath eofill} def
  /BoldDiamond {DiamondPath .73 .73 scale DiamondPath eofill} def
%%%
  /.notdef { } def
end
%
/BuildGlyph {
  exch
  begin 		
%  Metrics 1 index get exec 0
    0 0
%      BBoxes 3 index get exec
    -1000 -1000 1000 1000
%     -571.5 -742.5 571.5 742.5
    setcachedevice
    CharProcs begin load exec end
  end
} def
%
/BuildChar {
  1 index /Encoding get exch get
  1 index /BuildGlyph get exec
} bind def
%
end
/PSTricksDotFont exch definefont pop
%
%% end

%%EndProcSet
%%BeginProcSet: pst-barcode.pro 0 0
%!PS

% Barcode Writer in Pure PostScript - Version 2015-05-09
% http://bwipp.terryburton.co.uk
%
% Copyright (c) 2004-2014 Terry Burton
%
% Permission is hereby granted, free of charge, to any
% person obtaining a copy of this software and associated
% documentation files (the "Software"), to deal in the
% Software without restriction, including without
% limitation the rights to use, copy, modify, merge,
% publish, distribute, sublicense, and/or sell copies of
% the Software, and to permit persons to whom the Software
% is furnished to do so, subject to the following
% conditions:
%
% The above copyright notice and this permission notice
% shall be included in all copies or substantial portions
% of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
% KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
% THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
% PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
% THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
% DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
% CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
% CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
% IN THE SOFTWARE.
%
% --BEGIN TEMPLATE--
%
% --BEGIN RESOURCE preamble--
%%BeginResource: Category uk.co.terryburton.bwipp 0.0 2015050900 31191 34576
%%BeginData:          6 ASCII Lines
currentglobal
true setglobal
/Generic /Category findresource dup length 1 add dict copy dup
/InstanceType /setpacking where {pop /packedarraytype} {/arraytype} ifelse put
/uk.co.terryburton.bwipp exch /Category defineresource pop
setglobal
%%EndData
%%EndResource
% --END RESOURCE preamble--
%
% --BEGIN RESOURCE raiseerror--
% --REQUIRES preamble--
%%BeginResource: uk.co.terryburton.bwipp raiseerror 0.0 2015050900 44890 44440
%%BeginData:         13 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
begin
/raiseerror {
  $error exch /errorinfo exch put
  $error exch /errorname exch put
  $error /command null put
  $error /newerror true put 
  handleerror quit
} bind def
/raiseerror dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END RESOURCE raiseerror--

% --BEGIN RENDERER renlinear--
% --REQUIRES preamble raiseerror--
%%BeginResource: uk.co.terryburton.bwipp renlinear 0.0 2015050900 76908 76502
%%BeginData:        237 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
begin
/renlinear {
%
    20 dict begin          % Confine variables to local scope
%
    /args exch def   % We are given some arguments
%
    % Default options
    /sbs [] def
    /bhs [] def
    /bbs [] def
    /txt [] def
    /barcolor (unset) def
    /includetext false def
    /textcolor (unset) def
    /textxalign (unset) def
    /textyalign (unset) def
    /textfont (Courier) def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset 0 def
    /textgaps 0 def
    /alttext () def
    /bordercolor (unset) def
    /backgroundcolor (unset) def
    /inkspread 0.15 def
    /width 0 def
    /barratio 1 def
    /spaceratio 1 def
    /showborder false def
    /borderleft 10 def
    /borderright 10 def
    /bordertop 1 def
    /borderbottom 1 def
    /borderwidth 0.5 def
    /guardwhitespace false def
    /guardleftpos 0 def
    /guardleftypos 0 def
    /guardrightpos 0 def
    /guardrightypos 0 def
    /guardwidth 6 def
    /guardheight 7 def
%    
    % Apply the renderer options and the user options
    args {def} forall
    opt {def} forall 
%
    /barcolor barcolor cvlit def
    /textcolor textcolor cvlit def
    /textxalign textxalign cvlit def
    /textyalign textyalign cvlit def
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /textgaps textgaps cvr def
    /alttext alttext cvlit def
    /bordercolor bordercolor cvlit def
    /backgroundcolor backgroundcolor cvlit def
    /inkspread inkspread cvr def
    /width width cvr def
    /barratio barratio cvr def
    /spaceratio spaceratio cvr def
    /borderleft borderleft cvr def
    /borderright borderright cvr def
    /bordertop bordertop cvr def
    /borderbottom borderbottom cvr def
    /borderwidth borderwidth cvr def
    /guardleftpos guardleftpos cvr def
    /guardleftypos guardleftypos cvr def
    /guardrightpos guardrightpos cvr def
    /guardrightypos guardrightypos cvr def
    /guardwidth guardwidth cvr def
    /guardheight guardheight cvr def
%    
    % Create bar elements and put them into the bars array
    /bars sbs length 1 add 2 idiv array def
    /x 0.00 def /maxh 0 def
    0 1 sbs length 1 add 2 idiv 2 mul 2 sub {
        /i exch def
        i 2 mod 0 eq {           % i is even
            /d sbs i get barratio mul barratio sub 1 add def  % d=digit*r-r+1
            sbs i get 0 ne {
                /h bhs i 2 idiv get 72 mul def  % Height from bhs
                /c d 2 div x add def            % Centre of the bar = x + d/2
                /y bbs i 2 idiv get 72 mul def  % Baseline from bbs
                /w d inkspread sub def          % bar width = digit - inkspread
                bars i 2 idiv [h c y w] put     % Add the bar entry
                h y add maxh gt {/maxh h y add def} if
            } {
                bars i 2 idiv -1 put            % Dummy entry
            } ifelse
        } {
            /d sbs i get spaceratio mul spaceratio sub 1 add def  % d=digit*r-r+1 
        } ifelse
        /x x d add def  % x+=d
    } for

    gsave

    currentpoint translate

    % Force symbol to given width
    width 0 ne {
        width 72 mul x div 1 scale
    } if

    % Set RGB or CMYK color depending on length of given hex string
    /setanycolor {
        /anycolor exch def
        anycolor length 6 eq {
            (<      >) 8 string copy dup 1 anycolor putinterval cvx exec {255 div} forall setrgbcolor
        } if
        anycolor length 8 eq {
            (<        >) 10 string copy dup 1 anycolor putinterval cvx exec {255 div} forall setcmykcolor
        } if
    } bind def

    % Display the border and background
    newpath
    borderleft neg borderbottom neg moveto
    x borderleft add borderright add 0 rlineto
    0 maxh borderbottom add bordertop add rlineto
    x borderleft add borderright add neg 0 rlineto
    0 maxh borderbottom add bordertop add neg rlineto    
    closepath
    backgroundcolor (unset) ne { gsave backgroundcolor setanycolor fill grestore } if     
    showborder {
        gsave
        bordercolor (unset) ne { bordercolor setanycolor } if
        borderwidth setlinewidth stroke
        grestore
    } if    
   
    % Display the bars for elements in the bars array
    gsave
    0 setlinecap
    barcolor (unset) ne { barcolor setanycolor } if
    bars {
        dup -1 ne {
            aload pop newpath setlinewidth moveto 0 exch rlineto stroke
        } {
            pop
        } ifelse
    } forall
    grestore
    
    % Display the text for elements in the text array
    textcolor (unset) ne { textcolor setanycolor } if
    includetext {
        textxalign (unset) eq textyalign (unset) eq and alttext () eq and {
            /s 0 def /fn () def
            txt {
                {} forall
                2 copy s ne exch fn ne or {
                    2 copy /s exch def /fn exch def            
                    exch findfont exch scalefont setfont          
                } {
                    pop pop
                } ifelse
                moveto show
            } forall
        } {
            textfont findfont textsize scalefont setfont
            alttext () eq {
                /txt [ txt { 0 get {} forall } forall ] def
                /tstr txt length string def
                0 1 txt length 1 sub { dup txt exch get tstr 3 1 roll put } for
            } {
                /tstr alttext def
            } ifelse

            % Find true ascent of font
            tstr length 0 eq {
                0
            } {
                gsave
                newpath 0 0 moveto (0) false charpath pathbbox
                4 1 roll pop pop pop
                grestore
                currentfont /PaintType known {currentfont /PaintType get 2 eq} {false} ifelse
                currentfont /StrokeWidth known and {
                    currentfont /StrokeWidth get 2 div 0 exch
                    currentfont /FontMatrix get dtransform
                    dup mul exch dup mul add sqrt
                    add
                } if
            } ifelse
            /textascent exch def
            /textwidth tstr stringwidth pop tstr length 1 sub textgaps mul add def

            /textxpos textxoffset x textwidth sub 2 div add def
            textxalign (left) eq { /textxpos textxoffset def } if
            textxalign (right) eq { /textxpos x textxoffset sub textwidth sub def } if
            textxalign (offleft) eq { /textxpos textwidth textxoffset add neg def } if
            textxalign (offright) eq { /textxpos x textxoffset add def } if
            textxalign (justify) eq textwidth x lt and {
                /textxpos 0 def
                /textgaps x textwidth sub tstr length 1 sub div def
            } if
            /textypos textyoffset textascent add 1 add neg def
            textyalign (above) eq { /textypos textyoffset maxh add 1 add def } if
            textyalign (center) eq { /textypos textyoffset maxh textascent sub 2 div add def } if
            textxpos textypos moveto textgaps 0 tstr ashow
        } ifelse
    } if    

    % Display the guard elements
    guardwhitespace {
        0.75 setlinewidth
        guardleftpos 0 ne {
            newpath
            guardleftpos neg guardwidth add guardleftypos guardwidth 2 div add moveto
            guardwidth neg guardheight -2 div rlineto
            guardwidth guardheight -2 div rlineto
            stroke            
        } if
        guardrightpos 0 ne {
            newpath
            guardrightpos x add guardwidth sub guardrightypos guardheight 2 div add moveto
            guardwidth guardheight -2 div rlineto
            guardwidth neg guardheight -2 div rlineto
            stroke            
        } if
    } if
    
    grestore
    
    end

} bind def
/renlinear dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END RENDERER renlinear--

% --BEGIN RENDERER renmatrix--
% --REQUIRES preamble raiseerror--
%%BeginResource: uk.co.terryburton.bwipp renmatrix 0.0 2015050900 54074 54076
%%BeginData:         66 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
begin
/renmatrix {

    20 dict begin

    /args exch def

    % Default options
    /width 1 def
    /height 1 def
    /barcolor (unset) def
    /backgroundcolor (unset) def

    % Apply the renderer options and the user options
    args {def} forall
    opt {def} forall

    /width width cvr def
    /height height cvr def
    /barcolor barcolor cvlit def
    /backgroundcolor backgroundcolor cvlit def

    % Set RGB or CMYK color depending on length of given hex string
    /setanycolor {
        /anycolor exch def
        anycolor length 6 eq {
            (<      >) 8 string copy dup 1 anycolor putinterval cvx exec {255 div} forall setrgbcolor
        } if
        anycolor length 8 eq {
            (<        >) 10 string copy dup 1 anycolor putinterval cvx exec {255 div} forall setcmykcolor
        } if
    } bind def

    % Draw the image
    gsave
    currentpoint translate
    width pixx div 72 mul height pixy div 72 mul scale
    0 0 moveto pixx 0 lineto pixx pixy lineto 0 pixy lineto closepath
    backgroundcolor (unset) ne { gsave backgroundcolor setanycolor fill grestore } if 
    barcolor (unset) ne { barcolor setanycolor } if
    /xyget {pixx mul add get} bind def
    newpath
    0 1 pixs length 1 sub {
        dup pixx mod /x exch def
        pixx idiv /y exch def
        pixs x y xyget 1 eq {
           x pixy y sub 1 sub moveto
           0 1 rlineto
           1 0 rlineto
           0 -1 rlineto
           -1 0 rlineto
           closepath
        } if
    } for
    fill
    grestore

    end

} bind def
/renmatrix dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END RENDERER renmatrix--

% --BEGIN RENDERER renmaximatrix--
% --REQUIRES preamble raiseerror--
%%BeginResource: uk.co.terryburton.bwipp renmaximatrix 0.0 2015050900 55426 55272
%%BeginData:         79 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
begin
/renmaximatrix {

    20 dict begin

    /args exch def   % We are given some arguments

    % Default options
    /barcolor (unset) def
    /backgroundcolor (unset) def

    % Apply the renderer options and the user options
    args {def} forall
    opt {def} forall

    /barcolor barcolor cvlit def
    /backgroundcolor backgroundcolor cvlit def

    % Set RGB or CMYK color depending on length of given hex string
    /setanycolor {
        /anycolor exch def
        anycolor length 6 eq {
            (<      >) 8 string copy dup 1 anycolor putinterval cvx exec {255 div} forall setrgbcolor
        } if
        anycolor length 8 eq {
            (<        >) 10 string copy dup 1 anycolor putinterval cvx exec {255 div} forall setcmykcolor
        } if
    } bind def

    gsave

    currentpoint translate

    2.4945 dup scale  % from 1pt to 1.88mm

    0 0 moveto 30 0 lineto 30 29 lineto 0 29 lineto closepath
    backgroundcolor (unset) ne { gsave backgroundcolor setanycolor fill grestore } if 
    barcolor (unset) ne { barcolor setanycolor } if

    0.5 0.5774 translate

    newpath
    pixs {
        dup 
        /x exch 30 mod def 
        /y exch 30 idiv def
        y 2 mod 0 eq {x} {x 0.5 add} ifelse
        32 y sub 0.8661 mul
        moveto
        0     0.5774 rmoveto
        -0.5 -0.2887 rlineto
        0    -0.5774 rlineto
        0.5  -0.2887 rlineto
        0.5   0.2887 rlineto
        0     0.5774 rlineto
        -0.5  0.2887 rlineto
        closepath
    } forall
    fill

    % Plot the locator symbol
    newpath 14 13.8576 0.5774 0 360 arc closepath
    14 13.8576 1.3359 360 0 arcn closepath fill
    newpath 14 13.8576 2.1058 0 360 arc closepath
    14 13.8576 2.8644 360 0 arcn closepath fill
    newpath 14 13.8576 3.6229 0 360 arc closepath
    14 13.8576 4.3814 360 0 arcn closepath fill

    grestore

    end

} bind def
/renmaximatrix dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END RENDERER renmaximatrix--

% --BEGIN ENCODER ean5--
% --REQUIRES preamble raiseerror renlinear--
% --DESC: EAN-5 (5 digit addon)
% --EXAM: 90200
% --EXOP: includetext guardwhitespace
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp ean5 0.0 2015050900 62897 62576
%%BeginData:        135 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/ean5 {

    20 dict begin

    /options exch def                   % We are given an option string
    /barcode exch def                   % We are given a barcode string

    /dontdraw false def
    /includetext false def              % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textxoffset 0 def
    /textyoffset (unset) def
    /height 0.7 def    
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall   
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /height height cvr def
    /textxoffset textxoffset cvr def
    textyoffset (unset) eq {
        /textyoffset height 72 mul 1 add def
    } {
        /textyoffset textyoffset cvr def
    } ifelse

    % Validate input
    barcode length 5 ne {
        /bwipp.ean5badLength (EAN-5 add-on must be 5 digits) //raiseerror exec
    } if
    barcode {
        dup 48 lt exch 57 gt or {
            /bwipp.ean5badCharacter (EAN-5 add-on must contain only digits) //raiseerror exec
        } if
    } forall
 
    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (112) (11)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    % Determine the mirror map based on mod 10 checksum
    /mirrormaps
    [ (11000) (10100) (10010) (10001) (01100)
      (00110) (00011) (01010) (01001) (00101)
    ] def
    /checksum 0 def
    0 1 4 {
        /i exch def
        /barchar barcode i get 48 sub def
        i 2 mod 0 eq {
            /checksum barchar 3 mul checksum add def
        } {
            /checksum barchar 9 mul checksum add def
        } ifelse
    } for
    /checksum checksum 10 mod def
    /mirrormap mirrormaps checksum get def

    /sbs 31 string def
    /txt 5 array def
   
    0 1 4 {
        /i exch def

        % Prefix with either a start character or separator character
        i 0 eq {
            sbs 0 encs 10 get putinterval
        } {
            sbs i 1 sub 6 mul 7 add encs 11 get putinterval
        } ifelse

        % Lookup the encoding for the barcode character
        barcode i 1 getinterval barchars exch search
        pop                     % Discard true leaving pre
        length /indx exch def   % indx is the length of pre
        pop pop                 % Discard seek and post
        /enc encs indx get def  % Get the indxth encoding
        mirrormap i get 49 eq { % Reverse enc if 1 in this position in mirrormap
            /enclen enc length def
            /revenc enclen string def
            0 1 enclen 1 sub {
                /j exch def
                /char enc j get def
                revenc enclen j sub 1 sub char put
            } for
            /enc revenc def
        } if
        sbs i 6 mul 3 add enc putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 1 sub 9 mul 13 add textxoffset add textyoffset textfont textsize] put
    } for

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [16{height}repeat]
    /bbs [16{0}repeat]
    includetext {
        /txt txt
    } if
    /opt options
    /guardrightpos 10
    /guardrightypos textyoffset 4 add
    /bordertop 10
    >>

    dontdraw not //renlinear if

    end

} bind def
/ean5 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER ean5--

% --BEGIN ENCODER ean2--
% --REQUIRES preamble raiseerror renlinear--
% --DESC: EAN-2 (2 digit addon)
% --EXAM: 05
% --EXOP: includetext guardwhitespace
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp ean2 0.0 2015050900 61678 61382
%%BeginData:        120 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/ean2 {

    20 dict begin

    /options exch def                   % We are given an options string
    /barcode exch def                   % We are given a barcode string

    /dontdraw false def
    /includetext false def               % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textxoffset 0 def
    /textyoffset (unset) def
    /height 0.7 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /height height cvr def
    /textxoffset textxoffset cvr def
    textyoffset (unset) eq {
        /textyoffset height 72 mul 1 add def
    } {
        /textyoffset textyoffset cvr def
    } ifelse

    % Validate input
    barcode length 2 ne {
      /bwipp.ean2badLength (EAN-2 add-on must be 2 digits) //raiseerror exec
    } if
    barcode {
        dup 48 lt exch 57 gt or {
            /bwipp.ean2badCharacter (EAN-2 add-on must contain only digits) //raiseerror exec
        } if
    } forall
    
    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (112) (11)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    % Determine the mirror map based on mod 4 checksum
    /mirrormap [(00) (01) (10) (11)] barcode 0 2 getinterval cvi 4 mod get def

    /sbs 13 string def
    /txt 2 array def
    
    0 1 1 {
        /i exch def

        % Prefix with either a start character or separator character
        i 0 eq {
            sbs 0 encs 10 get putinterval
        } {
            sbs i 1 sub 6 mul 7 add encs 11 get putinterval
        } ifelse

        % Lookup the encoding for the barcode character
        barcode i 1 getinterval barchars exch search
        pop                     % Discard true leaving pre
        length /indx exch def   % indx is the length of pre
        pop pop                 % Discard seek and post
        /enc encs indx get def  % Get the indxth encoding
        mirrormap i get 49 eq { % Reverse enc if 1 in this position in mirrormap    
            /enclen enc length def
            /revenc enclen string def
            0 1 enclen 1 sub {
                /j exch def
                /char enc j get def
                revenc enclen j sub 1 sub char put
            } for
            /enc revenc def
        } if
        sbs i 6 mul 3 add enc putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 1 sub 9 mul 13 add textxoffset add textyoffset textfont textsize] put
    } for

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [12{height}repeat]
    /bbs [12{0}repeat]
    includetext {
        /txt txt
    } if
    /opt options
    /guardrightpos 10
    /guardrightypos textyoffset 4 add
    /bordertop 10
    >>

    dontdraw not //renlinear if

    end

} bind def
/ean2 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER ean2--

% --BEGIN ENCODER ean13--
% --REQUIRES preamble raiseerror renlinear ean5 ean2--
% --DESC: EAN-13
% --EXAM: 2112345678900
% --EXOP: includetext guardwhitespace
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp ean13 0.0 2015050900 84460 87603
%%BeginData:        215 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /ean2 dup /uk.co.terryburton.bwipp findresource put
dup /ean5 dup /uk.co.terryburton.bwipp findresource put
begin
/ean13 {

    20 dict begin

    /options exch def                  % We are given an option string
    /barcode exch def                  % We are given a barcode string

    /dontdraw false def
    /includetext false def             % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textxoffset -10 def
    /textyoffset -4 def
    /height 1 def
    /addongap 12 def
    /addontextfont (unset) def
    /addontextsize (unset) def
    /addontextxoffset (unset) def
    /addontextyoffset (unset) def

    % Parse the input options, either a string or a dict
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    /addongap addongap cvr def   
    addontextfont (unset) ne {/addontextfont addontextfont cvlit def} if
    addontextsize (unset) ne {/addontextsize addontextsize cvr def} if
    addontextxoffset (unset) ne {/addontextxoffset addontextxoffset cvr def} if
    addontextyoffset (unset) ne {/addontextyoffset addontextyoffset cvr def} if

    % Split off the addon
    barcode ( ) search {
        /barcode exch def
        pop
        /addon exch def
    } {
        pop
        /addon () def
    } ifelse

    % Validate the input
    barcode length 12 ne barcode length 13 ne and {
        /bwipp.ean13badLength (EAN-13 must be 12 or 13 digits) //raiseerror exec
    } if
    barcode {
        dup 48 lt exch 57 gt or {
            /bwipp.ean13badCharacter (EAN-13 must contain only digits) //raiseerror exec
        } if
    } forall
    addon length 0 ne addon length 2 ne and addon length 5 ne and {
        /bwipp.ean13badAddOnLength (Add-on for EAN-13 must be 2 or 5 digits) //raiseerror exec
    } if

    % Add checksum digit
    /pad 13 string def
    /checksum 0 def
    0 1 11 {
        /i exch def
        /barchar barcode i get 48 sub def
        i 2 mod 0 eq {
            /checksum barchar checksum add def
        } {
            /checksum barchar 3 mul checksum add def
        } ifelse
    } for
    /checksum 10 checksum 10 mod sub 10 mod def
    barcode length 13 eq {
        barcode 12 get checksum 48 add ne {
            /bwipp.ean13badCheckDigit (Incorrect EAN-13 check digit provided) //raiseerror exec
        } if
    } if
    pad 0 barcode putinterval       % Add barcode to the start of the pad
    pad 12 checksum 48 add put      % Put ascii for checksum at end of pad
    /barcode pad def

    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (111) (11111) (111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    % Digits to mirror on left side
    /mirrormaps
    [ (000000) (001011) (001101) (001110) (010011)
      (011001) (011100) (010101) (010110) (011010)
    ] def

    /sbs 59 string def
    /txt 13 array def
  
    % Put the start character
    sbs 0 encs 10 get putinterval

    % First digit - determine mirrormap by this and show before guard bars
    /mirrormap mirrormaps barcode 0 get 48 sub get def
    txt 0 [barcode 0 1 getinterval textxoffset textyoffset textfont textsize] put

    % Left side - performs mirroring
    1 1 6 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                            % Discard true leaving pre
        length /indx exch def          % indx is the length of pre
        pop pop                        % Discard seek and post
        /enc encs indx get def         % Get the indxth encoding
        mirrormap i 1 sub get 49 eq {   % Reverse enc if 1 in this position in mirrormap
            /enclen enc length def
            /revenc enclen string def
            0 1 enclen 1 sub {
                /j exch def
                /char enc j get def
                revenc enclen j sub 1 sub char put
            } for
            /enc revenc def
        } if
        sbs i 1 sub 4 mul 3 add enc putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 1 sub 7 mul 14 add textxoffset add textyoffset textfont textsize] put
    } for

    % Put the middle character
    sbs 7 1 sub 4 mul 3 add encs 11 get putinterval

    % Right side
    7 1 12 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                            % Discard true leaving pre
        length /indx exch def          % indx is the length of pre
        pop pop                        % Discard seek and post
        /enc encs indx get def         % Get the indxth encoding
        sbs i 1 sub 4 mul 8 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 1 sub 7 mul 18 add textxoffset add textyoffset textfont textsize] put
    } for

    % Put the end character
    sbs 56 encs 12 get putinterval

    /sbs [sbs {48 sub} forall] def
    includetext {
        /bhs [height height 12{height .075 sub}repeat height height 12{height .075 sub}repeat height height] def
        /bbs [0 0 12{.075}repeat 0 0 12{.075}repeat 0 0] def
    } {
        /bhs [30{height}repeat] def
        /bbs [30{0}repeat] def
        /txt [] def
    } ifelse
    /guardrightypos 0 def

    % Append the addon
    addon () ne {
        /addopts <<
            /dontdraw true
            /includetext true
            /height height 0.15 sub
            /textxoffset addontextxoffset (unset) ne {addontextxoffset} {95 addongap add} ifelse
            addontextyoffset (unset) ne {/textyoffset addontextyoffset} if
            /textsize addontextsize (unset) ne {addontextsize} {textsize} ifelse
            /textfont addontextfont (unset) ne {addontextfont} {textfont} ifelse
        >> def
        addon length 2 eq {addon addopts //ean2 exec} if
        addon length 5 eq {addon addopts //ean5 exec} if
        /addcode exch def
        /sbs [sbs aload pop addongap addcode (sbs) get aload pop] def
        /bhs [bhs aload pop addcode (bhs) get {.075 sub} forall] def
        /bbs [bbs aload pop addcode (bbs) get {.075 add} forall] def
        /txt [txt aload pop addcode (txt) get aload pop] def
        /guardrightypos height 72 mul 6 sub def
    } if 
   
    % Return the arguments
    <<
    /ren //renlinear
    /sbs sbs
    /bhs bhs
    /bbs bbs
    /txt txt
    /opt options
    /guardrightpos 10
    /guardrightypos guardrightypos
    /borderbottom 5
    >>

    dontdraw not //renlinear if

    end

} bind def
/ean13 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER ean13--

% --BEGIN ENCODER ean8--
% --REQUIRES preamble raiseerror renlinear ean5 ean2--
% --DESC: EAN-8
% --EXAM: 02345673
% --EXOP: includetext guardwhitespace
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp ean8 0.0 2015050900 81954 85278
%%BeginData:        196 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /ean2 dup /uk.co.terryburton.bwipp findresource put
dup /ean5 dup /uk.co.terryburton.bwipp findresource put
begin
/ean8 {

    20 dict begin

    /options exch def                  % We are given an option string
    /barcode exch def                  % We are given a barcode string

    /dontdraw false def
    /includetext false def              % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textxoffset 4 def
    /textyoffset -4 def
    /height 1 def
    /addongap 12 def
    /addontextfont (unset) def
    /addontextsize (unset) def
    /addontextxoffset (unset) def
    /addontextyoffset (unset) def
    
    % Parse the input options, either a string or a dict
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
   
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    /addongap addongap cvr def
    addontextfont (unset) ne {/addontextfont addontextfont cvlit def} if
    addontextsize (unset) ne {/addontextsize addontextsize cvr def} if
    addontextxoffset (unset) ne {/addontextxoffset addontextxoffset cvr def} if
    addontextyoffset (unset) ne {/addontextyoffset addontextyoffset cvr def} if

    % Split off the addon
    barcode ( ) search {
        /barcode exch def
        pop
        /addon exch def
    } {
        pop
        /addon () def
    } ifelse

    % Validate the input
    barcode length 7 ne barcode length 8 ne and {
        /bwipp.ean8badLength (EAN-8 must be 7 or 8 digits) //raiseerror exec
    } if
    barcode {
        dup 48 lt exch 57 gt or {
            /bwipp.ean8badCharacter (EAN-8 must contain only digits) //raiseerror exec
        } if
    } forall
    addon length 0 ne addon length 2 ne and addon length 5 ne and {
        /bwipp.ean8badAddOnLength (Add-on for EAN-8 must be 2 or 5 digits) //raiseerror exec
    } if

    % Add checksum digit
    /pad 8 string def
    /checksum 0 def
    0 1 6 {
        /i exch def
        /barchar barcode i get 48 sub def
        i 2 mod 0 ne {
            /checksum barchar checksum add def
        } {
            /checksum barchar 3 mul checksum add def
        } ifelse
    } for
    /checksum 10 checksum 10 mod sub 10 mod def
    barcode length 8 eq {
        barcode 7 get checksum 48 add ne {
            /bwipp.ean8badCheckDigit (Incorrect EAN-8 check digit provided) //raiseerror exec
        } if
    } if
    pad 0 barcode putinterval      % Add barcode to the start of the pad
    pad 7 checksum 48 add put      % Put ascii for checksum at end of pad
    /barcode pad def
 
    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (111) (11111) (111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    /sbs 43 string def
    /txt 8 array def
    
    % Put the start character
    sbs 0 encs 10 get putinterval

    % Left side
    0 1 3 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 4 mul 3 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 7 mul textxoffset add textyoffset textfont textsize] put
    } for

    % Put the middle character
    sbs 4 4 mul 3 add encs 11 get putinterval

    % Right side
    4 1 7 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 4 mul 8 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 7 mul textxoffset add 4 add textyoffset textfont textsize] put
    } for

    % Put the end character
    sbs 40 encs 12 get putinterval

    /sbs [sbs {48 sub} forall] def
    includetext {
        /bhs [height height 8{height .075 sub}repeat height height 8{height .075 sub}repeat height height] def
        /bbs [0 0 8{.075}repeat 0 0 8{.075}repeat 0 0] def
    } {
        /bhs [22{height}repeat] def
        /bbs [22{0}repeat] def
        /txt [] def
    } ifelse
    /guardrightypos 0 def

    % Append the addon
    addon () ne {
        /addopts <<
            /dontdraw true
            /includetext true
            /height height 0.15 sub
            /textxoffset addontextxoffset (unset) ne {addontextxoffset} {67 addongap add} ifelse
            addontextyoffset (unset) ne {/textyoffset addontextyoffset} if
            /textsize addontextsize (unset) ne {addontextsize} {textsize} ifelse
            /textfont addontextfont (unset) ne {addontextfont} {textfont} ifelse
        >> def
        addon length 2 eq {addon addopts //ean2 exec} if
        addon length 5 eq {addon addopts //ean5 exec} if
        /addcode exch def
        /sbs [sbs aload pop addongap addcode (sbs) get aload pop] def
        /bhs [bhs aload pop addcode (bhs) get {.075 sub} forall] def
        /bbs [bbs aload pop addcode (bbs) get {.075 add} forall] def
        /txt [txt aload pop addcode (txt) get aload pop] def
        /guardrightypos height 72 mul 6 sub def
    } if 

    % Return the arguments
    <<
    /ren //renlinear
    /sbs sbs
    /bhs bhs
    /bbs bbs
    /txt txt
    /opt options
    /guardleftpos 10
    /guardrightpos 10
    /guardrightypos guardrightypos
    /borderbottom 5
    >>

    dontdraw not //renlinear if

    end

} bind def
/ean8 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER ean8--

% --BEGIN ENCODER upca--
% --REQUIRES preamble raiseerror renlinear ean5 ean2--
% --DESC: UPC-A
% --EXAM: 416000336108
% --EXOP: includetext
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp upca 0.0 2015050900 89013 91922
%%BeginData:        248 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /ean2 dup /uk.co.terryburton.bwipp findresource put
dup /ean5 dup /uk.co.terryburton.bwipp findresource put
begin
/upca {

    20 dict begin

    /options exch def
    /barcode exch def             % We are given a barcode string

    /dontdraw false def
    /includetext false def         % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textxoffset -7 def
    /textyoffset -4 def
    /height 1 def 
    /addongap 12 def
    /addontextfont (unset) def
    /addontextsize (unset) def
    /addontextxoffset (unset) def
    /addontextyoffset (unset) def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall    

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    /addongap addongap cvr def
    addontextfont (unset) ne {/addontextfont addontextfont cvlit def} if
    addontextsize (unset) ne {/addontextsize addontextsize cvr def} if
    addontextxoffset (unset) ne {/addontextxoffset addontextxoffset cvr def} if
    addontextyoffset (unset) ne {/addontextyoffset addontextyoffset cvr def} if

    % Split off the addon
    barcode ( ) search {
        /barcode exch def
        pop
        /addon exch def
    } {
        pop
        /addon () def
    } ifelse

    % Expand a given UPC-E
    barcode length 7 eq barcode length 8 eq or {
        % Validate the input
        barcode {
            dup 48 lt exch 57 gt or {
                /bwipp.upcAupcEbadCharacter (UPC-E must contain only digits) //raiseerror exec
            } if
        } forall
        barcode 0 get dup 48 ne exch 49 ne and {
            /bwipp.upcAupcEbadNumberSystem (UPC-E must have number system 0 or 1) //raiseerror exec
        } if
        1 {  % Common exit
            /upcacode barcode length 8 eq {12} {11} ifelse string def
            barcode 6 get 48 sub 2 le {
                upcacode 0 barcode 0 3 getinterval putinterval
                upcacode 3 barcode 6 1 getinterval putinterval
                upcacode 4 (0000) putinterval
                upcacode 8 barcode 3 3 getinterval putinterval
                exit
            } if
            barcode 6 get 48 sub 3 eq {
                upcacode 0 barcode 0 4 getinterval putinterval
                upcacode 4 (00000) putinterval
                upcacode 9 barcode 4 2 getinterval putinterval
                exit
            } if
            barcode 6 get 48 sub 4 eq {
                upcacode 0 barcode 0 5 getinterval putinterval
                upcacode 5 (00000) putinterval
                upcacode 10 barcode 5 1 getinterval putinterval
                exit
            } if
            barcode 6 get 48 sub 5 ge {
                upcacode 0 barcode 0 6 getinterval putinterval
                upcacode 6 (0000) putinterval
                upcacode 10 barcode 6 1 getinterval putinterval
                exit
            } if
        } repeat
        barcode length 8 eq {
            upcacode 11 barcode 7 1 getinterval putinterval
        } if
        /barcode upcacode def
    } if

    % Validate the input
    barcode length 11 ne barcode length 12 ne and {
        /bwipp.upcAbadLength (UPC-A must be 11 or 12 digits) //raiseerror exec
    } if
    barcode {
        dup 48 lt exch 57 gt or {
            /bwipp.upcAbadCharacter (UPC-A must contain only digits) //raiseerror exec
        } if
    } forall
    addon length 0 ne addon length 2 ne and addon length 5 ne and {
        /bwipp.upcAbadAddOnLength (Add-on for UPC-A must be 2 or 5 digits) //raiseerror exec
    } if
 
    % Add checksum digit to barcode
    /pad 12 string def   % Create pad one bigger than barcode
    /checksum 0 def
    0 1 10 {
        /i exch def
        /barchar barcode i get 48 sub def
        i 2 mod 0 ne {
            /checksum checksum barchar add def
        } {
            /checksum checksum barchar 3 mul add def
        } ifelse
    } for
    /checksum 10 checksum 10 mod sub 10 mod def
    barcode length 12 eq {
        barcode 11 get checksum 48 add ne {
            /bwipp.upcAbadCheckDigit (Incorrect UPC check digit provided) //raiseerror exec
        } if
    } if
    pad 0 barcode putinterval       % Add barcode to the start of the pad
    pad 11 checksum 48 add put      % Put ascii for checksum at end of pad
    /barcode pad def

    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (111) (11111) (111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    /sbs 59 string def
    /txt 12 array def

    % Put the start character
    sbs 0 encs 10 get putinterval

    % Left side
    0 1 5 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 4 mul 3 add enc putinterval  % Put encoded digit into sbs
        i 0 eq {      % First digit is before the guard bars
            txt 0 [barcode 0 1 getinterval textxoffset textyoffset textfont textsize 2 sub] put
        } {
            txt i [barcode i 1 getinterval i 7 mul 11 add textxoffset add textyoffset textfont textsize] put
        } ifelse
    } for

    % Put the middle character
    sbs 6 4 mul 3 add encs 11 get putinterval

    % Right side
    6 1 11 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 4 mul 8 add enc putinterval  % Put encoded digit into sbs
        i 11 eq {       % Last digit is after guard bars
            txt 11 [barcode 11 1 getinterval textxoffset 103 add textyoffset textfont textsize 2 sub] put
        } {
            txt i [barcode i 1 getinterval i 7 mul textxoffset add 15 add textyoffset textfont textsize] put
        } ifelse
    } for

    % Put the end character
    sbs 56 encs 12 get putinterval

    /sbs [sbs {48 sub} forall] def
    includetext {
        /bhs [4{height}repeat 10{height .075 sub}repeat height height 10{height .075 sub}repeat 4{height}repeat] def
        /bbs [0 0 0 0 10{.075}repeat 0 0 10{.075}repeat 0 0 0 0] def
    } {
        /bhs [30{height}repeat] def
        /bbs [30{0}repeat] def
        /txt [] def
    } ifelse
    /guardrightypos 0 def

    % Append the addon
    addon () ne {
        /addopts <<
            /dontdraw true
            /includetext true
            /height height 0.15 sub
            /textxoffset addontextxoffset (unset) ne {addontextxoffset} {95 addongap add} ifelse
            addontextyoffset (unset) ne {/textyoffset addontextyoffset} if
            /textsize addontextsize (unset) ne {addontextsize} {textsize} ifelse
            /textfont addontextfont (unset) ne {addontextfont} {textfont} ifelse
        >> def
        addon length 2 eq {addon addopts //ean2 exec} if
        addon length 5 eq {addon addopts //ean5 exec} if
        /addcode exch def
        /sbs [sbs aload pop addongap addcode (sbs) get aload pop] def
        /bhs [bhs aload pop addcode (bhs) get {.075 sub} forall] def
        /bbs [bbs aload pop addcode (bbs) get {.075 add} forall] def
        /txt [txt aload pop addcode (txt) get aload pop] def
        /guardrightypos height 72 mul 6 sub def
    } if 

    % Return the arguments
    <<
    /ren //renlinear
    /sbs sbs
    /bhs bhs
    /bbs bbs
    /txt txt
    /opt options
    /guardrightpos 10
    /guardrightypos guardrightypos
    /borderbottom 5
    >>

    dontdraw not //renlinear if

    end

} bind def
/upca dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER upca--

% --BEGIN ENCODER upce--
% --REQUIRES preamble raiseerror renlinear ean5 ean2--
% --DESC: UPC-E
% --EXAM: 00123457
% --EXOP: includetext
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp upce 0.0 2015050900 92938 99490
%%BeginData:        287 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /ean2 dup /uk.co.terryburton.bwipp findresource put
dup /ean5 dup /uk.co.terryburton.bwipp findresource put
begin
/upce {

    20 dict begin

    /options exch def                   % We are given an option string
    /barcode exch def                   % We are given a barcode string

    /dontdraw false def
    /includetext false def               % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textxoffset -7 def
    /textyoffset -4 def
    /height 1 def
    /addongap 12 def
    /addontextfont (unset) def
    /addontextsize (unset) def
    /addontextxoffset (unset) def
    /addontextyoffset (unset) def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    /addongap addongap cvr def
    addontextfont (unset) ne {/addontextfont addontextfont cvlit def} if
    addontextsize (unset) ne {/addontextsize addontextsize cvr def} if
    addontextxoffset (unset) ne {/addontextxoffset addontextxoffset cvr def} if
    addontextyoffset (unset) ne {/addontextyoffset addontextyoffset cvr def} if

    % Split off the addon
    barcode ( ) search {
        /barcode exch def
        pop
        /addon exch def
    } {
        pop
        /addon () def
    } ifelse

    % Compress a given UPC-A
    barcode length 11 eq barcode length 12 eq or {
        % Validate the input
        barcode {
            dup 48 lt exch 57 gt or {
                /bwipp.upcEupcAbadCharacter (UPC-A must contain only digits) //raiseerror exec
            } if
        } forall
        1 {  % Common exit
            /upcecode barcode length 12 eq {8} {7} ifelse string def
            barcode 3 get 48 sub 2 le barcode 4 4 getinterval (0000) eq and {
                upcecode 0 barcode  0 3 getinterval putinterval
                upcecode 3 barcode  8 3 getinterval putinterval
                upcecode 6 barcode  3 1 getinterval putinterval
                exit
            } if
            barcode 4 5 getinterval (00000) eq {
                upcecode 0 barcode  0 4 getinterval putinterval
                upcecode 4 barcode  9 2 getinterval putinterval
                upcecode 6 (3) putinterval
                exit
            } if
            barcode 5 5 getinterval (00000) eq {
                upcecode 0 barcode  0 5 getinterval putinterval
                upcecode 5 barcode 10 1 getinterval putinterval
                upcecode 6 (4) putinterval
                exit
            } if
            barcode 10 get 48 sub 5 ge barcode 6 4 getinterval (0000) eq and {
                upcecode 0 barcode  0 6 getinterval putinterval
                upcecode 6 barcode 10 1 getinterval putinterval
                exit
            } if
            /bwipp.upcEupcAnotCompressible (UPC-A cannot be converted to a UPC-E) //raiseerror exec
        } repeat
        barcode length 12 eq {
            upcecode 7 barcode 11 1 getinterval putinterval
        } if
        /barcode upcecode def
    } if

    % Validate the input
    barcode length 7 ne barcode length 8 ne and {
        /bwipp.upcEbadLength (UPC-E must be 7 or 8 digits) //raiseerror exec
    } if
    barcode {
        dup 48 lt exch 57 gt or {
            /bwipp.upcEbadCharacter (UPC-E must contain only digits) //raiseerror exec
        } if
    } forall
    addon length 0 ne addon length 2 ne and addon length 5 ne and {
        /bwipp.upcEbadAddOnLength (Add-on for UPC-E must be 2 or 5 digits) //raiseerror exec
    } if

    % Ensure 0 or 1 number systems
    barcode 0 get dup 48 ne exch 49 ne and {
        /bwipp.upcEbadNumberSystem (UPC-E must have number system 0 or 1) //raiseerror exec
    } if

    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (111) (111111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    /mirrormaps
    [ (000111) (001011) (001101) (001110) (010011)
      (011001) (011100) (010101) (010110) (011010)
    ] def

    % Derive the equivalent UPC-A for its checksum
    1 {  % Common exit
        /upcacode 11 string def
        barcode 6 get 48 sub 2 le {
            upcacode 0 barcode 0 3 getinterval putinterval
            upcacode 3 barcode 6 1 getinterval putinterval
            upcacode 4 (0000) putinterval
            upcacode 8 barcode 3 3 getinterval putinterval
            exit
        } if
        barcode 6 get 48 sub 3 eq {
            upcacode 0 barcode 0 4 getinterval putinterval
            upcacode 4 (00000) putinterval
            upcacode 9 barcode 4 2 getinterval putinterval
            exit
        } if
        barcode 6 get 48 sub 4 eq {
            upcacode 0 barcode 0 5 getinterval putinterval
            upcacode 5 (00000) putinterval
            upcacode 10 barcode 5 1 getinterval putinterval
            exit
        } if
        barcode 6 get 48 sub 5 ge {
            upcacode 0 barcode 0 6 getinterval putinterval
            upcacode 6 (0000) putinterval
            upcacode 10 barcode 6 1 getinterval putinterval
            exit
        } if
    } repeat
    /checksum 0 def
    0 1 10 {
       /i exch def
       /barchar upcacode i get 48 sub def
       i 2 mod 0 ne {
           /checksum checksum barchar add def
       } {
           /checksum checksum barchar 3 mul add def
       } ifelse
    } for
    /checksum 10 checksum 10 mod sub 10 mod def
    barcode length 8 eq {
        barcode 7 get checksum 48 add ne {
            /bwipp.upcEbadCheckDigit (Incorrect UPC check digit provided) //raiseerror exec
        } if
    } if
    /pad 8 string def
    pad 0 barcode putinterval       % Add barcode to the start of the pad
    pad 7 checksum 48 add put       % Put ascii for checksum at end of pad
    /barcode pad def
    /txt 8 array def
    txt 0 [barcode 0 1 getinterval textxoffset textyoffset textfont textsize 2 sub] put

    % Determine the mirror map based on checksum
    /mirrormap mirrormaps checksum get def

    % Invert the mirrormap if we are using a non-zero number system
    barcode 0 get 48 eq {
        /invt mirrormap length string def
        0 1 mirrormap length 1 sub {
            /i exch def
            mirrormap i get 48 eq {
                invt i 49 put
            } {
                invt i 48 put
            } ifelse
        } for
        /mirrormap invt def
    } if

    /sbs 33 string def

    % Put the start character
    sbs 0 encs 10 get putinterval

    1 1 6 {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                            % Discard true leaving pre
        length /indx exch def          % indx is the length of pre
        pop pop                        % Discard seek and post
        /enc encs indx get def         % Get the indxth encoding
        mirrormap i 1 sub get 49 eq {  % Reverse enc if 1 in this position in mirrormap        
            /enclen enc length def
            /revenc enclen string def
            0 1 enclen 1 sub {
                /j exch def
                /char enc j get def
                revenc enclen j sub 1 sub char put
            } for
            /enc revenc def
        } if
        sbs i 1 sub 4 mul 3 add enc putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 1 sub 7 mul 11 add textxoffset add textyoffset textfont textsize] put
    } for

    txt 7 [barcode 7 1 getinterval 6 7 mul 18 add textxoffset add textyoffset textfont textsize 2 sub] put

    % Put the end character
    sbs 27 encs 11 get putinterval

    /sbs [sbs {48 sub} forall] def
    includetext {
        /bhs [height height 12{height .075 sub}repeat height height height] def
        /bbs [0 0 12{.075}repeat 0 0 0] def
    } {
        /bhs [17{height}repeat] def
        /bbs [17{0}repeat] def
        /txt [] def
    } ifelse
    /guardrightypos 0 def

    % Append the addon
    addon () ne {
        /addopts <<
            /dontdraw true
            /includetext true
            /height height 0.15 sub
            /textxoffset addontextxoffset (unset) ne {addontextxoffset} {51 addongap add} ifelse
            addontextyoffset (unset) ne {/textyoffset addontextyoffset} if
            /textsize addontextsize (unset) ne {addontextsize} {textsize} ifelse
            /textfont addontextfont (unset) ne {addontextfont} {textfont} ifelse
        >> def
        addon length 2 eq {addon addopts //ean2 exec} if
        addon length 5 eq {addon addopts //ean5 exec} if
        /addcode exch def
        /sbs [sbs aload pop addongap addcode (sbs) get aload pop] def
        /bhs [bhs aload pop addcode (bhs) get {.075 sub} forall] def
        /bbs [bbs aload pop addcode (bbs) get {.075 add} forall] def
        /txt [txt aload pop addcode (txt) get aload pop] def
        /guardrightypos height 72 mul 6 sub def
    } if

    % Return the arguments
    <<
    /ren //renlinear
    /sbs sbs
    /bhs bhs
    /bbs bbs
    /txt txt
    /opt options
    /guardrightpos 10
    /guardrightypos guardrightypos
    /borderbottom 5
    >>

    dontdraw not //renlinear if

    end

} bind def
/upce dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER upce--

% --BEGIN ENCODER isbn--
% --REQUIRES preamble raiseerror renlinear ean5 ean2 ean13--
% --DESC: ISBN
% --EXAM: 978-1-56581-231-4 52250
% --EXOP: includetext guardwhitespace
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp isbn 0.0 2015050900 97266 100181
%%BeginData:        252 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /ean13 dup /uk.co.terryburton.bwipp findresource put
begin
/isbn {

    20 dict begin

    /options exch def      % We are given an options string
    /barcode exch def      % We are given the isbn text with dashes

    /dontdraw false def
    /includetext false def  % Enable/disable ISBN text
    /isbntextfont /Courier def
    /isbntextsize 9 def
    /isbntextxoffset (unset) def
    /isbntextyoffset (unset) def
    /height 1 def
    /addongap 12 def   
    /legacy false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
    
    /isbntextfont isbntextfont cvlit def
    /isbntextsize isbntextsize cvr def
    isbntextxoffset (unset) ne {/isbntextxoffset isbntextxoffset cvr def} if
    isbntextyoffset (unset) ne {/isbntextyoffset isbntextyoffset cvr def} if
    /height height cvr def
    /addongap addongap cvr def

    % Split off the addon
    barcode ( ) search {
        /barcode exch def
        pop
        /addon exch def
    } {
        pop
        /addon () def
    } ifelse

    % Validate the input
    barcode length 15 ne barcode length 17 ne and
    barcode length 11 ne barcode length 13 ne and and {
        /bwipp.isbnBadLength (ISBN-13 must be 15 or 17 characters including dashes. ISBN-10 must be 11 or 13 characters including dashes) //raiseerror exec
    } if
    addon length 0 ne addon length 2 ne and addon length 5 ne and {
        /bwipp.isbnBadAddOnLength (Add-on for ISBN must be 2 or 5 digits) //raiseerror exec
    } if
    barcode length 15 ge {  % ISBN-13
        barcode 0 4 getinterval dup (978-) ne exch (979-) ne and {
            /bwipp.isbn13badPrefix (ISBN-13 prefix must be 978- or 979-) //raiseerror exec
        } if
        /wasdash false def /numdash 0 def /numdigit 0 def
        barcode 5 9 getinterval {
            dup
            45 eq {
                wasdash {
                    /bwipp.isbn13adjacentDashes (ISBN-13 does not permit adjacent dashes) //raiseerror exec
                } if
                /wasdash true def
                /numdash numdash 1 add def
            } if
            dup 48 ge exch 57 le and {
                /wasdash false def
                /numdigit numdigit 1 add def
            } if
        } forall
        numdash 2 ne numdigit 7 ne or {
            /bwipp.isbn13numDashesDigits (Incorrect number of dashes and digits for ISBN-13) //raiseerror exec
        } if
        barcode 14 get dup 48 lt exch 57 gt or {
            /bwipp.isbn13character15 (ISBN-13 character 15 must be a digit) //raiseerror exec
        } if
        barcode length 17 eq {
            barcode 15 1 getinterval (-) ne {
                /bwipp.isbn13character16 (ISBN-13 penultimate character must be a dash) //raiseerror exec
            } if
            barcode 16 get dup 48 lt exch 57 gt or {
                /bwipp.isbn13character17 (ISBN-13 final character must be a digit) //raiseerror exec
            } if
        } if
    } {  % ISBN-10
        barcode 0 get dup 48 lt exch 57 gt or {
            /bwipp.isbn10FirstDigit (ISBN-10 first character must be a digit) //raiseerror exec
        } if
        /wasdash false def /numdash 0 def /numdigit 0 def
        barcode 1 9 getinterval {
            dup
            45 eq {
                wasdash {
                    /bwipp.isbn10adjacentDashes (ISBN-10 does not permit adjacent dashes) //raiseerror exec
                } if
                /wasdash true def
                /numdash numdash 1 add def
            } if
            dup 48 ge exch 57 le and {
                /wasdash false def
                /numdigit numdigit 1 add def
            } if
        } forall
        numdash 2 ne numdigit 7 ne or {
            /bwipp.isbn10numDashesDigits (Incorrect number of dashes and digits for ISBN-10) //raiseerror exec
        } if
        barcode 10 get dup 48 lt exch 57 gt or {
            /bwipp.isbn10character11 (ISBN-10 character 11 must be a digit) //raiseerror exec
        } if
        barcode length 13 eq {
            barcode 11 1 getinterval (-) ne {
                /bwipp.isbn10character12 (ISBN-10 penultimate character must be a dash) //raiseerror exec
            } if
            barcode 12 get dup dup 48 lt exch 57 gt or exch 88 ne and {
                /bwipp.isbn10character13 (ISBN-10 final character must be a digit or X) //raiseerror exec
            } if
        } if
    } ifelse

    /isbntxt barcode def

    % Read the digits from isbntxt and validate checksum for ISBN-10
    isbntxt length 13 le {
        /isbn 10 string def
        /checksum 0 def
        /i 0 def /n 0 def
        { % loop
            /isbnchar isbntxt i get 48 sub def
            isbnchar -3 ne {     % Ignore dashes
                isbn n isbnchar 48 add put
                n 9 lt {
                    /checksum checksum 10 n sub isbnchar mul add def
                } if
                /n n 1 add def
            } if
            /i i 1 add def
            i isbntxt length eq {exit} if
        } loop
        /checksum 11 checksum 11 mod sub 11 mod dup 10 eq {pop 40} if 48 add def
        /isbn isbn 0 9 getinterval def
        isbntxt length 13 eq {
            isbntxt 12 get checksum ne {
                /bwipp.isbn10badCheckDigit (Incorrect ISBN-10 check digit provided) //raiseerror exec
            } if
        } if
    } if

    legacy not isbntxt length 15 ge or {

        % Convert ISBN-10 to ISBN-13
        isbntxt length 13 le {
            /pad 15 string def
            pad 0 (978-) putinterval
            pad 4 isbntxt 0 11 getinterval putinterval
            /isbntxt pad def
        } if

        % Read the digits from isbntxt and validate checksum for ISBN-13
        /isbn 13 string def
        /checksum 0 def
        /i 0 def /n 0 def
        { % loop
            /isbnchar isbntxt i get 48 sub def
            isbnchar -3 ne {     % Ignore dashes
                isbn n isbnchar 48 add put
                n 12 lt {
                    /checksum isbnchar n 2 mod 0 ne {3 mul} if checksum add def
                } if
                /n n 1 add def
            } if
            /i i 1 add def
            i isbntxt length eq {exit} if
        } loop
        /checksum 10 checksum 10 mod sub 10 mod 48 add def
        /isbn isbn 0 12 getinterval def
        isbntxt length 17 eq {
            isbntxt 16 get checksum ne {
                /bwipp.isbn13badCheckDigit (Incorrect ISBN-13 check digit provided) //raiseerror exec
            } if
        } if

    } if

    % Add the ISBN header to the isbntxt
    /pad isbn length 12 eq {22} {18} ifelse string def
    pad 0 (ISBN ) putinterval
    pad 5 isbntxt putinterval
    pad pad length 2 sub 45 put
    pad pad length 1 sub checksum put
    /isbntxt pad def

    % Convert ISBN digits to EAN-13
    /barcode 12 string def
    isbn length 9 eq {        
        barcode 0 (978) putinterval
        barcode 3 isbn putinterval
    } {
        barcode 0 isbn putinterval
    } ifelse

    % Append the addon
    addon () ne {
        12 addon length add 1 add string 
        dup 0 barcode putinterval
        dup 12 ( ) putinterval
        dup 13 addon putinterval
        /barcode exch def
    } if

    % Get the result of encoding with ean13
    options (dontdraw) true put
    options (addongap) addongap put 
    /args barcode options //ean13 exec def

    % Add the ISBN text
    includetext {
        isbntextxoffset (unset) eq {
            /isbntextxoffset isbn length 9 eq {-1} {-12} ifelse def
        } if
        isbntextyoffset (unset) eq {
            /isbntextyoffset height 72 mul 3 add def
        } if
        args (txt) known {
            /txt args (txt) get def
            /newtxt txt length 1 add array def
            newtxt 0 txt putinterval
            newtxt newtxt length 1 sub [isbntxt isbntextxoffset isbntextyoffset isbntextfont isbntextsize] put
            args (txt) newtxt put
        } {
            args (txt) [ [isbntxt isbntextxoffset isbntextyoffset isbntextfont isbntextsize] ] put
        } ifelse
    } if

    args (opt) options put
    args

    dontdraw not //renlinear if

    end
 
} bind def
/isbn dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER isbn--

% --BEGIN ENCODER ismn--
% --REQUIRES preamble raiseerror renlinear ean5 ean2 ean13--
% --DESC: ISMN
% --EXAM: 979-0-2605-3211-3
% --EXOP: includetext guardwhitespace
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp ismn 0.0 2015050900 94206 93526
%%BeginData:        231 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /ean13 dup /uk.co.terryburton.bwipp findresource put
begin
/ismn {

    20 dict begin

    /options exch def      % We are given an options string
    /barcode exch def      % We are given the ismn text with dashes

    /dontdraw false def
    /includetext false def  % Enable/disable ISMN text
    /ismntextfont /Courier def
    /ismntextsize 9 def
    /ismntextxoffset (unset) def
    /ismntextyoffset (unset) def
    /height 1 def
    /addongap 12 def   
    /legacy false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
    
    /ismntextfont ismntextfont cvlit def
    /ismntextsize ismntextsize cvr def
    ismntextxoffset (unset) ne {/ismntextxoffset ismntextxoffset cvr def} if
    ismntextyoffset (unset) ne {/ismntextyoffset ismntextyoffset cvr def} if
    /height height cvr def
    /addongap addongap cvr def
   
    % Split off the addon
    barcode ( ) search {
        /barcode exch def
        pop
        /addon exch def
    } {
        pop
        /addon () def
    } ifelse

    % Validate the input
    barcode length 15 ne barcode length 17 ne and
    barcode length 11 ne barcode length 13 ne and and {
        /bwipp.ismnBadLength (ISMN-13 must be 15 or 17 characters including dashes. ISMN-10 must be 11 or 13 characters including dashes) //raiseerror exec
    } if
    addon length 0 ne addon length 2 ne and addon length 5 ne and {
        /bwipp.ismnBadAddOnLength (Add-on for ISMN must be 2 or 5 digits) //raiseerror exec
    } if
    barcode length 15 ge {  % ISMN-13
        barcode 0 4 getinterval (979-) ne {
            /bwipp.ismn13badPrefix (ISMN-13 prefix must be 979-) //raiseerror exec
        } if
        /wasdash false def /numdash 0 def /numdigit 0 def
        barcode 5 9 getinterval {
            dup
            45 eq {
                wasdash {
                    /bwipp.ismn13adjacentDashes (ISMN-13 does not permit adjacent dashes) //raiseerror exec
                } if
                /wasdash true def
                /numdash numdash 1 add def
            } if
            dup 48 ge exch 57 le and {
                /wasdash false def
                /numdigit numdigit 1 add def
            } if
        } forall
        numdash 2 ne numdigit 7 ne or {
            /bwipp.ismn13numDashesDigits (Incorrect number of dashes and digits for ISMN-13) //raiseerror exec
        } if
        barcode 14 get dup 48 lt exch 57 gt or {
            /bwipp.ismn13character15 (ISMN-13 character 15 must be a digit) //raiseerror exec
        } if
        barcode length 17 eq {
            barcode 15 1 getinterval (-) ne {
                /bwipp.ismn13character16 (ISMN-13 penultimate character must be a dash) //raiseerror exec
            } if
            barcode 16 get dup 48 lt exch 57 gt or {
                /bwipp.ismn13character17 (ISMN-13 final character must be a digit) //raiseerror exec
            } if
        } if
    } {  % ISMN-10
        barcode 0 2 getinterval (M-) ne {
            /bwipp.ismn10badPrefix (ISMN-10 prefix must be M-) //raiseerror exec
        } if
        barcode 2 get dup 48 lt exch 57 gt or {
            /bwipp.ismn10character3 (ISMN-10 character 3 must be a digit) //raiseerror exec
        } if
        /wasdash false def /numdash 0 def /numdigit 0 def
        barcode 3 7 getinterval {
            dup
            45 eq {
                wasdash {
                    /bwipp.ismn10adjacentDashes (ISMN-10 does not permit adjacent dashes) //raiseerror exec
                } if
                /wasdash true def
                /numdash numdash 1 add def
            } if
            dup 48 ge exch 57 le and {
                /wasdash false def
                /numdigit numdigit 1 add def
            } if
        } forall
        numdash 1 ne numdigit 6 ne or {
            /bwipp.ismn10numDashesDigits (Incorrect number of dashes and digits for ISMN-10) //raiseerror exec
        } if
        barcode 10 get dup 48 lt exch 57 gt or {
            /bwipp.ismn10character11 (ISMN-10 character 11 must be a digit) //raiseerror exec
        } if
        barcode length 13 eq {
            barcode 11 1 getinterval (-) ne {
                /bwipp.ismn10character12 (ISMN-10 penultimate character must be a dash) //raiseerror exec
            } if
            barcode 12 get dup dup 48 lt exch 57 gt or exch 88 ne and {
                /bwipp.ismn10character13 (ISMN-10 final character must be a digit or X) //raiseerror exec
            } if
        } if
    } ifelse

    /ismntxt barcode def

    % Convert old ISMN to ISMN-13
    /legacytxt () def
    ismntxt length 13 le {
        /legacytxt ismntxt def
        /pad ismntxt length 4 add string def
        pad 0 (979-0-) putinterval
        pad 6 ismntxt 2 ismntxt length 2 sub getinterval putinterval
        /ismntxt pad def
    } if

    % Read the digits from ismntxt and calculate checksums
    /ismn 13 string def
    /checksum 0 def
    /i 0 def /n 0 def
    { % loop
        /ismnchar ismntxt i get 48 sub def
        ismnchar -3 ne {           % Ignore dashes
            ismn n ismnchar 48 add put
            n 12 lt {
                n 2 mod 0 eq {
                    /checksum ismnchar checksum add def
                } {
                    /checksum ismnchar 3 mul checksum add def
                } ifelse
            } if
            /n n 1 add def
        } if
        /i i 1 add def
        i ismntxt length eq {exit} if
    } loop
    /checksum 10 checksum 10 mod sub 10 mod 48 add def

    % Validate the checksum
    barcode length 13 eq barcode length 17 eq or {
        barcode dup length 1 sub get checksum ne {
            /bwipp.ismnBadCheckDigit (Incorrect ISMN check digit provided) //raiseerror exec
        } if
    } if

    % Add the ISMN header and checksum to the ismntxt
    legacy legacytxt () ne and {
        /ismntxt legacytxt def
        /pad 18 string def
    } {
        /pad 22 string def
    } ifelse
    pad 0 (ISMN ) putinterval
    pad 5 ismntxt putinterval
    pad pad length 2 sub 45 put
    pad pad length 1 sub checksum put
    /ismntxt pad def

    % Convert ISMN digits to EAN-13
    /barcode ismn 0 12 getinterval def 

    % Append the addon
    addon () ne {
        12 addon length add 1 add string 
        dup 0 barcode putinterval
        dup 12 ( ) putinterval
        dup 13 addon putinterval
        /barcode exch def
    } if

    % Get the result of encoding with ean13
    options (dontdraw) true put
    options (addongap) addongap put 
    /args barcode options //ean13 exec def

    % Add the ISMN text
    includetext {
        ismntextxoffset (unset) eq {
            /ismntextxoffset ismntxt length 18 eq {-1} {-12} ifelse def
        } if
        ismntextyoffset (unset) eq {
            /ismntextyoffset height 72 mul 3 add def
        } if
        args (txt) known {
            /txt args (txt) get def
            /newtxt txt length 1 add array def
            newtxt 0 txt putinterval
            newtxt newtxt length 1 sub [ismntxt ismntextxoffset ismntextyoffset ismntextfont ismntextsize] put
            args (txt) newtxt put
        } {
            args (txt) [ [ismntxt ismntextxoffset ismntextyoffset ismntextfont ismntextsize] ] put
        } ifelse
    } if

    args (opt) options put
    args

    dontdraw not //renlinear if

    end
 
} bind def
/ismn dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER ismn--

% --BEGIN ENCODER issn--
% --REQUIRES preamble raiseerror renlinear ean2 ean5 ean13--
% --DESC: ISSN
% --EXAM: 0311-175X 00 17
% --EXOP: includetext guardwhitespace
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp issn 0.0 2015050900 85135 81376
%%BeginData:        177 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /ean13 dup /uk.co.terryburton.bwipp findresource put
begin
/issn {

    20 dict begin

    /options exch def      % We are given an options string
    /issntxt exch def      % We are given the issn text with dashes

    /dontdraw false def
    /includetext false def  % Enable/disable ISSN text
    /issntextfont /Courier def
    /issntextsize 9 def
    /issntextxoffset (unset) def
    /issntextyoffset (unset) def
    /height 1 def
    /addongap 12 def   

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
    
    /issntextfont issntextfont cvlit def
    /issntextsize issntextsize cvr def
    issntextxoffset (unset) ne {/issntextxoffset issntextxoffset cvr def} if
    issntextyoffset (unset) ne {/issntextyoffset issntextyoffset cvr def} if
    /height height cvr def
    /addongap addongap cvr def
   
    % Split off the ISSN
    issntxt ( ) search {
        /issntxt exch def
        pop
        /seqvar exch def
    } { 
        pop
        /seqvar () def
    } ifelse

    % Split off the sequence variant and addon
    seqvar ( ) search {
        /seqvar exch def
        pop
        /addon exch def
    } {
        pop
        /addon seqvar def
        /seqvar (00) def
    } ifelse

    % Validate the input
    issntxt length 8 ne issntxt length 9 ne and {
        /bwipp.issnBadLength (ISSN must be 8 or 9 characters including dash) //raiseerror exec
    } if
    issntxt 0 4 getinterval {
        dup 48 lt exch 57 gt or {
            /bwipp.issnBadFormat (ISSN must have the format XXXX-XXXX) //raiseerror exec
        } if
    } forall
    issntxt 4 1 getinterval (-) ne {
        /bwipp.issnBadFormat (ISSN must have the format XXXX-XXXX) //raiseerror exec
    } if
    issntxt 5 3 getinterval {
        dup 48 lt exch 57 gt or {
            /bwipp.issnBadFormat (ISSN must have the format XXXX-XXXX) //raiseerror exec
        } if
    } forall
    issntxt length 9 eq {
        issntxt 8 get dup dup 48 lt exch 57 gt or exch 88 ne and {  % Digits or X
            /bwipp.issnBadFormat (ISSN must have the format XXXX-XXXX) //raiseerror exec
        } if
    } if
    seqvar length 2 ne {
        /bwipp.issnBadSequenceVariantLength (Sequence variant for ISSN must be 2 digits) //raiseerror exec
    } if
    seqvar {
        dup 48 lt exch 57 gt or {
           /bwipp.issnSequenceVariantBadCharacter (Sequence variant for ISSN must contain only digits) //raiseerror exec
        } if
    } forall
    addon length 0 ne addon length 2 ne and addon length 5 ne and {
        /bwipp.issnBadAddOnLength (Add-on for ISSN must be 2 or 5 digits) //raiseerror exec
    } if

    % Read the digits from issntxt and calculate checksums
    /issn 8 string def
    /checksum 0 def
    /i 0 def /n 0 def
    { % loop
        /issnchar issntxt i get 48 sub def
        issnchar -3 ne {           % Ignore dashes
            issn n issnchar 48 add put
            n 7 lt {
                /checksum checksum issnchar 8 n sub mul add def
            } if
            /n n 1 add def
        } if
        /i i 1 add def
        i issntxt length eq {exit} if
    } loop
    /checksum 11 checksum 11 mod sub 11 mod def
    /checksum checksum 48 add dup 58 eq {pop 88} if def
    issntxt length 9 eq {
        issntxt 8 get checksum ne {
            /bwipp.issnBadCheckDigit (Incorrect ISSN check digit provided) //raiseerror exec
        } if
    } if

    % Add the ISSN header and checksum to the issntxt
    /pad 14 string def
    pad 0 (ISSN ) putinterval
    pad 5 issntxt putinterval  % Add issntxt to the pad
    pad 13 checksum put
    /issntxt pad def

    % Convert ISSN digits to EAN-13
    /barcode issn 0 7 getinterval def 

    % Append the sequence variant
    /barcode 12 string def
    barcode 0 (977) putinterval
    barcode 3 issn putinterval
    barcode 10 seqvar putinterval

    % Append the addon
    addon () ne {
        12 addon length add 1 add string 
        dup 0 barcode putinterval
        dup 12 ( ) putinterval
        dup 13 addon putinterval
        /barcode exch def
    } if

    % Get the result of encoding with ean13
    options (dontdraw) true put
    options (addongap) addongap put 
    /args barcode options //ean13 exec def

    % Add the ISSN text
    includetext {
        issntextxoffset (unset) eq {/issntextxoffset 10 def} if
        issntextyoffset (unset) eq {
            /issntextyoffset height 72 mul 3 add def
        } if
        args (txt) known {
            /txt args (txt) get def
            /newtxt txt length 1 add array def
            newtxt 0 txt putinterval
            newtxt newtxt length 1 sub [issntxt issntextxoffset issntextyoffset issntextfont issntextsize] put
            args (txt) newtxt put
        } {
            args (txt) [ [issntxt issntextxoffset issntextyoffset issntextfont issntextsize] ] put
        } ifelse
    } if

    args (opt) options put
    args

    dontdraw not //renlinear if

    end
 
} bind def
/issn dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER issn--

% --BEGIN ENCODER code128--
% --REQUIRES preamble raiseerror renlinear--
% --DESC: Code 128
% --EXAM: Count01234567^FNC2!
% --EXOP: includetext parsefnc
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp code128 0.0 2015050900 112448 118940
%%BeginData:        421 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/code128 {

    20 dict begin                  % Confine variables to local scope

    /options exch def        % We are given an option string
    /barcode exch def        % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 1 def
    /encoding (auto) def
    /raw false def
    /parse false def
    /parsefnc false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    % Special function characters
    /sta  -1 def  /stb  -2 def  /stc  -3 def 
    /swa  -4 def  /swb  -5 def  /swc  -6 def 
    /fn1  -7 def  /fn2  -8 def  /fn3  -9 def 
    /fn4 -10 def  /sft -11 def  /stp -12 def
    /lka -13 def  /lkc -14 def  % CC-A/B and CC-C linkage

    % Character maps for each state
    /charmaps [
      %  A    B    C         A    B    C         A    B    C
      [  32   32  (00) ]  [ (!)  (!)  (01) ]  [ (")  (")  (02) ]  % 0-2 
      [ (#)  (#)  (03) ]  [ ($)  ($)  (04) ]  [ (%)  (%)  (05) ]  % 3-5
      [ (&)  (&)  (06) ]  [ (')  (')  (07) ]  [  40   40  (08) ]  % 6-8
      [  41   41  (09) ]  [ (*)  (*)  (10) ]  [ (+)  (+)  (11) ]  % 9-11
      [ (,)  (,)  (12) ]  [ (-)  (-)  (13) ]  [ (.)  (.)  (14) ]  % 12-14
      [ (/)  (/)  (15) ]  [ (0)  (0)  (16) ]  [ (1)  (1)  (17) ]  % 15-17
      [ (2)  (2)  (18) ]  [ (3)  (3)  (19) ]  [ (4)  (4)  (20) ]  % 18-20
      [ (5)  (5)  (21) ]  [ (6)  (6)  (22) ]  [ (7)  (7)  (23) ]  % 21-23
      [ (8)  (8)  (24) ]  [ (9)  (9)  (25) ]  [ (:)  (:)  (26) ]  % 24-26
      [ (;)  (;)  (27) ]  [ (<)  (<)  (28) ]  [ (=)  (=)  (29) ]  % 27-29
      [ (>)  (>)  (30) ]  [ (?)  (?)  (31) ]  [ (@)  (@)  (32) ]  % 30-32
      [ (A)  (A)  (33) ]  [ (B)  (B)  (34) ]  [ (C)  (C)  (35) ]  % 33-35
      [ (D)  (D)  (36) ]  [ (E)  (E)  (37) ]  [ (F)  (F)  (38) ]  % 36-38
      [ (G)  (G)  (39) ]  [ (H)  (H)  (40) ]  [ (I)  (I)  (41) ]  % 39-41
      [ (J)  (J)  (42) ]  [ (K)  (K)  (43) ]  [ (L)  (L)  (44) ]  % 42-44
      [ (M)  (M)  (45) ]  [ (N)  (N)  (46) ]  [ (O)  (O)  (47) ]  % 45-47
      [ (P)  (P)  (48) ]  [ (Q)  (Q)  (49) ]  [ (R)  (R)  (50) ]  % 48-50
      [ (S)  (S)  (51) ]  [ (T)  (T)  (52) ]  [ (U)  (U)  (53) ]  % 51-53
      [ (V)  (V)  (54) ]  [ (W)  (W)  (55) ]  [ (X)  (X)  (56) ]  % 54-56
      [ (Y)  (Y)  (57) ]  [ (Z)  (Z)  (58) ]  [ ([)  ([)  (59) ]  % 57-59
      [  92   92  (60) ]  [ (])  (])  (61) ]  [ (^)  (^)  (62) ]  % 60-62
      [ (_)  (_)  (63) ]  [   0  (`)  (64) ]  [   1  (a)  (65) ]  % 63-65
      [   2  (b)  (66) ]  [   3  (c)  (67) ]  [   4  (d)  (68) ]  % 66-68
      [   5  (e)  (69) ]  [   6  (f)  (70) ]  [   7  (g)  (71) ]  % 69-71
      [   8  (h)  (72) ]  [   9  (i)  (73) ]  [  10  (j)  (74) ]  % 72-74
      [  11  (k)  (75) ]  [  12  (l)  (76) ]  [  13  (m)  (77) ]  % 75-77
      [  14  (n)  (78) ]  [  15  (o)  (79) ]  [  16  (p)  (80) ]  % 78-80
      [  17  (q)  (81) ]  [  18  (r)  (82) ]  [  19  (s)  (83) ]  % 81-83
      [  20  (t)  (84) ]  [  21  (u)  (85) ]  [  22  (v)  (86) ]  % 84-86
      [  23  (w)  (87) ]  [  24  (x)  (88) ]  [  25  (y)  (89) ]  % 87-89
      [  26  (z)  (90) ]  [  27  ({)  (91) ]  [  28  (|)  (92) ]  % 90-92
      [  29  (})  (93) ]  [  30  (~)  (94) ]  [  31  127  (95) ]  % 93-95
      [ fn3  fn3  (96) ]  [ fn2  fn2  (97) ]  [ sft  sft  (98) ]  % 96-98
      [ swc  swc  (99) ]  [ swb  fn4  swb  ]  [ fn4  swa  swa  ]  % 99-101
      [ fn1  fn1  fn1  ]  [ sta  sta  sta  ]  [ stb  stb  stb  ]  % 102-104
      [ stc  stc  stc  ]  [ stp  stp  stp  ]                      % 105-106
    ] def 
    
    % Invert charmaps to give character to value maps for each state
    /charvals [ 109 dict 109 dict 109 dict ] def
    0 1 charmaps length 1 sub {
        /i exch def
        /encs charmaps i get def
        0 1 2 {
            /j exch def
            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required
            charvals j get exch i put 
        } for
    } for
    /seta charvals 0 get def
    /setb charvals 1 get def
    /setc charvals 2 get def

    % Include pseudo characters for GS1-128 Composite linkage identifiers
    seta lka seta swb get put  seta lkc seta swc get put
    setb lka setb swc get put  setb lkc setb swa get put
    setc lka setc swa get put  setc lkc setc swb get put

    raw {/encoding (raw) def} if

    encoding (raw) eq {
        /cws barlen array def
        /i 0 def /j 0 def
        { % loop
            i barlen eq {exit} if
            /cw barcode i 1 add 3 getinterval cvi def
            cws j cw put
            /i i 4 add def
            /j j 1 add def
        } loop
        /cws cws 0 j getinterval def
        /text () def
    } if

    encoding (auto) eq { 

        /fncvals <<
            (FNC1) fn1
            (FNC2) fn2
            (FNC3) fn3
            (FNC4) fn4
            (LNKA) lka
            (LNKC) lkc
        >> def

        % Convert input into bytes accounting for FNC and LNK characters 
        /msg barlen array def
        /text barlen string def
        /i 0 def /j 0 def {
            i barlen eq {exit} if
            /char barcode i get def
            text j char put
            parsefnc char 94 eq and i barlen 4 sub lt and {
                barcode i 1 add get 94 ne {
                    /char fncvals barcode i 1 add 4 getinterval get def
                    text j ( ) putinterval
                    /i i 4 add def
                } {
                    /i i 1 add def
                } ifelse
            } if
            msg j char put
            /i i 1 add def
            /j j 1 add def
        } loop
        /msg msg 0 j getinterval def
        /msglen msg length def
        /text text 0 j getinterval def

        % Determine digit runlength and characters from given position
        /numsscr {
            /n 0 def /s 0 def
            /p exch def {
                p msglen ge {exit} if
                msg p get
                dup setc exch known not {pop exit} if
                fn1 eq {
                    % FNC1 in odd position of run like two digits
                    s 2 mod 0 eq {/s s 1 add def} {exit} ifelse
                } if
                /n n 1 add def
                /s s 1 add def
                /p p 1 add def
            } loop
            n s
        } bind def

        % Encoding for each alphabet
        /enca {
            seta exch get cws exch j exch put
            /j j 1 add def
        } bind def
        /encb {
            setb exch get cws exch j exch put
            /j j 1 add def
        } bind def
        /encc {
            dup type /arraytype ne {
                setc exch get
            } {
                aload pop 48 sub exch 48 sub 10 mul add
            } ifelse
            cws exch j exch put
            /j j 1 add def
        } bind def

        % Character exclusively in either alphabet A or B
        /anotb {dup seta exch known exch setb exch known not and} bind def
        /bnota {dup setb exch known exch seta exch known not and} bind def

        % Pre-compute relative position of next anotb and next bnota characters
        /nextanotb [ msg length {0} repeat 9999 ] def
        /nextbnota [ msg length {0} repeat 9999 ] def
        msg length 1 sub -1 0 {
            /i exch def
            msg i get anotb {
                nextanotb i 0 put
            } {
                nextanotb i nextanotb i 1 add get 1 add put
            } ifelse
            msg i get bnota {
                nextbnota i 0 put
            } {
                nextbnota i nextbnota i 1 add get 1 add put
            } ifelse
        } for

        % Does a-only come before b-only after given position and vice versa
        /abeforeb {dup nextanotb exch get exch nextbnota exch get lt} bind def
        /bbeforea {dup nextbnota exch get exch nextanotb exch get lt} bind def
        
        /cws barcode length 2 mul 3 add array def

        % Select start character
        /j 0 def
        msglen 0 gt {0 numsscr} {-1 -1} ifelse /nums exch def /nchars exch def
        {  % common exit
            msglen 0 eq {
                stb enca
                /cset (setb) def
                exit
            } if
            msglen 2 eq nums 2 eq and {
                stc enca
                /cset (setc) def
                exit
            } if
            nums 4 ge {
                stc enca
                /cset (setc) def
                exit
            } if
            0 abeforeb { 
                sta enca
                /cset (seta) def
                exit 
            } if 
            stb enca
            /cset (setb) def
            exit
        } loop

        % Main encoding loop
        /i 0 def {  
            i msglen eq {exit} if
        
            i numsscr /nums exch def /nchars exch def
        
            % Determine switches and shifts
            {  % common exit
                cset (seta) eq cset (setb) eq or nums 4 ge and 
                msg i get fn1 ne and {
                    nums 2 mod 0 eq {
                        swc cset (seta) eq {enca} {encb} ifelse
                        /cset (setc) def
                        exit
                    } {
                        msg i get cset (seta) eq {enca} {encb} ifelse
                        /i i 1 add def
                        swc cset (seta) eq {enca} {encb} ifelse
                        /cset (setc) def
                        exit
                    } ifelse
                } if
                cset (setb) eq msg i get anotb and { 
                    i msglen 1 sub lt {
                        i 1 add bbeforea { 
                            sft encb
                            msg i get enca
                            /i i 1 add def
                            exit
                        } if
                    } if
                    swa encb
                    /cset (seta) def
                    exit
                } if
                cset (seta) eq msg i get bnota and {
                    i msglen 1 sub lt {
                        i 1 add abeforeb {
                            sft enca
                            msg i get encb
                            /i i 1 add def
                            exit
                        } if
                    } if
                    swb enca
                    /cset (setb) def
                    exit
                } if
                cset (setc) eq nums 2 lt and {
                    i abeforeb {
                        swa encc
                        /cset (seta) def
                        exit
                    } if
                    swb encc
                    /cset (setb) def
                    exit
                } if
        
                % No switches or latches so encode
                cset (seta) eq {
                    msg i get enca
                    /i i 1 add def
                    exit
                } if
                cset (setb) eq {
                    msg i get encb
                    /i i 1 add def
                    exit
                } if
                cset (setc) eq {
                    msg i get fn1 eq {
                        fn1 encc
                        /i i 1 add def
                    } {
                        msg i 2 getinterval encc
                        /i i 2 add def 
                    } ifelse
                    exit
                } if
         
                exit
            } loop
        
        } loop
        /cws cws 0 j getinterval def
    } if  % auto encoding

    % Derive checksum and place stop character
    /cws j 2 add array dup 0 cws putinterval def
    /csum cws 0 get def
    1 1 j 1 sub {
        /i exch def
        /csum csum cws i get i mul add def
    } for
    /csum csum 103 mod def
    cws j csum put
    cws j 1 add seta stp get put

    % Create an array containing the character mappings
    /encs
    [ (212222) (222122) (222221) (121223) (121322) (131222) (122213)
      (122312) (132212) (221213) (221312) (231212) (112232) (122132)
      (122231) (113222) (123122) (123221) (223211) (221132) (221231)
      (213212) (223112) (312131) (311222) (321122) (321221) (312212)
      (322112) (322211) (212123) (212321) (232121) (111323) (131123)
      (131321) (112313) (132113) (132311) (211313) (231113) (231311)
      (112133) (112331) (132131) (113123) (113321) (133121) (313121)
      (211331) (231131) (213113) (213311) (213131) (311123) (311321)
      (331121) (312113) (312311) (332111) (314111) (221411) (431111)
      (111224) (111422) (121124) (121421) (141122) (141221) (112214)
      (112412) (122114) (122411) (142112) (142211) (241211) (221114)
      (413111) (241112) (134111) (111242) (121142) (121241) (114212)
      (124112) (124211) (411212) (421112) (421211) (212141) (214121)
      (412121) (111143) (111341) (131141) (114113) (114311) (411113)
      (411311) (113141) (114131) (311141) (411131) (211412) (211214)
      (211232) (2331112)
    ] def

    % Derive space bar succession
    /sbs cws length 6 mul 1 add string def
    0 1 cws length 1 sub {
        /i exch def
        sbs i 6 mul encs cws i get get putinterval
    } for

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    /txt [ [text textxoffset textyoffset textfont textsize] ]
    /textxalign (center)
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/code128 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER code128--

% --BEGIN ENCODER gs1-128--
% --REQUIRES preamble raiseerror renlinear code128--
% --DESC: GS1-128
% --EXAM: (01)95012345678903(3103)000123
% --EXOP: includetext
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp gs1-128 0.0 2015050900 77611 77161
%%BeginData:        157 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code128 dup /uk.co.terryburton.bwipp findresource put
begin
/gs1-128 {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 0.5 def
    /linkagea false def
    /linkagec false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def 
   
    /text barcode def
 
    % Expand ordinals of the form ^NNN to ASCII
    /expand {
        /in exch def
        /out in length string def
        /j 0 def
        in
        { % loop
            (^) search {
                dup out exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi out exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup out exch j exch putinterval
                length j add /j exch def
                out 0 j getinterval exit
            } ifelse 
        } loop
    } bind def
    
    % Parse out AIs
    /ais [] def
    /aival 2 dict def
    barcode dup length 1 sub 1 exch getinterval
    {  % loop
        dup () eq {exit} if
        (\)) search pop
        exch pop
        exch (\() search {
            exch pop exch 3 1 roll 
        } { 
            () 3 1 roll
        } ifelse
        [ ais aload pop counttomark 2 add index ] /ais exch def
        aival 3 1 roll expand put
    } loop
    pop

    % Pre-defined fixed length data field AIs
    % any AI whose prefix is not included in this table must be
    % terminated with "FNC1", even if it's fixed length
    /aifixed 23 dict def
    [
        0 1 4 {} for
    ] {
        (00) 2 string copy dup dup 1 5 -1 roll 48 add put aifixed 3 1 roll put
    } forall
    [
        11 1 20 {} for
        23
        31 1 36 {} for
        41
    ] {
        10 2 string cvrs dup aifixed 3 1 roll put
    } forall

    % Create the code128 data 
    /fnc1 -1 def
    /c128 [ fnc1 ] def
    0 1 ais length 1 sub {
        /i exch def
        /ai ais i get def
        /val aival ai get def
        c128 length ai length add val length add array
        dup 0 c128 putinterval
        dup c128 length ai [ exch {} forall ] putinterval
        dup c128 length ai length add val [ exch {} forall ] putinterval
        /c128 exch def
        i ais length 1 sub ne aifixed ai 0 2 getinterval known not and {  % Append FNC1
            c128 length 1 add array
            dup 0 c128 putinterval
            dup c128 length fnc1 put
            /c128 exch def
        } if
    } for

    % Compose input to code128
    /barcode c128 length 1 add 5 mul string def
    /i 0 def /j 0 def {
        i c128 length eq {exit} if
        c128 i get dup fnc1 eq {
            pop barcode j (^FNC1) putinterval
            /j j 4 add def
        } {
            barcode exch j exch put
        } ifelse
        /i i 1 add def
        /j j 1 add def
    } loop
    linkagea linkagec or {
        barcode j linkagea {(^LNKA)} {(^LNKC)} ifelse putinterval
        /j j 5 add def
    } if
    /barcode barcode 0 j getinterval def

    % Get the result of encoding with code128
    options (height) height put
    options (dontdraw) true put
    options (parsefnc) true put
    /args barcode options //code128 exec def

    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args
 
    dontdraw not //renlinear if
 
    end

} bind def
/gs1-128 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER gs1-128--

% --BEGIN ENCODER ean14--
% --REQUIRES preamble raiseerror renlinear code128--
% --DESC: GS1-14
% --EXAM: (01) 0 46 01234 56789 3
% --EXOP: includetext
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp ean14 0.0 2015050900 69977 69481
%%BeginData:        105 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code128 dup /uk.co.terryburton.bwipp findresource put
begin
/ean14 {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 1 def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def 

    % Strip spaces from the given data
    /text barcode def
    barcode dup length string exch 0 exch
    {dup 32 ne {3 copy put pop 1 add} {pop} ifelse} forall
    0 exch getinterval /barcode exch def
    /hasspace text length barcode length ne def
 
    % Validate the input
    barcode 0 4 getinterval (\(01\)) ne {
        /bwipp.ean14badAI (GS1-14 must begin with (01) application identifier) //raiseerror exec
    } if
    barcode length 17 ne barcode length 18 ne and {
        /bwipp.ean14badLength (GS1-14 must be 13 or 14 digits) //raiseerror exec
    } if
    barcode 4 barcode length 4 sub getinterval {
        dup 48 lt exch 57 gt or {
            /bwipp.ean14badCharacter (GS1-14 must contain only digits) //raiseerror exec
        } if
    } forall

    % Calculate checksum and add to end of barcode
    /checksum 0 def
    0 1 12 {
        /i exch def
        /checksum checksum barcode i 4 add get 48 sub i 2 mod 0 eq {3 mul} if add def
    } for 
    /checksum 10 checksum 10 mod sub 10 mod def
    barcode length 18 eq {
        barcode 17 get checksum 48 add ne {
            /bwipp.ean14badCheckDigit (Incorrect GS1-14 check digit provided) //raiseerror exec
        } if
    } {
        18 string
        dup 0 barcode putinterval
        dup 17 checksum 48 add put
        /barcode exch def
        text length hasspace {2} {1} ifelse add string
        dup dup length 2 sub ( ) putinterval
        dup dup length 1 sub checksum 48 add put
        dup 0 text putinterval
        /text exch def
    } ifelse
    /gtin barcode 4 14 getinterval def

    % Compose input to code128
    /barcode 21 string def
    barcode 0 (^FNC101) putinterval
    barcode 7 gtin putinterval

    % Get the result of encoding with code128
    options (dontdraw) true put
    options (parsefnc) true put
    /args barcode options //code128 exec def

    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args
 
    dontdraw not //renlinear if
 
    end

} bind def
/ean14 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER ean14--

% --BEGIN ENCODER sscc18--
% --REQUIRES preamble raiseerror renlinear code128--
% --DESC: SSCC-18
% --EXAM: (00) 0 0614141 123456789 0
% --EXOP: includetext
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp sscc18 0.0 2015050900 69989 69488
%%BeginData:        105 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code128 dup /uk.co.terryburton.bwipp findresource put
begin
/sscc18 {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 1 def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def 

    % Strip spaces from the given data
    /text barcode def
    barcode dup length string exch 0 exch
    {dup 32 ne {3 copy put pop 1 add} {pop} ifelse} forall
    0 exch getinterval /barcode exch def
    /hasspace text length barcode length ne def

    % Validate the input
    barcode 0 4 getinterval (\(00\)) ne {
        /bwipp.sscc18badAI (SSCC-18 must begin with (00) application identifier) //raiseerror exec
    } if
    barcode length 21 ne barcode length 22 ne and {
        /bwipp.sscc18badLength (SSCC-18 must be 17 or 18 digits) //raiseerror exec
    } if
    barcode 4 barcode length 4 sub getinterval {
        dup 48 lt exch 57 gt or {
            /bwipp.sscc18badCharacter (SSCC-18 must contain only digits) //raiseerror exec
        } if
    } forall

    % Calculate checksum and add to end of barcode
    /checksum 0 def
    0 1 16 {
        /i exch def
        /checksum checksum barcode i 4 add get 48 sub i 2 mod 0 eq {3 mul} if add def
    } for 
    /checksum 10 checksum 10 mod sub 10 mod def
    barcode length 22 eq {
        barcode 21 get checksum 48 add ne {
            /bwipp.sscc18badCheckDigit (Incorrect SSCC-18 check digit provided) //raiseerror exec
        } if
    } {
        22 string
        dup 0 barcode putinterval
        dup 21 checksum 48 add put
        /barcode exch def
        text length hasspace {2} {1} ifelse add string
        dup dup length 2 sub ( ) putinterval
        dup dup length 1 sub checksum 48 add put
        dup 0 text putinterval
        /text exch def
    } ifelse
    /sscc barcode 4 18 getinterval def

    % Compose input to code128
    /barcode 25 string def
    barcode 0 (^FNC100) putinterval
    barcode 7 sscc putinterval

    % Get the result of encoding with code128
    options (dontdraw) true put
    options (parsefnc) true put
    /args barcode options //code128 exec def

    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args
 
    dontdraw not //renlinear if
 
    end

} bind def
/sscc18 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER sscc18--

% --BEGIN ENCODER code39--
% --REQUIRES preamble raiseerror renlinear--
% --DESC: Code 39
% --EXAM: THIS IS CODE 39
% --EXOP: includetext includecheck includecheckintext
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp code39 0.0 2015050900 67013 66837
%%BeginData:        141 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/code39 {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /includecheck false def
    /validatecheck false def
    /includetext false def
    /includecheckintext false def
    /hidestars false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def

    % Create a string of the available characters
    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def
    /charvals 43 dict def
    0 1 42 {charvals exch dup barchars exch 1 getinterval exch put} for

    % Validate the input
    0 1 barcode length 1 sub {
        barcode exch 1 getinterval charvals exch known not {
            /bwipp.code39badCharacter (Code 39 must contain only digits, capital letters, spaces and the symbols -.$/+%) //raiseerror exec
        } if
    } for

    /barlen barcode length validatecheck {1 sub} if def

    /checksum 0 def
    0 1 barlen 1 sub {
        barcode exch 1 getinterval charvals exch get
        checksum add /checksum exch def
    } for
    /checksum checksum 43 mod def
    validatecheck {
        barcode barlen get barchars checksum get ne {
            /bwipp.code39badCheckDigit (Incorrect Code 39 check digit provided) //raiseerror exec
        } if
        /barcode barcode 0 barlen getinterval def
        /includecheck true def
    } if

    % Create an array containing the character mappings
    /encs
    [ (1113313111) (3113111131) (1133111131) (3133111111) (1113311131)
      (3113311111) (1133311111) (1113113131) (3113113111) (1133113111)
      (3111131131) (1131131131) (3131131111) (1111331131) (3111331111)
      (1131331111) (1111133131) (3111133111) (1131133111) (1111333111)
      (3111111331) (1131111331) (3131111311) (1111311331) (3111311311)
      (1131311311) (1111113331) (3111113311) (1131113311) (1111313311)
      (3311111131) (1331111131) (3331111111) (1311311131) (3311311111)
      (1331311111) (1311113131) (3311113111) (1331113111) (1313131111)
      (1313111311) (1311131311) (1113131311) (1311313111)
    ] def

    /sbs barlen includecheck {3} {2} ifelse add 10 mul string def
    /txt barlen includecheck {3} {2} ifelse add array def

    % Put the start character
    sbs 0 encs 43 get putinterval
    hidestars not {
        txt 0 [(*) 0 textyoffset textfont textsize] put
    } {
        txt 0 [() 0 textyoffset textfont textsize] put
    } ifelse

    0 1 barlen 1 sub {
        /i exch def
        /indx charvals barcode i 1 getinterval get def
        sbs i 10 mul 10 add encs indx get putinterval
        txt i 1 add [barcode i 1 getinterval i 1 add 16 mul textyoffset textfont textsize] put
    } for

    % Put the checksum and end characters
    includecheck {
        sbs barlen 10 mul 10 add encs checksum get putinterval
        includecheckintext {
            txt barlen 1 add [barchars checksum 1 getinterval barlen 1 add 16 mul textyoffset textfont textsize] put
        } {
            txt barlen 1 add [() barlen 1 add 16 mul textyoffset textfont textsize] put
        } ifelse
        sbs barlen 10 mul 20 add encs 43 get putinterval
        hidestars not {
            txt barlen 2 add [(*) barlen 2 add 16 mul textyoffset textfont textsize] put
        } {
            txt barlen 2 add [() barlen 2 add 16 mul textyoffset textfont textsize] put
        } ifelse
    } {
        sbs barlen 10 mul 10 add encs 43 get putinterval
        hidestars not {
            txt barlen 1 add [(*) barlen 1 add 16 mul textyoffset textfont textsize] put
        } {
            txt barlen 1 add [() barlen 1 add 16 mul textyoffset textfont textsize] put
        } ifelse
    } ifelse
    
    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/code39 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER code39--

% --BEGIN ENCODER code39ext--
% --REQUIRES preamble raiseerror renlinear code39--
% --DESC: Code 39 Extended
% --EXAM: Code39 Ext!
% --EXOP: includetext includecheck includecheckintext
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp code39ext 0.0 2015050900 65652 65486
%%BeginData:        110 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code39 dup /uk.co.terryburton.bwipp findresource put
begin
/code39ext {

    20 dict begin

    /options exch def      % We are given an options string
    /barcode exch def      % We are given the code39extended text

    /dontdraw false def
    /includetext false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    % Validate the input
    barcode 4 barcode length 4 sub getinterval {
        128 ge {
            /bwipp.code39extBadCharacter (Code 39 Extended must contain only ASCII characters) //raiseerror exec
        } if
    } forall

    /barlen barcode length def

    % Extended alphabet to non-extended alphabet
    /extencs
    [ (%U) ($A) ($B) ($C) ($D) ($E) ($F) ($G) ($H) ($I) ($J) ($K) ($L) ($M) ($N) ($O)
      ($P) ($Q) ($R) ($S) ($T) ($U) ($V) ($W) ($X) ($Y) ($Z) (%A) (%B) (%C) (%D) (%E)
      ( )  (/A) (/B) (/C) (/D) (/E) (/F) (/G) (/H) (/I) (/J) (/K) (/L) (-)  (.)  (/O)
      (0)  (1)  (2)  (3)  (4)  (5)  (6)  (7)  (8)  (9)  (/Z) (%F) (%G) (%H) (%I) (%J)
      (%V) (A)  (B)  (C)  (D)  (E)  (F)  (G)  (H)  (I)  (J)  (K)  (L)  (M)  (N)  (O)
      (P)  (Q)  (R)  (S)  (T)  (U)  (V)  (W)  (X)  (Y)  (Z)  (%K) (%L) (%M) (%N) (%O)
      (%W) (+A) (+B) (+C) (+D) (+E) (+F) (+G) (+H) (+I) (+J) (+K) (+L) (+M) (+N) (+O)
      (+P) (+Q) (+R) (+S) (+T) (+U) (+V) (+W) (+X) (+Y) (+Z) (%P) (%Q) (%R) (%S) (%T)
    ] def

    /newcode barlen 2 mul string def
    /newtext barlen 2 mul string def
    /j 0 def
    0 1 barlen 1 sub {
        /i exch def
        /extchar extencs barcode i get get def
        newcode j extchar putinterval
        newtext j barcode i get put
        extchar length 1 ne {newtext j 1 add ( ) putinterval} if
        /j j extchar length add def
    } for
    /newcode newcode 0 j getinterval def
    /newtext newtext 0 j getinterval def

    % Get the result of encoding with code39
    options (dontdraw) true put
    /args newcode options //code39 exec def

    % Replace chars in /txt with chars in newtext
    includetext {
        /txt args (txt) get def
        0 1 newtext length 1 sub {
            /i exch def
            /txtentry txt i 1 add get def
            txtentry 0 newtext i 1 getinterval put
            txt i 1 add txtentry put
        } for
        args (txt) txt put
    } if
    args (opt) options put
    args

    dontdraw not //renlinear if

    end

} bind def
/code39ext dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER code39ext--

% --BEGIN ENCODER code32--
% --REQUIRES preamble raiseerror renlinear code39--
% --DESC: Italian Pharmacode
% --EXAM: 01234567
% --EXOP: includetext
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp code32 0.0 2015050900 63549 63380
%%BeginData:         99 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code39 dup /uk.co.terryburton.bwipp findresource put
begin
/code32 {

    20 dict begin

    /options exch def      % We are given an options string
    /barcode exch def      % We are given a barcode string

    /dontdraw false def
    /includetext false def  % Enable/disable code32 text
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /textxoffset 0 def
    /height 1 def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def

    % Validate the input
    barcode length 8 ne barcode length 9 ne and {
        /bwipp.code32badLength (Italian Pharmacode must be 8 or 9 digits) //raiseerror exec
    } if
    barcode {
        dup 48 lt exch 57 gt or {
            /bwipp.code32badCharacter (Italian Pharmacode must contain only digits) //raiseerror exec
        } if
    } forall

    % Calculate check digit
    /checksum 0 def
    0 1 7 {
        /i exch def
        barcode i get 48 sub i 2 mod 0 ne {2 mul} if dup 9 gt {9 sub} if
        checksum add /checksum exch def
    } for
    /checksum checksum 10 mod def
    barcode length 9 eq {
        barcode 8 get checksum 48 add ne {
            /bwipp.code32badCheckDigit (Incorrect Italian Pharmacode check digit provided) //raiseerror exec
        } if
    } if
    10 string
    dup 0 barcode putinterval
    dup 8 checksum 48 add put
    /text exch def

    % convert number from base10 to base32
    /val text cvi 32 barcode cvrs def
    /barcode 6 string def
    0 1 5 {barcode exch 48 put} for
    barcode 6 val length sub val putinterval

    % convert base32 number to specified character set
    0 1 5 {
        dup barcode exch get
        dup (AEIO) {ge {1 add} if dup} forall pop
        barcode 3 1 roll put
    } for

    % format HRI
    text 1 text 0 9 getinterval putinterval
    text 0 65 put

    % Get the result of encoding with code39
    options (dontdraw) true put
    /args barcode options //code39 exec def

    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args

    dontdraw not //renlinear if

    end

} bind def
/code32 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER code32--

% --BEGIN ENCODER pzn--
% --REQUIRES preamble raiseerror renlinear code39--
% --DESC: Pharmazentralnummer (PZN)
% --EXAM: 123456
% --EXOP: includetext
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp pzn 0.0 2015050900 63596 63384
%%BeginData:        100 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code39 dup /uk.co.terryburton.bwipp findresource put
begin
/pzn {

    20 dict begin
 
    /options exch def      % We are given an options string
    /barcode exch def      % We are given a barcode string
 
    /dontdraw false def
    /includetext false def  % Enable/disable code32 text
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /textxoffset 0 def
    /height 1 def
    /pzn8 false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /textxoffset textxoffset cvr def
    /height height cvr def

    % Validate the input
    pzn8 {
        barcode length 7 ne barcode length 8 ne and {
            /bwipp.pzn8badLength (PZN8 must be 7 or 8 digits) //raiseerror exec
        } if
    } {
        barcode length 6 ne barcode length 7 ne and {
            /bwipp.pzn7badLength (PZN7 must be 6 or 7 digits) //raiseerror exec
        } if
    } ifelse
    barcode {
        dup 48 lt exch 57 gt or {
            /bwipp.pznBadCharacter (PZN must contain only digits) //raiseerror exec
        } if
    } forall

    % Calculate check digit
    /msglen pzn8 {9} {8} ifelse def
    /checksum 0 def
    0 1 msglen 3 sub {
        /i exch def
        barcode i get 48 sub i pzn8 {1} {2} ifelse add mul
        checksum add /checksum exch def 
    } for 
    /checksum checksum 11 mod def
    checksum 10 eq {
        /bwipp.pznBadInputSequence (Incorrect PZN input sequence provided) //raiseerror exec
    } if
    barcode length msglen 1 sub eq {
        barcode msglen 2 sub get checksum 48 add ne {
            /bwipp.pznBadCheckDigit (Incorrect PZN check digit provided) //raiseerror exec
        } if
    } if
    msglen string
    dup 0 45 put 
    dup 1 barcode putinterval
    dup msglen 1 sub checksum 48 add put
    /msg exch def
 
    % Get the result of encoding with code39
    options (dontdraw) true put
    /args msg options //code39 exec def
 
    % format HRI
    /text msglen 5 add string def
    text 0 (PZN - ) putinterval
    text 6 msg 1 msglen 1 sub getinterval putinterval
 
    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args
 
    dontdraw not //renlinear if
 
    end
 
} bind def
/pzn dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER pzn--

% --BEGIN ENCODER code93--
% --REQUIRES preamble raiseerror renlinear--
% --DESC: Code 93
% --EXAM: THIS IS CODE 93
% --EXOP: includetext includecheck
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp code93 0.0 2015050900 65852 65716
%%BeginData:        148 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/code93 {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /includecheck false def  % Enable/disable checkdigit
    /includetext false def   % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    /parsefnc false def   
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    /encs
    [ (131112) (111213) (111312) (111411) (121113)
      (121212) (121311) (111114) (131211) (141111)
      (211113) (211212) (211311) (221112) (221211)
      (231111) (112113) (112212) (112311) (122112)
      (132111) (111123) (111222) (111321) (121122)
      (131121) (212112) (212211) (211122) (211221)
      (221121) (222111) (112122) (112221) (122121)
      (123111) (121131) (311112) (311211) (321111)
      (112131) (113121) (211131) (121221) (312111)
      (311121) (122211) (111141) (1111411)
    ] def

    % Create a string of the available characters
    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def

    /barlen barcode length def

    % Special function characters
    /sft1 -1 def  /sft2 -2 def  /sft3 -3 def  /sft4 -4 def
    /fncvals <<
        (SFT$) sft1
        (SFT%) sft2
        (SFT/) sft3
        (SFT+) sft4
    >> def

    % Convert input into bytes accounting for shift characters 
    /msg barlen array def
    /i 0 def /j 0 def {
        i barlen eq {exit} if
        /char barcode i get def
        parsefnc char 94 eq and i barlen 4 sub lt and {
            barcode i 1 add get 94 ne {
                /char fncvals barcode i 1 add 4 getinterval get def
                /i i 4 add def
            } {
                /i i 1 add def
            } ifelse
        } if
        msg j char put
        /i i 1 add def
        /j j 1 add def
    } loop
    /msg msg 0 j getinterval def
    /msglen msg length def

    includecheck {
        /sbs msglen 6 mul 25 add string def
    } {
        /sbs msglen 6 mul 13 add string def
    } ifelse
    /txt msglen array def

    % Put the start character
    sbs 0 encs 47 get putinterval
    
    /checksum1 0 def /checksum2 0 def
    0 1 msglen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        msg i get dup 0 lt { 
            42 exch sub /indx exch def
            /char ( ) def
        } {
            1 string dup 0 4 -1 roll put /char exch def
            barchars char search
            pop                                  % Discard true leaving pre
            length /indx exch def                % indx is the length of pre
            pop pop                              % Discard seek and post
        } ifelse
        /enc encs indx get def                   % Get the indxth encoding
        sbs i 6 mul 6 add enc putinterval        % Put encoded digit into sbs
        txt i [char i 9 mul 9 add textyoffset textfont textsize] put
        /checksum1 checksum1 msglen i sub 1 sub 20 mod 1 add indx mul add def
        /checksum2 checksum2 msglen i sub 15 mod 1 add indx mul add def
    } for

    includecheck {
        % Put the first checksum character
        /checksum1 checksum1 47 mod def
        /checksum2 checksum2 checksum1 add 47 mod def
        sbs msglen 6 mul 6 add encs checksum1 get putinterval
        sbs msglen 6 mul 12 add encs checksum2 get putinterval
        % Put the end character
        sbs msglen 6 mul 18 add encs 48 get putinterval
    } {
        % Put the end character
        sbs msglen 6 mul 6 add encs 48 get putinterval      
    } ifelse

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/code93 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER code93--

% --BEGIN ENCODER code93ext--
% --REQUIRES preamble raiseerror renlinear code93--
% --DESC: Code 93 Extended
% --EXAM: Code93 Ext!
% --EXOP: includetext includecheck
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp code93ext 0.0 2015050900 65941 65711
%%BeginData:        114 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code93 dup /uk.co.terryburton.bwipp findresource put
begin
/code93ext {

    20 dict begin

    /options exch def      % We are given an options string
    /barcode exch def      % We are given the code39extended text

    /dontdraw false def
    /includetext false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    % Extended alphabet to non-extended alphabet
    /extencs
    [ (^SFT%U) (^SFT$A) (^SFT$B) (^SFT$C) (^SFT$D) (^SFT$E) (^SFT$F) (^SFT$G) 
      (^SFT$H) (^SFT$I) (^SFT$J) (^SFT$K) (^SFT$L) (^SFT$M) (^SFT$N) (^SFT$O)
      (^SFT$P) (^SFT$Q) (^SFT$R) (^SFT$S) (^SFT$T) (^SFT$U) (^SFT$V) (^SFT$W)
      (^SFT$X) (^SFT$Y) (^SFT$Z) (^SFT%A) (^SFT%B) (^SFT%C) (^SFT%D) (^SFT%E)
      ( )      (^SFT/A) (^SFT/B) (^SFT/C) (^SFT/D) (^SFT/E) (^SFT/F) (^SFT/G)
      (^SFT/H) (^SFT/I) (^SFT/J) (^SFT/K) (^SFT/L) (-)      (.)      (^SFT/O)
      (0)      (1)      (2)      (3)      (4)      (5)      (6)      (7)
      (8)      (9)      (^SFT/Z) (^SFT%F) (^SFT%G) (^SFT%H) (^SFT%I) (^SFT%J)
      (^SFT%V) (A)      (B)      (C)      (D)      (E)      (F)      (G)
      (H)      (I)      (J)      (K)      (L)      (M)      (N)      (O)
      (P)      (Q)      (R)      (S)      (T)      (U)      (V)      (W)
      (X)      (Y)      (Z)      (^SFT%K) (^SFT%L) (^SFT%M) (^SFT%N) (^SFT%O)
      (^SFT%W) (^SFT+A) (^SFT+B) (^SFT+C) (^SFT+D) (^SFT+E) (^SFT+F) (^SFT+G)
      (^SFT+H) (^SFT+I) (^SFT+J) (^SFT+K) (^SFT+L) (^SFT+M) (^SFT+N) (^SFT+O)
      (^SFT+P) (^SFT+Q) (^SFT+R) (^SFT+S) (^SFT+T) (^SFT+U) (^SFT+V) (^SFT+W)
      (^SFT+X) (^SFT+Y) (^SFT+Z) (^SFT%P) (^SFT%Q) (^SFT%R) (^SFT%S) (^SFT%T)
    ] def

    /newcode barlen 6 mul string def
    /newtext barlen 6 mul string def
    /j 0 def /k 0 def
    0 1 barlen 1 sub {
        /i exch def
        /extchar extencs barcode i get get def
        /extlen extchar length def
        newcode j extchar putinterval
        newtext k barcode i get put
        extlen 1 ne {newtext k 1 add ( ) putinterval} if
        /j j extlen add def
        /k k extlen 1 eq {1} {2} ifelse add def
    } for
    /newcode newcode 0 j getinterval def
    /newtext newtext 0 k getinterval def

    % Get the result of encoding with code93
    options (dontdraw) true put
    options (parsefnc) true put
    /args newcode options //code93 exec def

    % Replace chars in /txt with chars in newtext
    includetext {
        /txt args (txt) get def
        0 1 newtext length 1 sub {
            /i exch def
            /txtentry txt i get def
            txtentry 0 newtext i 1 getinterval put
            txt i txtentry put
        } for
        args (txt) txt put
    } if
    args (opt) options put
    args

    dontdraw not //renlinear if

    end

} bind def
/code93ext dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER code93ext--

% --BEGIN ENCODER interleaved2of5--
% --REQUIRES preamble raiseerror renlinear--
% --DESC: Interleaved 2 of 5 (ITF)
% --EXAM: 2401234567
% --EXOP: height=0.5 includecheck includetext includecheckintext
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp interleaved2of5 0.0 2015050900 65832 65492
%%BeginData:        150 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/interleaved2of5 {

    20 dict begin         % Confine variables to local scope

    /options exch def               % We are given an option string
    /barcode exch def               % We are given a barcode string

    /dontdraw false def
    /includecheck false def         % Enable/disable checkdigit
    /includetext false def          % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
    
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def

    % Validate the input
    barcode {
        dup 48 lt exch 57 gt or {
            /bwipp.interleaved2of5badCharacter (Interleaved 2 of 5 must contain only digits) //raiseerror exec
        } if
    } forall
    
    /barlen barcode length def      % Length of the code

    % Prefix 0 to barcode if length is even and including checkdigit
    % or length is odd and not including checkdigit
    barlen 2 mod 0 eq includecheck and          % even & includecheck
    barlen 2 mod 0 ne includecheck not and or { % odd  & !includecheck
        /pad barlen 1 add string def  % Create pad one bigger than barcode
        pad 0 48 put                  % Put ascii 0 at start of pad
        pad 1 barcode putinterval     % Add barcode to the end of pad
        /barcode pad def              % barcode=pad
        /barlen barlen 1 add def      % barlen++
    } if

    % Add checksum to end of barcode
    includecheck {
        /checksum 0 def
        0 1 barlen 1 sub {
            /i exch def
            i 2 mod 0 eq {
                /checksum checksum barcode i get 48 sub 3 mul add def
            } {
                /checksum checksum barcode i get 48 sub add def
            } ifelse
        } for
        /checksum 10 checksum 10 mod sub 10 mod def
        /pad barlen 1 add string def    % Create pad one bigger than barcode
        pad 0 barcode putinterval       % Add barcode to the start of pad
        pad barlen checksum 48 add put  % Add checksum to end of pad
        /barcode pad def                % barcode=pad
        /barlen barlen 1 add def        % barlen++
    } if

    % Create an array containing the character mappings
    /encs
    [ (11221) (21112) (12112) (22111) (11212)
      (21211) (12211) (11122) (21121) (12121)
      (1111)  (2111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def
    /sbs barlen 5 mul 8 add string def
    /txt barlen array def

    % Put the start character
    sbs 0 encs 10 get putinterval

    0 2 barlen 1 sub {
    /i exch def
        % Lookup the encodings for two consecutive barcode characters
        barcode i 1 getinterval barchars exch search
        pop                           % Discard true leaving pre
        length /indx exch def         % indx is the length of pre
        pop pop                       % Discard seek and post
        /enca encs indx get def       % Get the indxth encoding

        barcode i 1 add 1 getinterval barchars exch search
        pop                           % Discard true leaving pre
        length /indx exch def         % indx is the length of pre
        pop pop                       % Discard seek and post
        /encb encs indx get def       % Get the indxth encoding

        % Interleave the two character encodings
        /intl enca length 2 mul string def
        0 1 enca length 1 sub {
            /j exch def
            /achar enca j get def
            /bchar encb j get def
            intl j 2 mul achar put
            intl j 2 mul 1 add bchar put
        } for

        sbs i 5 mul 4 add intl putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 9 mul 4 add textyoffset textfont textsize] put
        includecheck includecheckintext not and barlen 2 sub i eq and {
            txt i 1 add [( ) i 1 add 9 mul 4 add textyoffset textfont textsize] put
        } {
            txt i 1 add [barcode i 1 add 1 getinterval i 1 add 9 mul 4 add textyoffset textfont textsize] put
        } ifelse
    } for

    % Put the end character
    sbs barlen 5 mul 4 add encs 11 get putinterval

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /barratio 2
    /spaceratio 2
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/interleaved2of5 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER interleaved2of5--

% --BEGIN ENCODER itf14--
% --REQUIRES preamble raiseerror renlinear interleaved2of5--
% --DESC: ITF-14
% --EXAM: 0 46 01234 56789 3
% --EXOP: includetext
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp itf14 0.0 2015050900 65819 65737
%%BeginData:        109 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /interleaved2of5 dup /uk.co.terryburton.bwipp findresource put
begin
/itf14 {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /includetext false def
    /includecheckintext true def
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset 3 def
    /height 0.5 def
    /showborder true def
    /borderwidth 4 def
    /borderleft 15 def
    /borderright 15 def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def 
    /borderwidth borderwidth cvr def
    /borderleft borderleft cvr def
    /borderright borderright cvr def

    % Strip spaces from the given data
    /text barcode def
    barcode dup length string exch 0 exch
    {dup 32 ne {3 copy put pop 1 add} {pop} ifelse} forall
    0 exch getinterval /barcode exch def
    /hasspace text length barcode length ne def

    % Validate the input
    barcode length 13 ne barcode length 14 ne and {
        /bwipp.itf14badLength (ITF-14 must be 13 or 14 digits) //raiseerror exec
    } if
    barcode {
        dup 48 lt exch 57 gt or {
            /bwipp.itf14badCharacter (ITF-14 must contain only digits) //raiseerror exec
        } if
    } forall

    % Calculate ITF checksum and add to end of barcode
    /checksum 0 def
    0 1 12 {
        /i exch def
        /checksum checksum barcode i get 48 sub i 2 mod 0 eq {3 mul} if add def
    } for
    /checksum 10 checksum 10 mod sub 10 mod def
    barcode length 14 eq {
        barcode 13 get checksum 48 add ne {
            /bwipp.itf14badCheckDigit (Incorrect ITF-14 check digit provided) //raiseerror exec
        } if
    } {
        14 string
        dup 0 barcode putinterval
        dup 13 checksum 48 add put
        /barcode exch def
        text length hasspace {2} {1} ifelse add string
        dup dup length 2 sub ( ) putinterval
        dup dup length 1 sub checksum 48 add put
        dup 0 text putinterval
        /text exch def
    } ifelse

    % Get the result of encoding with interleaved2of5
    options (dontdraw) true put
    options (showborder) showborder put
    options (borderwidth) borderwidth put
    options (borderleft) borderleft put
    options (borderright) borderright put
    options (height) height put
    options (textyoffset) textyoffset put
    /args barcode options //interleaved2of5 exec def

    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args
 
    dontdraw not //renlinear if
 
    end

} bind def
/itf14 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER itf14--

% --BEGIN ENCODER identcode--
% --REQUIRES preamble raiseerror renlinear interleaved2of5--
% --DESC: Deutsche Post Identcode
% --EXAM: 563102430313
% --EXOP: includetext
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp identcode 0.0 2015050900 62754 62576
%%BeginData:         91 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /interleaved2of5 dup /uk.co.terryburton.bwipp findresource put
begin
/identcode {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 1 def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def 

    % Validate the input
    barcode length 11 ne barcode length 12 ne and {
        /bwipp.identcodeBadLength (Deutsche Post Identcode must be 11 or 12 digits) //raiseerror exec
    } if
    barcode {
        dup 48 lt exch 57 gt or {
            /bwipp.identcodeBadCharacter (Deutsche Post Identcode must contain only digits) //raiseerror exec
        } if
    } forall

    % Calculate checksum and add to end of barcode
    /checksum 0 def
    0 1 10 {
        /i exch def
        /checksum checksum barcode i get 48 sub i 2 mod 0 eq {4 mul} {9 mul} ifelse add def
    } for 
    /checksum 10 checksum 10 mod sub 10 mod def
    barcode length 12 eq {
        barcode 11 get checksum 48 add ne {
            /bwipp.identcodeBadCheckDigit (Incorrect Deutsche Post Identcode check digit provided) //raiseerror exec
        } if
    } if
    12 string
    dup 0 barcode putinterval
    dup 11 checksum 48 add put
    /barcode exch def

    % Compose the human readable text
    /text (  .       .     ) 16 string copy def
    text  0 barcode  0 2 getinterval putinterval
    text  3 barcode  2 3 getinterval putinterval
    text  7 barcode  5 3 getinterval putinterval
    text 11 barcode  8 3 getinterval putinterval
    text 15 barcode 11 1 getinterval putinterval

    % Get the result of encoding with interleaved2of5
    options (dontdraw) true put
    options (includecheck) false put
    /args barcode options //interleaved2of5 exec def

    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args
 
    dontdraw not //renlinear if
 
    end

} bind def
/identcode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER identcode--

% --BEGIN ENCODER leitcode--
% --REQUIRES preamble raiseerror renlinear interleaved2of5--
% --DESC: Deutsche Post Leitcode
% --EXAM: 21348075016401
% --EXOP: includetext
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp leitcode 0.0 2015050900 62746 62572
%%BeginData:         91 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /interleaved2of5 dup /uk.co.terryburton.bwipp findresource put
begin
/leitcode {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 1 def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def 

    % Validate the input
    barcode length 13 ne barcode length 14 ne and {
        /bwipp.leitcodeBadLength (Deutsche Post Leitcode must be 13 or 14 digits) //raiseerror exec
    } if
    barcode {
        dup 48 lt exch 57 gt or {
            /bwipp.leitcodeBadCharacter (Deutsche Post Leitcode must contain only digits) //raiseerror exec
        } if
    } forall

    % Calculate checksum and add to end of barcode
    /checksum 0 def
    0 1 12 {
        /i exch def
        /checksum checksum barcode i get 48 sub i 2 mod 0 eq {4 mul} {9 mul} ifelse add def
    } for 
    /checksum 10 checksum 10 mod sub 10 mod def
    barcode length 14 eq {
        barcode 13 get checksum 48 add ne {
            /bwipp.leitcodeBadCheckDigit (Incorrect Deutsche Post Leitcode check digit provided) //raiseerror exec
        } if
    } if
    14 string
    dup 0 barcode putinterval
    dup 13 checksum 48 add put
    /barcode exch def

    % Compose the human readable text
    /text (     .   .   .    ) 18 string copy def
    text  0 barcode  0 5 getinterval putinterval
    text  6 barcode  5 3 getinterval putinterval
    text 10 barcode  8 3 getinterval putinterval
    text 14 barcode 11 2 getinterval putinterval
    text 17 barcode 13 1 getinterval putinterval

    % Get the result of encoding with interleaved2of5
    options (dontdraw) true put
    options (includecheck) false put
    /args barcode options //interleaved2of5 exec def

    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args
 
    dontdraw not //renlinear if
 
    end

} bind def
/leitcode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER leitcode--

% --BEGIN ENCODER databaromni--
% --REQUIRES preamble raiseerror renlinear renmatrix--
% --DESC: GS1 DataBar Omnidirectional
% --EXAM: (01)24012345678905
% --EXOP:
% --RNDR: renlinear renmatrix
%%BeginResource: uk.co.terryburton.bwipp databaromni 0.0 2015050900 112081 118257
%%BeginData:        418 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databaromni {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /height 33 72 div def
    /linkage false def
    /format (omni) def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
  
    format (truncated) eq {/height 13 72 div def} if
    /height height cvr def

    % Validate the input
    barcode 0 4 getinterval (\(01\)) ne {
        /bwipp.databaromniBadAI (GS1 DataBar Omnidirectional must begin with (01) application identifier) //raiseerror exec
    } if
    barcode length 17 ne barcode length 18 ne and {
        /bwipp.databaromniBadLength (GS1 DataBar Omnidirectional must be 13 or 14 digits) //raiseerror exec
    } if
    barcode 4 barcode length 4 sub getinterval {
        dup 48 lt exch 57 gt or {
            /bwipp.databaromniBadCharacter (GS1 DataBar Omnidirectional must contain only digits) //raiseerror exec
        } if
    } forall

    % Calculate checksum and add to end of barcode
    /checksum 0 def
    0 1 12 {
        /i exch def
        /checksum checksum barcode i 4 add get 48 sub i 2 mod 0 eq {3 mul} if add def
    } for
    /checksum 10 checksum 10 mod sub 10 mod def
    barcode length 18 eq {
        barcode 17 get checksum 48 add ne {
            /bwipp.databaromniBadCheckDigit (Incorrect GS1 DataBar Omnidirectional check digit provided) //raiseerror exec
        } if
    } if
    18 string
    dup 0 barcode putinterval
    dup 17 checksum 48 add put
    /barcode exch def

    % Create the human readable text
    /txt barcode length array def
    0 1 barcode length 1 sub {
        /i exch def
        txt i [barcode i 1 getinterval 0 0 () 0] put
    } for

    /ncr {  % n r
        2 copy sub 2 copy lt {exch} if  % n r maxd mind
        1 1 5 3 roll  % mind j=1 v=1 n maxd
        1 add -1 exch {  % mind j v  n -1 maxd+1
            mul  % mind j v*i
            1 index 3 index le {
                1 index idiv exch 1 add exch
            } if
        } for
        {  % mind j v
            1 index 3 index gt {exit} if
            1 index idiv exch 1 add exch
        } loop
        exch pop exch pop
    } bind def
     
    /getRSSwidths {
        /oe exch def
        /el exch def
        /mw exch def
        /nm exch def
        /val exch def
        /out el array def
        /mask 0 def
        0 1 el 2 sub {
            /bar exch def
            /ew 1 def 
            /mask mask 1 bar bitshift or def {
                /sval nm ew sub 1 sub el bar sub 2 sub ncr def
                oe mask 0 eq and nm ew sub el 2 mul sub bar 2 mul add -2 ge and {
                    /sval sval nm ew sub el sub bar add el bar sub 2 sub ncr sub def
                } if
                el bar sub 2 gt {
                    /lval 0 def
                    nm ew sub el sub bar add 2 add -1 mw 1 add {
                        nm exch sub ew sub 1 sub el bar sub 3 sub ncr
                        /lval exch lval add def
                    } for
                    /sval sval lval el bar sub 1 sub mul sub def
                } {
                    nm ew sub mw gt {/sval sval 1 sub def} if
                } ifelse
                /val val sval sub def
                val 0 lt {exit} if
                /ew ew 1 add def
                /mask mask 1 bar bitshift not and def
            } loop  
            /val val sval add def
            /nm nm ew sub def
            out bar ew put 
        } for
        out el 1 sub nm put
        out
    } bind def
  
    /binval [ 
        linkage {1} {0} ifelse
        barcode 4 13 getinterval {48 sub} forall
    ] def
 
    0 1 12 {
        /i exch def
        binval i 1 add 2 copy get binval i get 4537077 mod 10 mul add put
        binval i binval i get 4537077 idiv put
    } for
    /right binval 13 get 4537077 mod def
    binval 13 2 copy get 4537077 idiv put

    /left 0 def
    /i true def
    0 1 13 {
        /j exch def
        binval j get
        dup 0 eq i and {
            pop
        } {
            /i false def
            /left left 3 -1 roll 10 13 j sub exp cvi mul add def
        } ifelse
    } for
    
    /d1 left 1597 idiv def
    /d2 left 1597 mod def
    /d3 right 1597 idiv def
    /d4 right 1597 mod def

    /tab164 [
        160   0     12 4   8 1  161   1
        960   161   10 6   6 3  80   10
        2014  961   8  8   4 5  31   34
        2714  2015  6  10  3 6  10   70
        2840  2715  4  12  1 8  1    126
    ] def

    /tab154 [
        335   0     5  10  2 7  4   84
        1035  336   7  8   4 5  20  35
        1515  1036  9  6   6 3  48  10
        1596  1516  11 4   8 1  81  1
    ] def

    /i 0 def {
        d1 tab164 i get le {
            tab164 i 1 add 7 getinterval {} forall
            /d1te exch def /d1to exch def
            /d1mwe exch def /d1mwo exch def
            /d1ele exch def /d1elo exch def
            /d1gs exch def
            exit
        } if
        /i i 8 add def
    } loop

    /i 0 def {
        d2 tab154 i get le {
            tab154 i 1 add 7 getinterval {} forall
            /d2te exch def /d2to exch def
            /d2mwe exch def /d2mwo exch def
            /d2ele exch def /d2elo exch def
            /d2gs exch def
            exit
        } if
        /i i 8 add def
    } loop

    /i 0 def {
        d3 tab164 i get le {
            tab164 i 1 add 7 getinterval {} forall
            /d3te exch def /d3to exch def
            /d3mwe exch def /d3mwo exch def
            /d3ele exch def /d3elo exch def
            /d3gs exch def
            exit
        } if
        /i i 8 add def
    } loop

    /i 0 def {
        d4 tab154 i get le {
            tab154 i 1 add 7 getinterval {} forall
            /d4te exch def /d4to exch def
            /d4mwe exch def /d4mwo exch def
            /d4ele exch def /d4elo exch def
            /d4gs exch def
            exit
        } if
        /i i 8 add def
    } loop
    
    /d1wo d1 d1gs sub d1te idiv d1elo d1mwo 4 false getRSSwidths def
    /d1we d1 d1gs sub d1te mod  d1ele d1mwe 4 true  getRSSwidths def
    /d2wo d2 d2gs sub d2to mod  d2elo d2mwo 4 true  getRSSwidths def
    /d2we d2 d2gs sub d2to idiv d2ele d2mwe 4 false getRSSwidths def
    /d3wo d3 d3gs sub d3te idiv d3elo d3mwo 4 false getRSSwidths def
    /d3we d3 d3gs sub d3te mod  d3ele d3mwe 4 true  getRSSwidths def
    /d4wo d4 d4gs sub d4to mod  d4elo d4mwo 4 true  getRSSwidths def
    /d4we d4 d4gs sub d4to idiv d4ele d4mwe 4 false getRSSwidths def

    /d1w 8 array def
    0 1 3 {
        /i exch def
        d1w i 2 mul d1wo i get put
        d1w i 2 mul 1 add d1we i get put
    } for

    /d2w 8 array def
    0 1 3 {
        /i exch def
        d2w 7 i 2 mul sub d2wo i get put
        d2w 6 i 2 mul sub d2we i get put
    } for
    
    /d3w 8 array def
    0 1 3 {
        /i exch def
        d3w 7 i 2 mul sub d3wo i get put
        d3w 6 i 2 mul sub d3we i get put
    } for
    
    /d4w 8 array def
    0 1 3 {
        /i exch def
        d4w i 2 mul d4wo i get put
        d4w i 2 mul 1 add d4we i get put
    } for

    /widths [
        d1w {} forall
        d2w {} forall
        d3w {} forall
        d4w {} forall
    ] def
    
    /checkweights [
        1   3   9   27  2   6   18  54
        58  72  24  8   29  36  12  4
        74  51  17  32  37  65  48  16
        64  34  23  69  49  68  46  59
    ] def

    /checkwidths [
        3 8 2 1 1   3 5 5 1 1   3 3 7 1 1
        3 1 9 1 1   2 7 4 1 1   2 5 6 1 1
        2 3 8 1 1   1 5 7 1 1   1 3 9 1 1
    ] def
    
    /checksum 0 def
    0 1 31 {
        /i exch def
        /checksum checksum widths i get checkweights i get mul add def 
    } for
    /checksum checksum 79 mod def    
    checksum 8 ge {/checksum checksum 1 add def} if
    checksum 72 ge {/checksum checksum 1 add def} if
    /checklt checkwidths checksum 9 idiv 5 mul 5 getinterval def
    /checkrtrev checkwidths checksum 9 mod 5 mul 5 getinterval def
    /checkrt 5 array def
    0 1 4 {
        /i exch def
        checkrt i checkrtrev 4 i sub get put
    } for

    % Stacked format
    format (omni) eq format (truncated) eq or {  % linear

        /sbs [
            1 d1w {} forall checklt {} forall d2w {} forall 
            d4w {} forall checkrt {} forall d3w {} forall 1 1
        ] def
        
        <<
        /ren //renlinear
        /sbs sbs
        /bhs [sbs length 1 add 2 idiv {height} repeat]
        /bbs [sbs length 1 add 2 idiv {0} repeat]
        /txt txt
        /textxalign (center)
        /opt options
        >>
    
        dontdraw not //renlinear if

    } {  % 2D - stacked or stackedomni

        /top [ 1 1 d1w {} forall checklt {} forall d2w {} forall 1 1 0 ] def
        /bot [ 1 1 d4w {} forall checkrt {} forall d3w {} forall 1 1 0 ] def 
        0 2 24 {
            /i exch def
            top i get {0} repeat
            top i 1 add get {1} repeat
        } for
        50 array astore /top exch def 
        0 2 24 {
            /i exch def
            bot i get {1} repeat
            bot i 1 add get {0} repeat
        } for
        50 array astore /bot exch def

        % Stacked
        format (stacked) eq {
            /sep [ 50 {0} repeat ] def
            4 1 45 {
                /i exch def
                top i get bot i get eq {
                    sep i 1 top i get sub put
                } {
                    sep i 1 sep i 1 sub get sub put
                } ifelse
            } for
            /pixs [
                5 {top aload pop} repeat
                sep aload pop
                7 {bot aload pop} repeat
            ] def
            /pixy pixs length 50 idiv def
        } if
    
        % Stacked omnidirectional
        format (stackedomni) eq {
            /sep1 [ top {1 exch sub} forall ] def
            sep1 0  [ 0 0 0 0 ] putinterval
            sep1 46 [ 0 0 0 0 ] putinterval
            18 1 30 {
                /i exch def
                top i get 0 eq {
                    top i 1 sub get 1 eq {
                        1
                    } {
                        sep1 i 1 sub get 0 eq {1} {0} ifelse
                    } ifelse
                } {
                    0
                } ifelse
                sep1 exch i exch put
            } for
            /sep2 [ 0 0 0 0 21 { 0 1 } repeat 0 0 0 0 ] def
            /sep3 [ bot {1 exch sub} forall ] def
            sep3 0  [ 0 0 0 0 ] putinterval
            sep3 46 [ 0 0 0 0 ] putinterval
            19 1 31 {
                /i exch def
                bot i get 0 eq {
                    bot i 1 sub get 1 eq {
                        1
                    } {
                        sep3 i 1 sub get 0 eq {1} {0} ifelse
                    } ifelse
                } {
                    0
                } ifelse
                sep3 exch i exch put
            } for
            /f3 [1 1 1 1 1 1 1 1 1 0 1 1 1] def
            true 0 1 12 {dup bot exch 19 add get exch f3 exch get eq and} for {
                % Right shifted module for value 3 finder
                sep3 19 [ 0 0 0 0 0 0 0 0 0 0 1 0 0 ] putinterval
            } if
            /pixs [
                33 {top aload pop} repeat
                sep1 aload pop
                sep2 aload pop
                sep3 aload pop
                33 {bot aload pop} repeat
            ] def
            /pixy pixs length 50 idiv def
        } if
    
        % Return the arguments
        <<
        /ren //renmatrix
        /pixs pixs
        /pixx 50
        /pixy pixy
        /height pixy 72 div
        /width 50 72 div
        /opt options
        >>
    
        dontdraw not //renmatrix if
     
    } ifelse
    
    end

} bind def
/databaromni dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER databaromni--

% --BEGIN ENCODER databarstacked--
% --REQUIRES preamble raiseerror renlinear renmatrix databaromni--
% --DESC: GS1 DataBar Stacked
% --EXAM: (01)24012345678905
% --EXOP:
% --RNDR: renmatrix
%%BeginResource: uk.co.terryburton.bwipp databarstacked 0.0 2015050900 67872 71029
%%BeginData:         73 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /databaromni dup /uk.co.terryburton.bwipp findresource put
begin
/databarstacked {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Validate the input
    barcode 0 4 getinterval (\(01\)) ne {
        /bwipp.databarstackedBadAI (GS1 DataBar Stacked must begin with (01) application identifier) //raiseerror exec
    } if
    barcode length 17 ne barcode length 18 ne and {
        /bwipp.databarstackedBadLength (GS1 DataBar Stacked must be 13 or 14 digits) //raiseerror exec
    } if
    barcode 4 barcode length 4 sub getinterval {
        dup 48 lt exch 57 gt or {
            /bwipp.databarstackedBadCharacter (GS1 DataBar Stacked must contain only digits) //raiseerror exec
        } if
    } forall

    % Calculate checksum and add to end of barcode
    /checksum 0 def
    0 1 12 {
        /i exch def
        /checksum checksum barcode i 4 add get 48 sub i 2 mod 0 eq {3 mul} if add def
    } for
    /checksum 10 checksum 10 mod sub 10 mod def
    barcode length 18 eq {
        barcode 17 get checksum 48 add ne {
            /bwipp.databarstackedBadCheckDigit (Incorrect GS1 DataBar Stacked check digit provided) //raiseerror exec
        } if
    } if
    18 string
    dup 0 barcode putinterval
    dup 17 checksum 48 add put
    /barcode exch def

    % Get the result of encoding with databaromni with format=stacked
    options (dontdraw) true put
    options (format) (stacked) put

    /args barcode options //databaromni exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/databarstacked dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER databarstacked--

% --BEGIN ENCODER databarstackedomni--
% --REQUIRES preamble raiseerror renlinear renmatrix databaromni--
% --DESC: GS1 DataBar Stacked Omnidirectional
% --EXAM: (01)24012345678905
% --EXOP:
% --RNDR: renmatrix
%%BeginResource: uk.co.terryburton.bwipp databarstackedomni 0.0 2015050900 67972 71109
%%BeginData:         73 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /databaromni dup /uk.co.terryburton.bwipp findresource put
begin
/databarstackedomni {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Validate the input
    barcode 0 4 getinterval (\(01\)) ne {
        /bwipp.databarstackedomniBadAI (GS1 DataBar Stacked Omnidirectional must begin with (01) application identifier) //raiseerror exec
    } if
    barcode length 17 ne barcode length 18 ne and {
        /bwipp.databarstackedomniBadLength (GS1 DataBar Stacked Omnidirectional must be 13 or 14 digits) //raiseerror exec
    } if
    barcode 4 barcode length 4 sub getinterval {
        dup 48 lt exch 57 gt or {
            /bwipp.databarstackedomniBadCharacter (GS1 DataBar Stacked Omnidirectional must contain only digits) //raiseerror exec
        } if
    } forall

    % Calculate checksum and add to end of barcode
    /checksum 0 def
    0 1 12 {
        /i exch def
        /checksum checksum barcode i 4 add get 48 sub i 2 mod 0 eq {3 mul} if add def
    } for
    /checksum 10 checksum 10 mod sub 10 mod def
    barcode length 18 eq {
        barcode 17 get checksum 48 add ne {
            /bwipp.databarstackedomniBadCheckDigit (Incorrect GS1 DataBar Stacked Omnidirectional check digit provided) //raiseerror exec
        } if
    } if
    18 string
    dup 0 barcode putinterval
    dup 17 checksum 48 add put
    /barcode exch def

    % Get the result of encoding with databaromni with format=stackedomni
    options (dontdraw) true put
    options (format) (stackedomni) put

    /args barcode options //databaromni exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/databarstackedomni dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER databarstackedomni--

% --BEGIN ENCODER databartruncated--
% --REQUIRES preamble raiseerror renlinear renmatrix databaromni--
% --DESC: GS1 DataBar Truncated
% --EXAM: (01)24012345678905
% --EXOP:
% --RNDR: renlinear renmatrix
%%BeginResource: uk.co.terryburton.bwipp databartruncated 0.0 2015050900 67898 71045
%%BeginData:         73 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /databaromni dup /uk.co.terryburton.bwipp findresource put
begin
/databartruncated {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Validate the input
    barcode 0 4 getinterval (\(01\)) ne {
        /bwipp.databartruncatedBadAI (GS1 DataBar Truncated must begin with (01) application identifier) //raiseerror exec
    } if
    barcode length 17 ne barcode length 18 ne and {
        /bwipp.databartruncatedBadLength (GS1 DataBar Truncated must be 13 or 14 digits) //raiseerror exec
    } if
    barcode 4 barcode length 4 sub getinterval {
        dup 48 lt exch 57 gt or {
            /bwipp.databartruncatedBadCharacter (GS1 DataBar Truncated must contain only digits) //raiseerror exec
        } if
    } forall

    % Calculate checksum and add to end of barcode
    /checksum 0 def
    0 1 12 {
        /i exch def
        /checksum checksum barcode i 4 add get 48 sub i 2 mod 0 eq {3 mul} if add def
    } for
    /checksum 10 checksum 10 mod sub 10 mod def
    barcode length 18 eq {
        barcode 17 get checksum 48 add ne {
            /bwipp.databartruncatedBadCheckDigit (Incorrect GS1 DataBar Truncated check digit provided) //raiseerror exec
        } if
    } if
    18 string
    dup 0 barcode putinterval
    dup 17 checksum 48 add put
    /barcode exch def

    % Get the result of encoding with databaromni with format=truncated
    options (dontdraw) true put
    options (format) (truncated) put

    /args barcode options //databaromni exec def

    args (opt) options put
    args
 
    dontdraw not //renlinear if

    end

} bind def
/databartruncated dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER databartruncated--

% --BEGIN ENCODER databarlimited--
% --REQUIRES preamble raiseerror renlinear--
% --DESC: GS1 DataBar Limited
% --EXAM: (01)15012345678907
% --EXOP:
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp databarlimited 0.0 2015050900 83260 86093
%%BeginData:        276 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/databarlimited {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /height 10 72 div def
    /linkage false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
   
    /height height cvr def

    % Validate the input
    barcode 0 4 getinterval (\(01\)) ne {
        /bwipp.databarlimitedBadAI (GS1 DataBar Limited must begin with (01) application identifier) //raiseerror exec
    } if
    barcode length 17 ne barcode length 18 ne and {
        /bwipp.databarlimitedBadLength (GS1 DataBar Limited must be 13 or 14 digits) //raiseerror exec
    } if
    barcode 4 get dup 48 lt exch 49 gt or {
        /bwipp.databarlimitedBadStartDigit (GS1 DataBar Limited must begin with 0 or 1) //raiseerror exec
    } if
    barcode 5 barcode length 5 sub getinterval {
        dup 48 lt exch 57 gt or {
            /bwipp.databarlimitedBadCharacter (GS1 DataBar Limited must contain only digits) //raiseerror exec
        } if
    } forall

    % Calculate checksum and add to end of barcode
    /checksum 0 def
    0 1 12 {
        /i exch def
        /checksum checksum barcode i 4 add get 48 sub i 2 mod 0 eq {3 mul} if add def
    } for
    /checksum 10 checksum 10 mod sub 10 mod def
    barcode length 18 eq {
        barcode 17 get checksum 48 add ne {
            /bwipp.databaromniBadCheckDigit (Incorrect GS1 DataBar Limited check digit provided) //raiseerror exec
        } if
    } if
    18 string
    dup 0 barcode putinterval
    dup 17 checksum 48 add put
    /barcode exch def

    % Strip the AI and optional check digit
    /binval [ 
        barcode 4 13 getinterval {48 sub} forall
    ] def
    linkage {
        /linkval [ 2 0 1 5 1 3 3 5 3 1 0 9 6 ] def
        0 1 binval length 1 sub {
            /i exch def
            binval i binval i get linkval i get add put
        } for
    } if 

    % Create the human readable text
    /txt barcode length array def
    0 1 barcode length 1 sub {
        /i exch def
        txt i [barcode i 1 getinterval 0 0 () 0] put
    } for

    /ncr {  % n r
        2 copy sub 2 copy lt {exch} if  % n r maxd mind
        1 1 5 3 roll  % mind j=1 v=1 n maxd
        1 add -1 exch {  % mind j v  n -1 maxd+1
            mul  % mind j v*i
            1 index 3 index le {
                1 index idiv exch 1 add exch
            } if
        } for
        {  % mind j v
            1 index 3 index gt {exit} if
            1 index idiv exch 1 add exch
        } loop
        exch pop exch pop
    } bind def
    
    /getRSSwidths {
        /oe exch def
        /el exch def
        /mw exch def
        /nm exch def
        /val exch def
        /out el array def
        /mask 0 def
        0 1 el 2 sub {
            /bar exch def
            /ew 1 def 
            /mask mask 1 bar bitshift or def {
                /sval nm ew sub 1 sub el bar sub 2 sub ncr def
                oe mask 0 eq and nm ew sub el 2 mul sub bar 2 mul add -2 ge and {
                    /sval sval nm ew sub el sub bar add el bar sub 2 sub ncr sub def
                } if
                el bar sub 2 gt {
                    /lval 0 def
                    nm ew sub el sub bar add 2 add -1 mw 1 add {
                        nm exch sub ew sub 1 sub el bar sub 3 sub ncr
                        /lval exch lval add def
                    } for
                    /sval sval lval el bar sub 1 sub mul sub def
                } {
                    nm ew sub mw gt {/sval sval 1 sub def} if
                } ifelse
                /val val sval sub def
                val 0 lt {exit} if
                /ew ew 1 add def
                /mask mask 1 bar bitshift not and def
            } loop  
            /val val sval add def
            /nm nm ew sub def
            out bar ew put 
        } for
        out el 1 sub nm put
        out
    } bind def
   
    0 1 11 {
        /i exch def
        binval i 1 add 2 copy get binval i get 2013571 mod 10 mul add put
        binval i binval i get 2013571 idiv put
    } for
    /d2 binval 12 get 2013571 mod def
    binval 12 2 copy get 2013571 idiv put

    /d1 0 def
    /i true def
    0 1 12 {
        /j exch def
        binval j get
        dup 0 eq i and {
            pop
        } {
            /i false def
            /d1 d1 3 -1 roll 10 12 j sub exp cvi mul add def
        } ifelse
    } for
    
    /tab267 [
        183063   0        17 9   6 3  6538   28
        820063   183064   13 13  5 4  875    728
        1000775  820064   9  17  3 6  28     6454
        1491020  1000776  15 11  5 4  2415   203
        1979844  1491021  11 15  4 5  203    2408
        1996938  1979845  19 7   8 1  17094  1
        2013570  1996939  7  19  1 8  1      16632
    ] def

    /i 0 def {
        d1 tab267 i get le {
            tab267 i 1 add 7 getinterval {} forall
            /d1te exch def /d1to exch def
            /d1mwe exch def /d1mwo exch def
            /d1ele exch def /d1elo exch def
            /d1gs exch def
            exit
        } if
        /i i 8 add def
    } loop

    /i 0 def {
        d2 tab267 i get le {
            tab267 i 1 add 7 getinterval {} forall
            /d2te exch def /d2to exch def
            /d2mwe exch def /d2mwo exch def
            /d2ele exch def /d2elo exch def
            /d2gs exch def
            exit
        } if
        /i i 8 add def
    } loop

    /d1wo d1 d1gs sub d1te idiv d1elo d1mwo 7 false getRSSwidths def    
    /d1we d1 d1gs sub d1te mod  d1ele d1mwe 7 true  getRSSwidths def
    /d2wo d2 d2gs sub d2te idiv d2elo d2mwo 7 false getRSSwidths def    
    /d2we d2 d2gs sub d2te mod  d2ele d2mwe 7 true  getRSSwidths def

    /d1w 14 array def
    0 1 6 {
        /i exch def
        d1w i 2 mul d1wo i get put
        d1w i 2 mul 1 add d1we i get put
    } for

    /d2w 14 array def
    0 1 6 {
        /i exch def
        d2w i 2 mul d2wo i get put
        d2w i 2 mul 1 add d2we i get put
    } for

    /widths [
        d1w {} forall
        d2w {} forall
    ] def
    
    /checkweights [
        1  3  9  27 81 65 17 51 64 14 42 37 22 66
        20 60 2  6  18 54 73 41 34 13 39 28 84 74
    ] def

    /checkseq [
        0 1 43 {} for
        45 52 57
        63 1 66 {} for
        73 1 79 {} for
        82
        126 1 130 {} for
        132
        141 1 146 {} for
        210 1 217 {} for
        220
        316 1 320 {} for
        322 323
        326 337
    ] def
   
    /checksum 0 def
    0 1 27 {
        /i exch def
        /checksum checksum widths i get checkweights i get mul add def
    } for
    /checksum checksum 89 mod def
    /seq checkseq checksum get def
    /swidths seq 21 idiv 8 3 6 false getRSSwidths def
    /bwidths seq 21 mod  8 3 6 false getRSSwidths def

    /checkwidths [0 0 0 0 0 0 0 0 0 0 0 0 1 1] def
    0 1 5 {
        /i exch def
        checkwidths i 2 mul swidths i get put
        checkwidths i 2 mul 1 add bwidths i get put
    } for
    
    /sbs [
        1 d1w {} forall checkwidths {} forall d2w {} forall 1 1
    ] def
    
    % Return the arguments
    <<
    /ren //renlinear
    /sbs sbs
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    /txt txt
    /textxalign (center)
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/databarlimited dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER databarlimited--

% --BEGIN ENCODER databarexpanded--
% --REQUIRES preamble raiseerror renlinear renmatrix--
% --DESC: GS1 DataBar Expanded
% --EXAM: (01)95012345678903(3103)000123
% --EXOP:
% --RNDR: renlinear renmatrix
%%BeginResource: uk.co.terryburton.bwipp databarexpanded 0.0 2015050900 197224 210202
%%BeginData:        871 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databarexpanded {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /height 34 72 div def
    /format (expanded) def
    /segments -1 def
    /linkage false def   
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /height height cvr def
    /segments segments cvi def

    segments -1 eq {
        /segments format (expandedstacked) eq {4} {22} ifelse def
    } if

    % Expand ordinals of the form ^NNN to ASCII
    /expand {
        /in exch def
        /out in length string def
        /j 0 def
        in
        { % loop
            (^) search {
                dup out exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi out exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup out exch j exch putinterval
                length j add /j exch def
                out 0 j getinterval exit
            } ifelse 
        } loop
    } bind def
    
    % Parse out AIs
    /ais [] def
    /aival 2 dict def
    barcode dup length 1 sub 1 exch getinterval
    {  % loop
        dup () eq {exit} if
        (\)) search pop
        exch pop
        exch (\() search {
            exch pop exch 3 1 roll 
        } { 
            () 3 1 roll
        }  ifelse
        [ ais aload pop counttomark 2 add index ] /ais exch def
        aival 3 1 roll expand put
    } loop
    pop
    
    % Method selection
    {  % common exit
    
        % (01)9...(3103)...
        ais length 2 eq {
            ais 0 get (01) eq ais 1 get (3103) eq and { 
                aival (01) get 0 1 getinterval (9) eq aival (3103) get cvi 32767 le and {
                   (0100) false exit 
                } if
            } if
        } if
    
        % (01)9...(3202)...
        ais length 2 eq {
            ais 0 get (01) eq ais 1 get (3202) eq and {
                aival (01) get 0 1 getinterval (9) eq aival (3202) get cvi 9999 le and {
                    (0101) false exit
                } if
            } if
        } if
    
        % (01)9...(3203)...
        ais length 2 eq {
            ais 0 get (01) eq ais 1 get (3203) eq and {
                aival (01) get 0 1 getinterval (9) eq aival (3203) get cvi 22767 le and {
                    (0101) false exit
                } if
            } if
        } if
    
        % (01)9...(310x/320x)...[(11/13/15/17)...]
        ais length dup 2 eq exch 3 eq or {
           /ai310x false 3100 1 3109 {10 4 string cvrs ais 1 get eq or} for def
           /ai320x false 3200 1 3209 {10 4 string cvrs ais 1 get eq or} for def
           ais length 3 eq {
               /aibad true [ (11) (13) (15) (17) ] {ais 2 get ne and} forall def
           } {
               /aibad false def
           } ifelse
           ais 0 get (01) eq ai310x ai320x or and aibad not and {
               ais length 3 eq {
                   aival (01) get 0 1 getinterval (9) eq 
                   aival ais 1 get get cvi 99999 le and 
                   aival ais 2 get get cvi 999999 le and {
                       ai310x ais 2 get (11) eq and { (0111000) false exit } if
                       ai320x ais 2 get (11) eq and { (0111001) false exit } if
                       ai310x ais 2 get (13) eq and { (0111010) false exit } if
                       ai320x ais 2 get (13) eq and { (0111011) false exit } if
                       ai310x ais 2 get (15) eq and { (0111100) false exit } if
                       ai320x ais 2 get (15) eq and { (0111101) false exit } if
                       ai310x ais 2 get (17) eq and { (0111110) false exit } if
                       ai320x ais 2 get (17) eq and { (0111111) false exit } if
                   } if
               } {
                   aival (01) get 0 1 getinterval (9) eq 
                   aival ais 1 get get cvi 99999 le and {
                       ai310x { (0111000) false exit } if
                       ai320x { (0111001) false exit } if
                   } if
               } ifelse
           } if
        } if
    
        % (01)9...(392x)...
        ais length 2 ge {
            /ai392x false 3920 1 3923 {10 4 string cvrs ais 1 get eq or} for def
            ais 0 get (01) eq ai392x and {
                aival (01) get 0 1 getinterval (9) eq { (01100) true exit } if
            } if
        } if
    
        % (01)9...(393x)...
        ais length 2 ge {
            /ai393x false 3930 1 3933 {10 4 string cvrs ais 1 get eq or} for def
            ais 0 get (01) eq ai393x and {
                aival (01) get 0 1 getinterval (9) eq { (01101) true exit } if
            } if
        } if
    
        % (01)...
        ais 0 get (01) eq { (1) true exit } if
    
        % Freeform
        (00) true exit
    
    } loop
    /gpfallow exch def
    /method exch def
   
    /conv12to40 {
        (0000000000000000000000000000000000000000) 40 string copy
        2 copy  0 10 getinterval exch 0 3 getinterval cvi 2 10 string cvrs dup length 10 exch sub exch putinterval
        2 copy 10 10 getinterval exch 3 3 getinterval cvi 2 10 string cvrs dup length 10 exch sub exch putinterval
        2 copy 20 10 getinterval exch 6 3 getinterval cvi 2 10 string cvrs dup length 10 exch sub exch putinterval
        2 copy 30 10 getinterval exch 9 3 getinterval cvi 2 10 string cvrs dup length 10 exch sub exch putinterval
        exch pop
    } bind def
    
    /conv13to44 {
        (00000000000000000000000000000000000000000000) 44 string copy
        2 copy 0 4 getinterval exch 0 1 getinterval cvi 2 4 string cvrs dup length 4 exch sub exch putinterval
        dup 3 -1 roll 1 12 getinterval conv12to40 4 exch putinterval
    } bind def
    
    /tobin {
        string dup length 1 sub 0 exch 1 exch {1 index exch 48 put} for
        dup 3 -1 roll 2 2 index length string cvrs dup length 2 index length exch sub exch putinterval 
    } bind def
    
    method (00) eq {
        /cdf [] def
        /gpf [] def
    } if
    
    method (1) eq {
        /cdf aival (01) get 0 13 getinterval conv13to44 def
        /cdf [ cdf {48 sub} forall ] def
        /gpf [] def
        /ais ais 1 ais length 1 sub getinterval def
    } if
    
    method (0100) eq {
        /cdf 55 string def
        cdf 0 aival (01) get 1 12 getinterval conv12to40 putinterval
        cdf 40 aival (3103) get cvi 15 tobin putinterval
        /cdf [ cdf {48 sub} forall ] def
        /gpf [] def
        /ais [] def
    } if
    
    method (0101) eq {
        /cdf 55 string def
        cdf 0 aival (01) get 1 12 getinterval conv12to40 putinterval
        ais 1 get (3202) eq {
            aival (3202) get cvi 15 tobin
        } {
            aival (3203) get cvi 10000 add 15 tobin
        } ifelse
        cdf exch 40 exch putinterval
        /cdf [ cdf {48 sub} forall ] def
        /gpf [] def
        /ais [] def
    } if
    
    method length 7 eq {
        /cdf 76 string def
        cdf 0 aival (01) get 1 12 getinterval conv12to40 putinterval
        6 string dup 0 ais 1 get 3 1 getinterval putinterval
        dup aival ais 1 get get 1 5 getinterval 1 exch putinterval cvi 20 tobin
        cdf exch 40 exch putinterval
        ais length 3 eq {
            aival ais 2 get get
            dup 0 2 getinterval cvi 384 mul exch
            dup 2 2 getinterval cvi 1 sub 32 mul exch
            4 2 getinterval cvi add add 
        } {
            38400
        } ifelse
        16 tobin cdf exch 60 exch putinterval
        /cdf [ cdf {48 sub} forall ] def
        /gpf [] def
        /ais [] def
    } if
    
    method (01100) eq {
        /cdf 42 string def
        cdf 0 aival (01) get 1 12 getinterval conv12to40 putinterval
        cdf 40 ais 1 get 3 1 getinterval cvi 2 tobin putinterval
        /cdf [ cdf {48 sub} forall ] def
        /gpf [ aival ais 1 get get {} forall ] def
        /ais ais 2 ais length 2 sub getinterval def
    } if
    
    method (01101) eq {
        /cdf 52 string def
        cdf 0 aival (01) get 1 12 getinterval conv12to40 putinterval
        cdf 40 ais 1 get 3 1 getinterval cvi 2 tobin putinterval
        cdf 42 aival ais 1 get get 0 3 getinterval cvi 10 tobin putinterval
        /cdf [ cdf {48 sub} forall ] def
        /gpf [ aival ais 1 get get dup length 3 sub 3 exch getinterval {} forall ] def
        /ais ais 2 ais length 2 sub getinterval def
    } if
    
    % Variable length symbol field
    gpfallow {
        /vlf 2 array def
    } {
        /vlf [] def
    } ifelse

    % Pre-defined fixed length data field AIs
    % any AI whose prefix is not included in this table must be
    % terminated with "FNC1", even if it's fixed length
    /aifixed 23 dict def
    [
        0 1 4 {} for
    ] {
        (00) 2 string copy dup dup 1 5 -1 roll 48 add put aifixed 3 1 roll put
    } forall
    [
        11 1 20 {} for
        23
        31 1 36 {} for
        41
    ] {
        10 2 string cvrs dup aifixed 3 1 roll put
    } forall

    /fnc1 -1 def /lnumeric -2 def /lalphanumeric -3 def /liso646 -4 def
    
    /numeric <<
        0 1 119 {
            dup (00) 2 string copy dup 3 -1 roll 11 2 string cvrs
            dup length 2 exch sub exch putinterval 
            dup 0 get 65 eq {dup 0 94 put} if 
            dup 1 get 65 eq {dup 1 94 put} if 
            exch 8 add
            (0000000) 7 string copy dup 3 -1 roll 2 7 string cvrs 
            dup length 7 exch sub exch putinterval
        } for
        lalphanumeric (0000)
    >> def
    
    /alphanumeric <<
        48 1 57 {dup 43 sub 5 tobin} for
        fnc1 (01111)
        65 1 90 {dup 33 sub 6 tobin} for
        42 (111010)
        44 1 47 {dup 15 add 6 tobin} for
        lnumeric (000)
        liso646 (00100)
    >> def
    
    /iso646 <<
        48 1 57 {dup 43 sub 5 tobin} for
        fnc1 (01111)
        65 1 90 {dup 1 sub 7 tobin} for
        97 1 122 {dup 7 sub 7 tobin} for
        33 (11101000)
        34 (11101001)
        37 1 47 {dup 197 add 8 tobin} for
        58 1 63 {dup 187 add 8 tobin} for
        95 (11111011)
        32 (11111100)
        lnumeric (000)
        lalphanumeric (00100)
    >> def
    
    % Append the remaining AI data
    0 1 ais length 1 sub {
        /i exch def
        /ai ais i get def
        /val aival ai get def
        gpf length ai length add val length add array
        dup 0 gpf putinterval
        dup gpf length ai [ exch {} forall ] putinterval
        dup gpf length ai length add val [ exch {} forall ] putinterval
        /gpf exch def
        i ais length 1 sub ne aifixed ai 0 2 getinterval known not and {  % Append FNC1
            gpf length 1 add array
            dup 0 gpf putinterval
            dup gpf length fnc1 put
            /gpf exch def
        } if
    } for

    % Calculate the number of bits remaining to the next valid symbol size
    /rembits {
        dup
        12 div ceiling cvi 12 mul            % Round up to multiple of 12 
        48 2 copy lt {exch} if pop           % At least 4 symbols
        dup 12 idiv dup segments mod 1 eq {  % At least 2 symbols on last row of stacked symbol
            1 add 12 mul exch pop
        } {
            pop
        } ifelse 
        exch sub
    } bind def
    
    /encode {
        dup /raw ne {exch get} {pop} ifelse
        [ exch {48 sub} forall ]
        dup length exch
        gpfenc exch j exch putinterval
        /j exch j add def
    } bind def
   
    % Pre-compute alphanumeric and numeric runlengths and position of next ISO646-only characters
    /numericruns [ gpf length {0} repeat 0 -1 ] def
    /alphanumericruns [ gpf length {0} repeat 0 ] def
    /nextiso646only [ gpf length {0} repeat 9999 ] def
    gpf length 1 sub -1 0 {
        /i exch def
        gpf i get
        (00) 2 string copy
        dup 0 gpf i get dup fnc1 eq {pop 94} if put 
        i gpf length 1 sub lt {dup 1 gpf i 1 add get dup fnc1 eq {pop 94} if put} if
        numeric exch known {
            numericruns i numericruns i 2 add get 2 add put
        } {
            numericruns i 0 put
        } ifelse
        dup alphanumeric exch known {
            alphanumericruns i alphanumericruns i 1 add get 1 add put
        } {
            alphanumericruns i 0 put
        } ifelse
        dup iso646 exch known exch alphanumeric exch known not and {
            nextiso646only i 0 put
        } {
            nextiso646only i nextiso646only i 1 add get 1 add put
        } ifelse
    } for
   
    % Encode the general purpose field
    /gpfenc 252 array def
    /i 0 def /j 0 def /mode (numeric) def
    {  % loop
        i gpf length eq {exit} if
        {  % not a loop but common exit point
    
            mode (numeric) eq {
                i gpf length 2 sub le {
                    2 string 
                    dup 0 gpf i get dup fnc1 eq {pop 94} if put
                    dup 1 gpf i 1 add get dup fnc1 eq {pop 94} if put
                    dup numeric exch known {
                        numeric encode
                        /i i 2 add def
                        exit
                    } if
                    pop
                    lalphanumeric numeric encode 
                    /mode (alphanumeric) def
                    exit
                } {
                    gpf i get dup 48 lt exch 57 gt or {
                        lalphanumeric numeric encode
                        /mode (alphanumeric) def
                        exit
                    } if
                    /rem 12 1 add method length add vlf length add cdf length add j add rembits def
                    rem 4 ge rem 6 le and {  % C1 + 1 into 4 to 6 bits
                        (000000) 6 string copy 0 rem getinterval
                        dup gpf i get 47 sub 2 4 string cvrs
                        dup length 4 exch sub exch putinterval /raw encode
                        /i i 1 add def
                        exit
                    } {  % C1.FNC1
                        2 string dup 0 gpf i get put dup 1 94 put numeric encode 
                        /i i 1 add def
                        exit
                    } ifelse
                } ifelse
            } if
    
            mode (alphanumeric) eq {
                gpf i get fnc1 eq {
                    fnc1 alphanumeric encode
                    /mode (numeric) def
                    /i i 1 add def
                    exit
                } if
                gpf i get dup iso646 exch known exch alphanumeric exch known not and {
                     liso646 alphanumeric encode
                     /mode (iso646) def
                     exit
                } if
                numericruns i get 6 ge {
                    lnumeric alphanumeric encode
                    /mode (numeric) def
                    exit
                } if
                numericruns i get dup 4 ge exch i add gpf length eq and {
                    lnumeric alphanumeric encode
                    /mode (numeric) def
                    exit
                } if
                gpf i get alphanumeric encode
                /i i 1 add def
                exit
            } if
    
            mode (iso646) eq {
                gpf i get fnc1 eq {
                    fnc1 iso646 encode
                    /mode (numeric) def
                    /i i 1 add def
                    exit
                } if
                numericruns i get 4 ge nextiso646only i get 10 ge and {
                    lnumeric iso646 encode
                    /mode (numeric) def
                    exit
                } if
                alphanumericruns i get 5 ge nextiso646only i get 10 ge and {
                    lalphanumeric iso646 encode
                    /mode (alphanumeric) def
                    exit
                } if
                gpf i get iso646 encode
                /i i 1 add def
                exit
            } if
    
        } loop
    } loop
    /gpf gpfenc 0 j getinterval def

    % Complete the variable length field and create pad
    1 12 add method length add vlf length add cdf length add gpf length add 
    dup rembits dup array /pad exch def
    vlf length 0 ne {
        add 12 idiv
        dup 2 mod vlf exch 0 exch put
        14 le {0} {1} ifelse vlf exch 1 exch put
    } {
        pop pop
    } ifelse
    pad length 0 gt {
        0 5 pad length 1 sub {  % Fill with 00100
            /i exch def
            pad i [ 0 0 1 0 0 ] 0 pad length i sub 5 2 copy gt {exch} if pop getinterval putinterval 
        } for 
        mode (numeric) eq {  % Prefix shift from numeric to ASCII
            /pad [ 0 0 0 0 pad aload pop ] 0 pad length getinterval def
        } if
    } if
   
    % Concatinate fields
    /binval [
        linkage {1} {0} ifelse 
        method {48 sub} forall
        vlf aload pop
        cdf aload pop
        gpf aload pop
        pad aload pop
    ] def
    /datalen binval length 12 idiv def
    
    /ncr {  % n r
        2 copy sub 2 copy lt {exch} if  % n r maxd mind
        1 1 5 3 roll  % mind j=1 v=1 n maxd
        1 add -1 exch {  % mind j v  n -1 maxd+1
            mul  % mind j v*i
            1 index 3 index le {
                1 index idiv exch 1 add exch
            } if
        } for
        {  % mind j v
            1 index 3 index gt {exit} if
            1 index idiv exch 1 add exch
        } loop
        exch pop exch pop
    } bind def
    
    /getRSSwidths {
        /oe exch def
        /el exch def
        /mw exch def
        /nm exch def
        /val exch def
        /out el array def
        /mask 0 def
        0 1 el 2 sub {
            /bar exch def
            /ew 1 def 
            /mask mask 1 bar bitshift or def {
                /sval nm ew sub 1 sub el bar sub 2 sub ncr def
                oe mask 0 eq and nm ew sub el 2 mul sub bar 2 mul add -2 ge and {
                    /sval sval nm ew sub el sub bar add el bar sub 2 sub ncr sub def
                } if
                el bar sub 2 gt {
                    /lval 0 def
                    nm ew sub el sub bar add 2 add -1 mw 1 add {
                        nm exch sub ew sub 1 sub el bar sub 3 sub ncr
                        /lval exch lval add def
                    } for
                    /sval sval lval el bar sub 1 sub mul sub def
                } {
                    nm ew sub mw gt {/sval sval 1 sub def} if
                } ifelse
                /val val sval sub def
                val 0 lt {exit} if
                /ew ew 1 add def
                /mask mask 1 bar bitshift not and def
            } loop  
            /val val sval add def
            /nm nm ew sub def
            out bar ew put 
        } for
        out el 1 sub nm put
        out
    } bind def

    /tab174 [
        347   0     12 5   7 2  87  4
        1387  348   10 7   5 4  52  20
        2947  1388  8  9   4 5  30  52
        3987  2948  6  11  3 6  10  104
        4191  3988  4  13  1 8  1   204
    ] def

    /dxw datalen array def
    
    0 1 datalen 1 sub {

        /x exch def

        /d binval x 12 mul 12 getinterval def
        /d 0 0 1 11 {/j exch def 2 11 j sub exp cvi d j get mul add} for def

        /j 0 def {
            d tab174 j get le {
                tab174 j 1 add 7 getinterval {} forall
                /dte exch def /dto exch def
                /dmwe exch def /dmwo exch def
                /dele exch def /delo exch def
                /dgs exch def
                exit
            } if
            /j j 8 add def
        } loop

        /dwo d dgs sub dte idiv delo dmwo 4 true  getRSSwidths def
        /dwe d dgs sub dte mod  dele dmwe 4 false getRSSwidths def

        /dw 8 array def        
        x 2 mod 0 eq {                    
            0 1 3 {
                /j exch def
                dw 7 j 2 mul sub dwo j get put
                dw 6 j 2 mul sub dwe j get put
            } for
        } {           
            0 1 3 {
                /j exch def
                dw j 2 mul dwo j get put
                dw j 2 mul 1 add dwe j get put
            } for
        } ifelse

        dxw x dw put

    } for
    
    /finderwidths [
        1 8 4 1 1    1 1 4 8 1
        3 6 4 1 1    1 1 4 6 3
        3 4 6 1 1    1 1 6 4 3
        3 2 8 1 1    1 1 8 2 3
        2 6 5 1 1    1 1 5 6 2
        2 2 9 1 1    1 1 9 2 2
    ] def

    /finderseq [
        [0 1]
        [0 3 2]
        [0 5 2 7]
        [0 9 2 7 4]
        [0 9 2 7 6 11]
        [0 9 2 7 8 11 10]
        [0 1 2 3 4 5 6 7]
        [0 1 2 3 4 5 6 9 8]
        [0 1 2 3 4 5 6 9 10 11]
        [0 1 2 3 4 7 6 9 8 11 10]
    ] def

    /seq finderseq datalen 2 sub 2 idiv get def
    /fxw seq length array def
    0 1 seq length 1 sub {
        /x exch def
        fxw x finderwidths seq x get 5 mul 5 getinterval put
    } for

    /checkweights [
        -1   -1   -1   -1   -1   -1   -1   -1   % A1L
        77   96   32   81   27   9    3    1    % A1R
        20   60   180  118  143  7    21   63   % A2L
        205  209  140  117  39   13   145  189  % A2R
        193  157  49   147  19   57   171  91   % B1L 
        132  44   85   169  197  136  186  62   % B1R
        185  133  188  142  4    12   36   108  % B2L
        50   87   29   80   97   173  128  113  % B2R
        150  28   84   41   123  158  52   156  % C1L
        166  196  206  139  187  203  138  46   % C1R
        76   17   51   153  37   111  122  155  % C2L
        146  119  110  107  106  176  129  43   % C2R
        16   48   144  10   30   90   59   177  % D1L
        164  125  112  178  200  137  116  109  % D1R
        70   210  208  202  184  130  179  115  % D2L
        190  204  68   93   31   151  191  134  % D2R
        148  22   66   198  172  94   71   2    % E1L
        40   154  192  64   162  54   18   6    % E1R
        120  149  25   75   14   42   126  167  % E2L
        175  199  207  69   23   78   26   79   % E2R
        103  98   83   38   114  131  182  124  % F1L
        159  53   88   170  127  183  61   161  % F1R
        55   165  73   8    24   72   5    15   % F2L
        89   100  174  58   160  194  135  45   % F2R
    ] def

    /checkweightseq [
       seq {16 mul checkweights exch 16 getinterval aload pop} forall
    ] dup length 8 sub 8 exch getinterval def

    /widths [
        dxw {{} forall} forall
    ] def
   
    /checksum 0 def
    0 1 widths length 1 sub {
        /i exch def
        /checksum checksum widths i get checkweightseq i get mul add def 
    } for
    /checksum checksum 211 mod datalen 3 sub 211 mul add def

    /i 0 def {
        checksum tab174 i get le {
            tab174 i 1 add 7 getinterval {} forall
            /cte exch def /cto exch def
            /cmwe exch def /cmwo exch def
            /cele exch def /celo exch def
            /cgs exch def
            exit
        } if
        /i i 8 add def
    } loop

    /cwo checksum cgs sub cte idiv celo cmwo 4 true  getRSSwidths def
    /cwe checksum cgs sub cte mod  cele cmwe 4 false getRSSwidths def

    /cw 8 array def        
    0 1 3 {
        /i exch def
        cw i 2 mul cwo i get put
        cw i 2 mul 1 add cwe i get put
    } for

    22 array dup dup
    0 cw put 1 dxw putinterval 0 datalen 1 add getinterval
    /dxw exch def
    /datalen dxw length def

    % Encode row runlengths
    /rows datalen segments div ceiling cvi array def
    /numrows rows length def
    0 1 numrows 1 sub {
        /r exch def
        mark
        segments 4 mod 0 ne r 2 mod 1 eq and {0} if
        1 1
        0 1 segments 1 sub {
            /pos exch r segments mul add def
            pos datalen lt {
                dxw pos get {} forall                 
                pos 2 mod 0 eq {fxw pos 2 idiv get {} forall} if
            } if
        } for
        1 1
        counttomark array astore rows exch r exch put pop
    } for

    format (expandedstacked) ne {  % Linear

        % Remove leading space
        /sbs rows 0 get dup length 1 sub 1 exch getinterval def

        /sbs [
            1
            0 1 datalen 1 sub {
                /i exch def
                dxw i get {} forall
                i 2 mod 0 eq {fxw i 2 idiv get {} forall} if
            } for
            1 1
        ] def

        <<
        /ren //renlinear
        /sbs sbs
        /bhs [sbs length 1 add 2 idiv {height} repeat]
        /bbs [sbs length 1 add 2 idiv {0} repeat]
        /opt options
        >>

        dontdraw not //renlinear if

    } {  % expandedstacked

        /seps numrows array def
        0 1 numrows 1 sub {

            /r exch def
            /row rows r get def

            % Sample runlengths into bitmap
            mark
            0 2 row length 1 sub {
                /i exch def
                row i get {0} repeat
                i row length 1 sub lt {row i 1 add get {1} repeat} if
            } for
            counttomark array astore /row exch def pop

            % Derive the separator pattern
            /sep [ row {1 exch sub} forall ] def
            sep 0 [ 0 0 0 0 ] putinterval
            sep row length 4 sub [ 0 0 0 0 ] putinterval
            /finderpos [  % Finder pattern module positions
                19 98 row length 13 sub {} for
                68 98 row length 13 sub {} for
            ] def 
            finderpos {
                dup 14 add 1 exch {
                    /i exch def
                    row i get 0 eq {
                        row i 1 sub get 1 eq {
                            1
                        } {
                            sep i 1 sub get 0 eq {1} {0} ifelse
                        } ifelse
                    } {
                        0
                    } ifelse
                    sep exch i exch put
                } for
            } forall

            % For even segment-pair symbols reverse alternate rows
            segments 4 mod 0 eq r 2 mod 1 eq and {
                rows r get length rows 0 get length ne  % Except partial width last row
                finderpos length 2 mod 1 eq and {       % with odd finders
                    /row [ 0 row aload pop ] def
                    /sep [ 0 sep aload pop ] def
                } {
                    row length 1 sub -1 0 {row exch get} for
                    row astore pop
                    sep length 1 sub -1 0 {sep exch get} for
                    sep astore pop
                } ifelse
            } if

            rows r row put
            seps r sep put

        } for

        % Extend last row and separator to fill width of symbol
        /pixx rows 0 get length def
        [ pixx {0} repeat ] dup 0 rows numrows 1 sub get putinterval
        rows exch numrows 1 sub exch put 
        [ pixx {0} repeat ] dup 0 seps numrows 1 sub get putinterval
        seps exch numrows 1 sub exch put 

        % Middle separator pattern
        /sep [ pixx 2 idiv 1 add { 0 1 } repeat ] 0 pixx getinterval def
        sep 0 [0 0 0 0] putinterval
        sep pixx 4 sub [0 0 0 0] putinterval

        % Compose the symbol
        /pixs [
            0 1 numrows 1 sub {
                /r exch def
                r 0 ne {
                    seps r get aload pop
                } if
                34 {rows r get aload pop} repeat
                r numrows 1 sub ne {
                    seps r get aload pop
                    sep aload pop
                } if
            } for
        ] def

        <<
        /ren //renmatrix
        /pixs pixs
        /pixx pixx
        /pixy pixs length pixx idiv
        /height pixs length pixx idiv 72 div
        /width pixx 72 div
        /opt options
        >>

        dontdraw not //renmatrix if

    } ifelse

    end

} bind def
/databarexpanded dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER databarexpanded--

% --BEGIN ENCODER databarexpandedstacked--
% --REQUIRES preamble raiseerror renlinear renmatrix databarexpanded--
% --DESC: GS1 DataBar Expanded Stacked
% --EXAM: (01)95012345678903(3103)000123
% --EXOP: segments=4
% --RNDR: renlinear renmatrix
%%BeginResource: uk.co.terryburton.bwipp databarexpandedstacked 0.0 2015050900 63589 66857
%%BeginData:         43 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /databarexpanded dup /uk.co.terryburton.bwipp findresource put
begin
/databarexpandedstacked {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Get the result of encoding with databarexpanded with format=expandedstacked
    options (dontdraw) true put
    options (format) (expandedstacked) put

    /args barcode options //databarexpanded exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/databarexpandedstacked dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER databarexpandedstacked--

% --BEGIN ENCODER pharmacode--
% --REQUIRES preamble raiseerror renlinear--
% --DESC: Pharmaceutical Binary Code
% --EXAM: 117480
% --EXOP: showborder
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp pharmacode 0.0 2015050900 60269 60124
%%BeginData:         91 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/pharmacode {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /height 8 2.835 mul 72 div def
    /nwidth 0.5 2.835 mul def
    /wwidth 1.5 2.835 mul def
    /swidth 1.0 2.835 mul def    

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /height height cvr def
    /nwidth nwidth cvr def
    /wwidth wwidth cvr def
    /swidth swidth cvr def

    % Validate the input
    barcode length 1 lt barcode length 6 gt or {
        /bwipp.pharmacodeBadLength (Pharmacode must be 1 to 6 digits) //raiseerror exec
    } if
    barcode {
        dup 48 lt exch 57 gt or {
            /bwipp.pharmacodeBadCharacter (Pharmacode must contain only digits) //raiseerror exec
        } if
    } forall
    barcode cvi dup 3 lt exch 131070 gt or {
        /bwipp.pharmacodeBadValue (Pharmacode value must be between 3 and 131070) //raiseerror exec
    } if

    % Create the human readable text
    /txt barcode length array def
    0 1 barcode length 1 sub {
        /i exch def
        txt i [barcode i 1 getinterval 0 0 () 0] put
    } for

    % Convert the integer into the paramacode string 
    /barcode barcode cvi 1 add 2 17 string cvrs def
    /barcode barcode 1 barcode length 1 sub getinterval def

    /barlen barcode length def  % Length of the code
    /sbs barlen 2 mul array def

    0 1 barlen 1 sub {
        /i exch def
        /enc barcode i 1 getinterval def
        enc (0) eq {
            sbs i 2 mul nwidth put
        } {
            sbs i 2 mul wwidth put
        } ifelse
        sbs i 2 mul 1 add swidth put
    } for

    % Return the arguments
    <<
    /ren //renlinear
    /sbs sbs
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    /txt txt
    /textxalign (center)
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/pharmacode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER pharmacode--

% --BEGIN ENCODER pharmacode2--
% --REQUIRES preamble raiseerror renlinear--
% --DESC: Two-track Pharmacode
% --EXAM: 117480
% --EXOP: includetext showborder
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp pharmacode2 0.0 2015050900 60956 60646
%%BeginData:         96 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/pharmacode2 {

    20 dict begin

    /options exch def           % We are given an option string
    /barcode exch def           % We are given a barcode string

    /dontdraw false def
    /includetext false def      % Enable/disable text
    /height 4 def               % Height of short bars in millimetres

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /height height cvr def

    % Validate the input
    barcode length 1 lt barcode length 8 gt or {
        /bwipp.pharmacode2BadLength (Two-track Pharmacode must be 1 to 6 digits) //raiseerror exec
    } if
    barcode {
        dup 48 lt exch 57 gt or {
            /bwipp.pharmacode2badCharacter (Two-track Pharmacode must contain only digits) //raiseerror exec
        } if
    } forall
    barcode cvi dup 4 lt exch 64570080 gt or {
        /bwipp.pharmacode2badValue (Two-track Pharmacode value must be between 4 and 64570080) //raiseerror exec
    } if

    % Create the human readable text
    /txt barcode length array def
    0 1 barcode length 1 sub {
        /i exch def
        txt i [barcode i 1 getinterval 0 0 () 0] put
    } for

    /encstr 16 string def
    /bhs 16 array def
    /bbs 16 array def
    /sbs 32 array def
    /bar 1 25.4 div height mul def     % bar height (mm)
    /spc 1 25.4 div 72 mul def         % bar width & spacing (1mm)
 
    % Convert number into a base3 representation
    /i 15 def
    /val barcode cvi def
    {  % loop
        val 0 eq {exit} if
        val 3 mod dup
        [3 1 2] exch get val exch sub 3 idiv /val exch def
        encstr i [2 0 1] 4 -1 roll get put
        /i i 1 sub def
    } loop
    /encstr encstr i 1 add 15 i sub getinterval def
 
    % Generate the bar pattern
    0 1 encstr length 1 sub {
        /i exch def
        encstr i get dup
        bhs i bar [1 1 2] 5 -1 roll get mul put
        bbs i [0 bar 0] 4 -1 roll get put
    } for
     
    % Return the arguments
    <<
    /ren //renlinear
    /bhs bhs
    /bbs bbs
    /sbs [encstr length 2 mul {spc} repeat]
    /txt txt
    /textxalign (center)
    /textyoffset 4
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/pharmacode2 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER pharmacode2--

% --BEGIN ENCODER code2of5--
% --REQUIRES preamble raiseerror renlinear--
% --DESC: Code 25
% --EXAM: 01234567
% --EXOP: includetext includecheck includecheckintext
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp code2of5 0.0 2015050900 67430 67109
%%BeginData:        150 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/code2of5 {

    20 dict begin                 % Confine variable to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /includecheck false def
    /validatecheck false def
    /includetext false def   % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    /version (industrial) def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def

    % Validate input
    barcode {
        dup 48 lt exch 57 gt or {
            /bwipp.code2of5badCharacter (Code 25 must contain only digits) //raiseerror exec
        } if
    } forall

    /barlen barcode length validatecheck {1 sub} if def

    /checksum 0 def
    0 1 barlen 1 sub {
        /i exch def
        /checksum checksum barcode i get 48 sub barlen i sub 2 mod 0 ne {3 mul} if add def
    } for
    /checksum 10 checksum 10 mod sub 10 mod def
    validatecheck {
        barcode barlen get checksum 48 add ne {
            /bwipp.code2of5badCheckDigit (Incorrect Code 25 check digit provided) //raiseerror exec
        } if
        /barcode barcode 0 barlen getinterval def
        /includecheck true def
    } if

    % Create an array containing the character mappings
    /versions << 
    /industrial
        [ (1111313111) (3111111131) (1131111131) (3131111111)
          (1111311131) (3111311111) (1131311111) (1111113131)
          (3111113111) (1131113111) (313111)     (31113)
        ] 
    /iata
        [ (1111313111) (3111111131) (1131111131) (3131111111)
          (1111311131) (3111311111) (1131311111) (1111113131)
          (3111113111) (1131113111) (1111)       (311)
        ]
    /matrix
        [ (113311) (311131) (131131) (331111) (113131) (313111)
          (133111) (111331) (311311) (131311) (311111) (31111)
        ]
    /coop
        [ (331111) (111331) (113131) (113311) (131131) (131311)
          (133111) (311131) (311311) (313111) (3131)   (133)
        ]
    /datalogic
        [ (113311) (311131) (131131) (331111) (113131) (313111)
          (133111) (111331) (311311) (131311) (1111)   (311)
        ]
    >> def
    versions version known not {
        /bwipp.code2of5badVersion (Unrecognised Code 25 version) //raiseerror exec
    } if
    /encs versions version get def

    /cs encs 0 get length def
    /cw 0 encs 0 get {48 sub add} forall def
    /ss encs dup length 2 sub get length def
    /sw 0 encs dup length 2 sub get {48 sub add} forall def

    % Create a string of the available characters
    /barchars (0123456789) def

    /sbs barlen includecheck {1 add} if cs mul ss add ss add string def
    /txt barlen includecheck {1 add} if array def

    % Put the start character
    sbs 0 encs 10 get putinterval
    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                 % Discard true leaving pre
        length /indx exch def               % indx is the length of pre
        pop pop                             % Discard seek and post
        /enc encs indx get def              % Get the indxth encoding
        sbs i cs mul ss add enc putinterval % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i cw mul sw add textyoffset textfont textsize] put
    } for

    % Put the checksum and end characters
    includecheck {
        sbs barlen cs mul ss add encs checksum get putinterval
        sbs barlen cs mul cs add ss add encs 11 get putinterval
        includecheckintext {
            txt barlen [barchars checksum 1 getinterval barlen cw mul sw add textyoffset textfont textsize] put
        } {
            txt barlen [( ) barlen cw mul sw add textyoffset textfont textsize] put
        } ifelse
    } {
        sbs barlen cs mul ss add encs 11 get putinterval
    } ifelse

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/code2of5 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER code2of5--

% --BEGIN ENCODER industrial2of5--
% --REQUIRES preamble raiseerror renlinear code2of5--
% --DESC: Industrial 2 of 5
% --EXAM: 01234567
% --EXOP: includetext includecheck includecheckintext
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp industrial2of5 0.0 2015050900 57882 57606
%%BeginData:         55 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code2of5 dup /uk.co.terryburton.bwipp findresource put
begin
/industrial2of5 {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 1 def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def 

    % Get the result of encoding with code2of5 with version=industrial
    options (dontdraw) true put
    options (version) (industrial) put

    /args barcode options //code2of5 exec def

    args (opt) options put
    args

    dontdraw not //renlinear if
 
    end

} bind def
/industrial2of5 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER industrial2of5--

% --BEGIN ENCODER iata2of5--
% --REQUIRES preamble raiseerror renlinear code2of5--
% --DESC: IATA 2 of 5
% --EXAM: 01234567
% --EXOP: includetext includecheck includecheckintext
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp iata2of5 0.0 2015050900 57852 57582
%%BeginData:         55 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code2of5 dup /uk.co.terryburton.bwipp findresource put
begin
/iata2of5 {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 1 def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def 

    % Get the result of encoding with code2of5 with version=iata
    options (dontdraw) true put
    options (version) (iata) put

    /args barcode options //code2of5 exec def

    args (opt) options put
    args

    dontdraw not //renlinear if
 
    end

} bind def
/iata2of5 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER iata2of5--

% --BEGIN ENCODER matrix2of5--
% --REQUIRES preamble raiseerror renlinear code2of5--
% --DESC: Matrix 2 of 5
% --EXAM: 01234567
% --EXOP: includetext includecheck includecheckintext
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp matrix2of5 0.0 2015050900 57862 57590
%%BeginData:         55 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code2of5 dup /uk.co.terryburton.bwipp findresource put
begin
/matrix2of5 {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 1 def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def 

    % Get the result of encoding with code2of5 with version=matrix
    options (dontdraw) true put
    options (version) (matrix) put

    /args barcode options //code2of5 exec def

    args (opt) options put
    args

    dontdraw not //renlinear if
 
    end

} bind def
/matrix2of5 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER matrix2of5--

% --BEGIN ENCODER coop2of5--
% --REQUIRES preamble raiseerror renlinear code2of5--
% --DESC: COOP 2 of 5
% --EXAM: 01234567
% --EXOP: includetext includecheck includecheckintext
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp coop2of5 0.0 2015050900 57852 57582
%%BeginData:         55 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code2of5 dup /uk.co.terryburton.bwipp findresource put
begin
/coop2of5 {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 1 def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def 

    % Get the result of encoding with code2of5 with version=coop
    options (dontdraw) true put
    options (version) (coop) put

    /args barcode options //code2of5 exec def

    args (opt) options put
    args

    dontdraw not //renlinear if
 
    end

} bind def
/coop2of5 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER coop2of5--

% --BEGIN ENCODER datalogic2of5--
% --REQUIRES preamble raiseerror renlinear code2of5--
% --DESC: Datalogic 2 of 5
% --EXAM: 01234567
% --EXOP: includetext includecheck includecheckintext
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp datalogic2of5 0.0 2015050900 57877 57602
%%BeginData:         55 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code2of5 dup /uk.co.terryburton.bwipp findresource put
begin
/datalogic2of5 {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 1 def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def 

    % Get the result of encoding with code2of5 with version=datalogic
    options (dontdraw) true put
    options (version) (datalogic) put

    /args barcode options //code2of5 exec def

    args (opt) options put
    args

    dontdraw not //renlinear if
 
    end

} bind def
/datalogic2of5 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER datalogic2of5--

% --BEGIN ENCODER code11--
% --REQUIRES preamble raiseerror renlinear--
% --DESC: Code 11
% --EXAM: 0123456789
% --EXOP: includetext includecheck includecheckintext
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp code11 0.0 2015050900 69086 68582
%%BeginData:        158 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/code11 {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /includecheck false def
    /validatecheck false def
    /includetext false def
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (111131) (311131) (131131) (331111) (113131)
      (313111) (133111) (111331) (311311) (311111)
      (113111) (113311)
    ] def

    % Create a string of the available characters
    /barchars (0123456789-) def
    /charvals 11 dict def
    0 1 10 {charvals exch dup barchars exch 1 getinterval exch put} for

    % Validate the input
    0 1 barcode length 1 sub {
        barcode exch 1 getinterval charvals exch known not {
            /bwipp.code11badCharacter (Code 11 must contain only digits and dashes) //raiseerror exec
        } if
    } for

    /barlen barcode length def
    validatecheck {
        barlen 11 eq {
            /bwipp.code11badLength (Code 11 cannot be 11 characters using check digits) //raiseerror exec
        } if
        /barlen barlen barlen 10 le {1} {2} ifelse sub def
    } if

    /numchecks includecheck validatecheck or {barlen 10 ge {2} {1} ifelse} {0} ifelse def
    /checksum1 0 def /checksum2 0 def
    0 1 barlen 1 sub {
        /i exch def
        /indx charvals barcode i 1 getinterval get def
        /checksum1 checksum1 barlen i sub 1 sub 10 mod 1 add indx mul add def
        /checksum2 checksum2 barlen i sub 9 mod 1 add indx mul add def
    } for
    /checksum1 checksum1 11 mod def
    /checksum2 checksum2 checksum1 add 11 mod def
    validatecheck {
        numchecks 1 eq {
            barcode barlen get barchars checksum1 get ne {
                /bwipp.code11badCheckDigit (Incorrect Code 11 check digit provided) //raiseerror exec
            } if
        } {
            barcode barlen get barchars checksum1 get ne
            barcode barlen 1 add get barchars checksum2 get ne or {
                /bwipp.code11badCheckDigits (Incorrect Code 11 check digits provided) //raiseerror exec
            } if
        } ifelse
        /barcode barcode 0 barlen getinterval def
        /includecheck true def
    } if

    /sbs barlen numchecks add 6 mul 12 add string def
    /txt barlen numchecks add array def

    % Put the start character
    sbs 0 encs 11 get putinterval

    /xpos 8 def
    0 1 barlen 1 sub {
        /i exch def
        /indx charvals barcode i 1 getinterval get def
        /enc encs indx get def
        sbs i 6 mul 6 add enc putinterval
        txt i [barcode i 1 getinterval xpos textyoffset textfont textsize] put
        0 1 5 {       % xpos+=width of the character
            /xpos exch enc exch get 48 sub xpos add def
        } for
    } for
   
    % Put the checksum and end characters
    includecheck {
        barlen 10 ge {
            sbs barlen 6 mul 6 add encs checksum1 get putinterval        
            sbs barlen 6 mul 12 add encs checksum2 get putinterval
            includecheckintext {
                txt barlen [barchars checksum1 1 getinterval xpos textyoffset textfont textsize] put
                /enc encs checksum1 get def   
                0 1 5 {       % xpos+=width of the character
                    /xpos exch enc exch get 48 sub xpos add def
                } for
                txt barlen 1 add [barchars checksum2 1 getinterval xpos textyoffset textfont textsize] put
            } {
                txt barlen [() xpos textyoffset textfont textsize] put
                txt barlen 1 add [() xpos textyoffset textfont textsize] put
            } ifelse
            sbs barlen 6 mul 18 add encs 11 get putinterval
        } {
            sbs barlen 6 mul 6 add encs checksum1 get putinterval          
            includecheckintext {
                txt barlen [barchars checksum1 1 getinterval xpos textyoffset textfont textsize] put
            } {
                txt barlen [() xpos textyoffset textfont textsize] put
            } ifelse
            sbs barlen 6 mul 12 add encs 11 get putinterval
        } ifelse
    } {
        sbs barlen 6 mul 6 add encs 11 get putinterval
    } ifelse

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/code11 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER code11--

% --BEGIN ENCODER bc412--
% --REQUIRES preamble raiseerror renlinear--
% --DESC: BC412
% --EXAM: BC412
% --EXOP: semi includetext includecheckintext
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp bc412 0.0 2015050900 64995 64541
%%BeginData:        148 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/bc412 {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /includecheck false def
    /validatecheck false def
    /includetext false def
    /includecheckintext false def
    /includestartstop false def
    /semi false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
   
    semi {
        /includecheck true def
        /includestartstop true def
    } if

    % Create a string of the available characters
    /barchars (0R9GLVHA8EZ4NTS1J2Q6C7DYKBUIX3FWP5M) def
    /charvals 35 dict def
    0 1 34 {charvals exch dup barchars exch 1 getinterval exch put} for

    % Validate the input
    0 1 barcode length 1 sub {
        barcode exch 1 getinterval charvals exch known not {
            /bwipp.bc412badCharacter (BC412 must contain only digits and capital letters except O) //raiseerror exec
        } if
    } for

    /barlen barcode length validatecheck {1 sub} if def

    /checksum 0 def
    0 1 barlen 1 sub {
        barcode exch 1 getinterval charvals exch get
        checksum add /checksum exch def
    } for
    /checksum checksum 35 mod def
    validatecheck {
        barcode barlen get barchars checksum get ne {
            /bwipp.bc412badCheckDigit (Incorrect BC412 check digit provided) //raiseerror exec
        } if
        /barcode barcode 0 barlen getinterval def
        /includecheck true def
    } if

    % Create an array containing the character mappings
    /encs
    [ (11111115) (13111212) (11131113) (12111213) (12121311)
      (13131111) (12111312) (11131212) (11121411) (11151111)
      (15111111) (11111511) (12131211) (13121112) (13111212)
      (11111214) (12121113) (11111313) (13111113) (11121213)
      (11141112) (11121312) (11141211) (14121111) (12121212)
      (11131311) (13121211) (12111411) (14111211) (11111412)
      (12111114) (14111112) (12141111) (11121114) (12131112)
      (12) (111)
    ] def

    /sbs barlen 1 add 8 mul 5 add string def
    includecheck {
        /txt barlen 1 add array def
    } {
        /txt barlen array def
    } ifelse

    % Put the start character
    includestartstop {
        sbs 0 encs 35 get putinterval
        /pos 2 def
        /txtpos 3 def
    } {
        /pos 0 def
        /txtpos 0 def
    } ifelse

    0 1 barlen 1 sub {
        /i exch def
        /indx charvals barcode i 1 getinterval get def
        sbs pos encs indx get putinterval
        txt i [barcode i 1 getinterval i 12 mul txtpos add textyoffset textfont textsize] put
        /pos pos 8 add def
    } for

    % Put the checksum
    includecheck {
        sbs pos encs checksum get putinterval
        includecheckintext {
            txt barlen [barchars checksum 1 getinterval barlen 12 mul txtpos add textyoffset textfont textsize] put
        } {
            txt barlen [() barlen 12 mul txtpos add textyoffset textfont textsize] put
        } ifelse
        /pos pos 8 add def
    } if 

    % Put the stop character
    includestartstop { 
        sbs pos encs 36 get putinterval
        /pos pos 2 add def
    } if

    % Return the arguments
    /sbs sbs 0 pos getinterval def 
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/bc412 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER bc412--

% --BEGIN ENCODER rationalizedCodabar--
% --REQUIRES preamble raiseerror renlinear--
% --DESC: Codabar
% --EXAM: A0123456789B
% --EXOP: includetext includecheck includecheckintext
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp rationalizedCodabar 0.0 2015050900 69398 68906
%%BeginData:        156 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/rationalizedCodabar {

    20 dict begin                    % Confine variables to local scope

    /options exch def          % We are given an option string
    /barcode exch def          % We are given a barcode string

    /dontdraw false def
    /altstartstop false def
    /includecheck false def     % Enable/disable checkdigit
    /validatecheck false def
    /includetext false def      % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
    
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (11111331) (11113311) (11131131) (33111111) (11311311)
      (31111311) (13111131) (13113111) (13311111) (31131111)
      (11133111) (11331111) (31113131) (31311131) (31313111)
      (11313131) (11331311) (13131131) (11131331) (11133311)
    ] def

    % Create a string of the available characters
    altstartstop {
        /barchars (0123456789-$:/.+TN*E) def
    } {
        /barchars (0123456789-$:/.+ABCD) def
    } ifelse
    /charvals 20 dict def
    0 1 19 {charvals exch dup barchars exch 1 getinterval exch put} for
    /bodyvals 16 dict def
    0 1 15 {bodyvals exch dup barchars exch 1 getinterval exch put} for
    /ssvals 4 dict def
    16 1 19 {ssvals exch dup barchars exch 1 getinterval exch put} for

    % Validate the input
    barcode 0 1 getinterval ssvals exch known not 
    barcode barcode length 1 sub 1 getinterval ssvals exch known not or {
        altstartstop {
            /bwipp.rationalizedCodabarBadAltStartStop (Codabar start and stop characters must be one of E N T or *) //raiseerror exec
        } {
            /bwipp.rationalizedCodabarBadStartStop (Codabar start and stop characters must be one of A B C or D) //raiseerror exec
        } ifelse
    } if
    1 1 barcode length 2 sub {
        barcode exch 1 getinterval bodyvals exch known not {
            /bwipp.rationalizedCodabarBadCharacter (Codabar body must contain only digits and symbols - $ : / . +) //raiseerror exec
        } if
    } for

    /barlen barcode length validatecheck {1 sub} if def

    /checksum 0 def
    0 1 barlen 2 sub {
        barcode exch 1 getinterval charvals exch get
        checksum add /checksum exch def
    } for
    barcode barcode length 1 sub 1 getinterval charvals exch get
    checksum add /checksum exch def 
    /checksum 16 checksum 16 mod sub 16 mod def
    validatecheck {
        barcode barlen 1 sub get barchars checksum get ne {
            /bwipp.rationalizedCodabarBadCheckDigit (Incorrect Codabar check digit provided) //raiseerror exec
        } if
        barlen string
        dup 0 barcode 0 barlen 1 sub getinterval putinterval
        dup barlen 1 sub barcode barlen 1 getinterval putinterval
        /barcode exch def
        /includecheck true def
    } if

    /sbs barlen includecheck {1 add} if 8 mul string def
    /txt barlen includecheck {1 add} if array def

    /xpos 0 def
    0 1 barlen 2 sub {
        /i exch def
        /indx charvals barcode i 1 getinterval get def
        /enc encs indx get def
        sbs i 8 mul enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval xpos textyoffset textfont textsize] put
        0 1 7 {       % xpos+=width of the character
            /xpos exch enc exch get 48 sub xpos add def
        } for
    } for

    % Put the checksum character and stop character
    includecheck {
        % Put the checksum character
        sbs barlen 8 mul 8 sub encs checksum get putinterval
        includecheckintext {
            txt barlen 1 sub [barchars checksum 1 getinterval xpos textyoffset textfont textsize] put
        } {
            txt barlen 1 sub [( ) xpos textyoffset textfont textsize] put
        } ifelse
        0 1 7 {       % xpos+=width of the character
            /xpos exch encs checksum get exch get 48 sub xpos add def
        } for
        % Put the end character
        /indx charvals barcode barlen 1 sub 1 getinterval get def
        /enc encs indx get def            % Get the indxth encoding
        sbs barlen 8 mul enc putinterval  % Put encoded digit into sbs
        txt barlen [barcode barlen 1 sub 1 getinterval xpos textyoffset textfont textsize] put
    } {
        % Put the end character
        /indx charvals barcode barlen 1 sub 1 getinterval get def
        /enc encs indx get def                  % Get the indxth encoding
        sbs barlen 8 mul 8 sub enc putinterval  % Put encoded digit into sbs
        txt barlen 1 sub [barcode barlen 1 sub 1 getinterval xpos textyoffset textfont textsize] put
    } ifelse

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/rationalizedCodabar dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER rationalizedCodabar--

% --BEGIN ENCODER onecode--
% --REQUIRES preamble raiseerror renlinear--
% --DESC: USPS Intelligent Mail
% --EXAM: 0123456709498765432101234567891
% --EXOP: barcolor=FF0000
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp onecode 0.0 2015050900 101896 104906
%%BeginData:        335 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/onecode {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /height 0.15 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /height height cvr def

    /barlen barcode length def
 
    % Create the human readable text
    /txtdict <<
        2 dup
        5 dup
        barcode 5 1 getinterval (9) eq {14} {11} ifelse dup
        20 dup
        25 dup
        29 dup
    >> def
    /txt barlen 6 add array def
    /spacecnt 0 def
    0 1 barlen 1 sub {
        /i exch def
        txtdict i known {
            txt i spacecnt add [( ) 0 0 () 0] put
            /spacecnt spacecnt 1 add def
        } if
        txt i spacecnt add [barcode i 1 getinterval 0 0 () 0] put
    } for
    /txt txt 0 barcode length spacecnt add getinterval def

    /normalize {
        /base exch def
        /num exch def
        num length 1 sub -1 1 {
            /i exch def        
            num i 1 sub 2 copy get num i get base idiv add put
            num i num i get base mod put
        } for
        { %loop - extend input as necessary
            num 0 get base lt {exit} if
            /num [0 num {} forall] def        
            num 0 num 0 get num 1 get base idiv add put
            num 1 num 1 get base mod put
        } loop
        % Trim leading zeros
        /num [/i true def num {dup 0 eq i and {pop} {/i false def} ifelse} forall] def   
        num length 0 eq {/num [0] def} if
        num
    } bind def

    /bigadd {
        2 copy length exch length
        2 copy sub abs /offset exch def
        lt {exch} if
        /a exch def /b exch def    
        0 1 b length 1 sub {
            dup a exch offset add 2 copy get b 5 -1 roll get add put
        } for
        a
    } bind def

    % Conversion of data fields into binary data
    barlen 20 eq {[0]} if
    barlen 25 eq {[1]} if
    barlen 29 eq {[1 0 0 0 0 1]} if
    barlen 31 eq {[1 0 0 0 1 0 0 0 0 1]} if
    /binval exch [barcode 20 barlen 20 sub getinterval {48 sub} forall] bigadd def
    /binval [binval {} forall barcode 0 get 48 sub] def
    /binval [binval {5 mul} forall] [barcode 1 get 48 sub] bigadd 10 normalize def
    /binval [binval {} forall barcode 2 18 getinterval {48 sub} forall] def

    % Conversion of binary data into byte array
    /bytes 13 array def
    /bintmp [binval {} forall] def
    12 -1 0 {
        /i exch def
        0 1 bintmp length 2 sub {
            /j exch def
            bintmp j 1 add 2 copy get bintmp j get 256 mod 10 mul add put
            bintmp j bintmp j get 256 idiv put
        } for
        bytes i bintmp bintmp length 1 sub get 256 mod put
        bintmp bintmp length 1 sub 2 copy get 256 idiv put    
    } for

    % Generation of 11-bit CRC on byte array
    /fcs 2047 def
    /dat bytes 0 get 5 bitshift def
    6 {
        fcs dat xor 1024 and 0 ne {
            /fcs fcs 1 bitshift 3893 xor def 
        } {
            /fcs fcs 1 bitshift def
        } ifelse
        /fcs fcs 2047 and def
        /dat dat 1 bitshift def
    } repeat
    1 1 12 {
        bytes exch get 3 bitshift /dat exch def    
        8 {        
            fcs dat xor 1024 and 0 ne {
                /fcs fcs 1 bitshift 3893 xor def 
            } {
                /fcs fcs 1 bitshift def
            } ifelse
            /fcs fcs 2047 and def
            /dat dat 1 bitshift def
        } repeat
    } for

    % Conversion from binary data to codewords
    /codewords 10 array def
    9 -1 0 {
        /i exch def
        i 9 eq {
            /b 636 def
        } {
            /b 1365 def
        } ifelse
        0 1 binval length 2 sub {
            /j exch def
            binval j 1 add 2 copy get binval j get b mod 10 mul add put
            binval j binval j get b idiv put
        } for   
        codewords i binval binval length 1 sub get b mod put
        binval binval length 1 sub 2 copy get b idiv put
    } for

    % Inserting additional information into codewords
    codewords 9 codewords 9 get 2 mul put
    fcs 1024 and 0 ne {
        codewords 0 codewords 0 get 659 add put
    } if

    % Conversion from codewords to characters
    /tab513 [
        31 7936   47 7808   55 7552   59 7040   61 6016   62 3968   79 7744   87 
      7488   91 6976   93 5952   94 3904  103 7360  107 6848  109 5824  110 3776 
       115 6592  117 5568  118 3520  121 5056  122 3008  124 1984  143 7712  151 
      7456  155 6944  157 5920  158 3872  167 7328  171 6816  173 5792  174 3744 
       179 6560  181 5536  182 3488  185 5024  186 2976  188 1952  199 7264  203 
      6752  205 5728  206 3680  211 6496  213 5472  214 3424  217 4960  218 2912 
       220 1888  227 6368  229 5344  230 3296  233 4832  234 2784  236 1760  241 
      4576  242 2528  244 1504  248  992  271 7696  279 7440  283 6928  285 5904 
       286 3856  295 7312  299 6800  301 5776  302 3728  307 6544  309 5520  310 
      3472  313 5008  314 2960  316 1936  327 7248  331 6736  333 5712  334 3664 
       339 6480  341 5456  342 3408  345 4944  346 2896  348 1872  355 6352  357 
      5328  358 3280  361 4816  362 2768  364 1744  369 4560  370 2512  372 1488 
       376  976  391 7216  395 6704  397 5680  398 3632  403 6448  405 5424  406 
      3376  409 4912  410 2864  412 1840  419 6320  421 5296  422 3248  425 4784 
       426 2736  428 1712  433 4528  434 2480  436 1456  440  944  451 6256  453 
      5232  454 3184  457 4720  458 2672  460 1648  465 4464  466 2416  468 1392 
       472  880  481 4336  482 2288  484 1264  488  752  527 7688  535 7432  539 
      6920  541 5896  542 3848  551 7304  555 6792  557 5768  558 3720  563 6536 
       565 5512  566 3464  569 5000  570 2952  572 1928  583 7240  587 6728  589 
      5704  590 3656  595 6472  597 5448  598 3400  601 4936  602 2888  604 1864 
       611 6344  613 5320  614 3272  617 4808  618 2760  620 1736  625 4552  626 
      2504  628 1480  632  968  647 7208  651 6696  653 5672  654 3624  659 6440 
       661 5416  662 3368  665 4904  666 2856  668 1832  675 6312  677 5288  678 
      3240  681 4776  682 2728  684 1704  689 4520  690 2472  692 1448  696  936 
       707 6248  709 5224  710 3176  713 4712  714 2664  716 1640  721 4456  722 
      2408  724 1384  728  872  737 4328  738 2280  740 1256  775 7192  779 6680 
       781 5656  782 3608  787 6424  789 5400  790 3352  793 4888  794 2840  796 
      1816  803 6296  805 5272  806 3224  809 4760  810 2712  812 1688  817 4504 
       818 2456  820 1432  824  920  835 6232  837 5208  838 3160  841 4696  842 
      2648  844 1624  849 4440  850 2392  852 1368  865 4312  866 2264  868 1240 
       899 6200  901 5176  902 3128  905 4664  906 2616  908 1592  913 4408  914 
      2360  916 1336  929 4280  930 2232  932 1208  961 4216  962 2168  964 1144 
      1039 7684 1047 7428 1051 6916 1053 5892 1054 3844 1063 7300 1067 6788 1069 
      5764 1070 3716 1075 6532 1077 5508 1078 3460 1081 4996 1082 2948 1084 1924 
      1095 7236 1099 6724 1101 5700 1102 3652 1107 6468 1109 5444 1110 3396 1113 
      4932 1114 2884 1116 1860 1123 6340 1125 5316 1126 3268 1129 4804 1130 2756 
      1132 1732 1137 4548 1138 2500 1140 1476 1159 7204 1163 6692 1165 5668 1166 
      3620 1171 6436 1173 5412 1174 3364 1177 4900 1178 2852 1180 1828 1187 6308 
      1189 5284 1190 3236 1193 4772 1194 2724 1196 1700 1201 4516 1202 2468 1204 
      1444 1219 6244 1221 5220 1222 3172 1225 4708 1226 2660 1228 1636 1233 4452 
      1234 2404 1236 1380 1249 4324 1250 2276 1287 7188 1291 6676 1293 5652 1294 
      3604 1299 6420 1301 5396 1302 3348 1305 4884 1306 2836 1308 1812 1315 6292 
      1317 5268 1318 3220 1321 4756 1322 2708 1324 1684 1329 4500 1330 2452 1332 
      1428 1347 6228 1349 5204 1350 3156 1353 4692 1354 2644 1356 1620 1361 4436 
      1362 2388 1377 4308 1378 2260 1411 6196 1413 5172 1414 3124 1417 4660 1418 
      2612 1420 1588 1425 4404 1426 2356 1441 4276 1442 2228 1473 4212 1474 2164 
      1543 7180 1547 6668 1549 5644 1550 3596 1555 6412 1557 5388 1558 3340 1561 
      4876 1562 2828 1564 1804 1571 6284 1573 5260 1574 3212 1577 4748 1578 2700 
      1580 1676 1585 4492 1586 2444 1603 6220 1605 5196 1606 3148 1609 4684 1610 
      2636 1617 4428 1618 2380 1633 4300 1634 2252 1667 6188 1669 5164 1670 3116 
      1673 4652 1674 2604 1681 4396 1682 2348 1697 4268 1698 2220 1729 4204 1730 
      2156 1795 6172 1797 5148 1798 3100 1801 4636 1802 2588 1809 4380 1810 2332 
      1825 4252 1826 2204 1857 4188 1858 2140 1921 4156 1922 2108 2063 7682 2071 
      7426 2075 6914 2077 5890 2078 3842 2087 7298 2091 6786 2093 5762 2094 3714 
      2099 6530 2101 5506 2102 3458 2105 4994 2106 2946 2119 7234 2123 6722 2125 
      5698 2126 3650 2131 6466 2133 5442 2134 3394 2137 4930 2138 2882 2147 6338 
      2149 5314 2150 3266 2153 4802 2154 2754 2161 4546 2162 2498 2183 7202 2187 
      6690 2189 5666 2190 3618 2195 6434 2197 5410 2198 3362 2201 4898 2202 2850 
      2211 6306 2213 5282 2214 3234 2217 4770 2218 2722 2225 4514 2226 2466 2243 
      6242 2245 5218 2246 3170 2249 4706 2250 2658 2257 4450 2258 2402 2273 4322 
      2311 7186 2315 6674 2317 5650 2318 3602 2323 6418 2325 5394 2326 3346 2329 
      4882 2330 2834 2339 6290 2341 5266 2342 3218 2345 4754 2346 2706 2353 4498 
      2354 2450 2371 6226 2373 5202 2374 3154 2377 4690 2378 2642 2385 4434 2401 
      4306 2435 6194 2437 5170 2438 3122 2441 4658 2442 2610 2449 4402 2465 4274 
      2497 4210 2567 7178 2571 6666 2573 5642 2574 3594 2579 6410 2581 5386 2582 
      3338 2585 4874 2586 2826 2595 6282 2597 5258 2598 3210 2601 4746 2602 2698 
      2609 4490 2627 6218 2629 5194 2630 3146 2633 4682 2641 4426 2657 4298 2691 
      6186 2693 5162 2694 3114 2697 4650 2705 4394 2721 4266 2753 4202 2819 6170 
      2821 5146 2822 3098 2825 4634 2833 4378 2849 4250 2881 4186 2945 4154 3079 
      7174 3083 6662 3085 5638 3086 3590 3091 6406 3093 5382 3094 3334 3097 4870 
      3107 6278 3109 5254 3110 3206 3113 4742 3121 4486 3139 6214 3141 5190 3145 
      4678 3153 4422 3169 4294 3203 6182 3205 5158 3209 4646 3217 4390 3233 4262 
      3265 4198 3331 6166 3333 5142 3337 4630 3345 4374 3361 4246 3393 4182 3457 
      4150 3587 6158 3589 5134 3593 4622 3601 4366 3617 4238 3649 4174 3713 4142 
      3841 4126 4111 7681 4119 7425 4123 6913 4125 5889 4135 7297 4139 6785 4141 
      5761 4147 6529 4149 5505 4153 4993 4167 7233 4171 6721 4173 5697 4179 6465 
      4181 5441 4185 4929 4195 6337 4197 5313 4201 4801 4209 4545 4231 7201 4235 
      6689 4237 5665 4243 6433 4245 5409 4249 4897 4259 6305 4261 5281 4265 4769 
      4273 4513 4291 6241 4293 5217 4297 4705 4305 4449 4359 7185 4363 6673 4365 
      5649 4371 6417 4373 5393 4377 4881 4387 6289 4389 5265 4393 4753 4401 4497 
      4419 6225 4421 5201 4425 4689 4483 6193 4485 5169 4489 4657 4615 7177 4619 
      6665 4621 5641 4627 6409 4629 5385 4633 4873 4643 6281 4645 5257 4649 4745 
      4675 6217 4677 5193 4739 6185 4741 5161 4867 6169 4869 5145 5127 7173 5131 
      6661 5133 5637 5139 6405 5141 5381 5155 6277 5157 5253 5187 6213 5251 6181 
      5379 6165 5635 6157 6151 7171 6155 6659 6163 6403 6179 6275 6211 5189 4681 
      4433 4321 3142 2634 2386 2274 1612 1364 1252  856  744  496 
    ] def

    /tab213 [
         3 6144    5 5120    6 3072    9 4608   10 2560   12 1536   17 4352   18 
      2304   20 1280   24  768   33 4224   34 2176   36 1152   40  640   48  384 
        65 4160   66 2112   68 1088   72  576   80  320   96  192  129 4128  130 
      2080  132 1056  136  544  144  288  257 4112  258 2064  260 1040  264  528 
       513 4104  514 2056  516 1032 1025 4100 1026 2052 2049 4098 4097 2050 1028 
       520  272  160
    ] def

    /chars 10 array def
    0 1 9 {
        /i exch def
        codewords i get dup 1286 le {
            tab513 exch get 
        } {
            tab213 exch 1287 sub get
        } ifelse
        chars i 3 -1 roll put
    } for

    9 -1 0 {
        /i exch def
        2 i exp cvi fcs and 0 ne {
            chars i chars i get 8191 xor put
        } if
    } for

    % Conversion from characters to the OneCode encoding
    /barmap [
        7 2 4 3    1 10 0 0   9 12 2 8   5 5 6 11   8 9 3 1
        0 1 5 12   2 5 1 8    4 4 9 11   6 3 8 10   3 9 7 6
        5 11 1 4   8 5 2 12   9 10 0 2   7 1 6 7    3 6 4 9
        0 3 8 6    6 4 2 7    1 1 9 9    7 10 5 2   4 0 3 8
        6 2 0 4    8 11 1 0   9 8 3 12   2 6 7 7    5 1 4 10
        1 12 6 9   7 3 8 0    5 8 9 7    4 6 2 10   3 4 0 5
        8 4 5 7    7 11 1 9   6 0 9 6    0 6 4 8    2 1 3 2
        5 9 8 12   4 11 6 1   9 5 7 4    3 3 1 2    0 7 2 0
        1 3 4 1    6 10 3 5   8 7 9 4    2 11 5 6   0 8 7 12
        4 2 8 1    5 10 3 0   9 3 0 9    6 5 2 4    7 8 1 7
        5 0 4 5    2 3 0 10   6 12 9 2   3 11 1 6   8 8 7 9
        5 4 0 11   1 5 2 2    9 1 4 12   8 3 6 6    7 0 3 7
        4 7 7 5    0 12 1 11  2 9 9 0    6 8 5 3    3 10 8 2
    ] def

    /bbs 65 array def    
    /bhs 65 array def
    0 1 64 {
        /i exch def
        /dec chars barmap i 4 mul get get 2 barmap i 4 mul 1 add get exp cvi and 0 ne def
        /asc chars barmap i 4 mul 2 add get get 2 barmap i 4 mul 3 add get exp cvi and 0 ne def
        dec not asc not and {
            bbs i 3 height mul 8 div put
            bhs i 2 height mul 8 div put
        } if
        dec not asc and {
            bbs i 3 height mul 8 div put
            bhs i 5 height mul 8 div put        
        } if
        dec asc not and {
            bbs i 0 height mul 8 div put
            bhs i 5 height mul 8 div put        
        } if
        dec asc and {
            bbs i 0 height mul 8 div put
            bhs i 8 height mul 8 div put        
        } if
    } for
    
    % Return the arguments
    <<
    /ren //renlinear
    /bbs bbs
    /bhs bhs
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    /txt txt
    /textxalign (left)
    /textfont /Helvetica
    /textyoffset 1
    /textxoffset -0.3
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/onecode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER onecode--

% --BEGIN ENCODER postnet--
% --REQUIRES preamble raiseerror renlinear--
% --DESC: USPS POSTNET
% --EXAM: 01234
% --EXOP: includetext includecheckintext
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp postnet 0.0 2015050900 65689 65439
%%BeginData:        140 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/postnet {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /includetext false def          % Enable/disable text
    /validatecheck false def
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 0.125 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    /barlen barcode length validatecheck {1 sub} if def

    % Validate the input
    barlen 5 ne barlen 9 ne and barlen 11 ne and {
        /bwipp.postnetBadLength (USPS POSTNET must be 5, 9 or 11 digits excluding check digit) //raiseerror exec
    } if
    barcode {
        dup 48 lt exch 57 gt or {
            /bwipp.postnetBadCharacter (USPS POSTNET must contain only digits) //raiseerror exec
        } if
    } forall

    % Create a string of the available characters
    /barchars (0123456789) def

    /checksum 0 def
    0 1 barlen 1 sub {
        /i exch def
        /checksum checksum barcode i get 48 sub add def
    } for
    /checksum 10 checksum 10 mod sub 10 mod def
    validatecheck {
        barcode barlen get barchars checksum get ne {
            /bwipp.postnetBadCheckDigit (Incorrect USPS POSTNET check digit provided) //raiseerror exec
        } if
        /barcode barcode 0 barlen getinterval def
    } if

    % Create an array containing the character mappings
    /encs
    [ (55222) (22255) (22525) (22552) (25225)
      (25252) (25522) (52225) (52252) (52522)
      (5) (5)
    ] def

    /bhs barlen 5 mul 7 add array def
    /txt barlen 1 add array def

    % Put start character
    /enc encs 10 get def
    /heights enc length array def
    0 1 enc length 1 sub {
        /j exch def
        heights j enc j 1 getinterval cvi height mul 5 div put
    } for
    bhs 0 heights putinterval   % Put encoded digit into sbs

    0 1 barlen 1 sub {
        /i exch def
        /enc encs barcode i get 48 sub get def
        /heights enc length array def
        0 1 enc length 1 sub {
            /j exch def
            heights j enc j 1 getinterval cvi height mul 5 div put
        } for
        bhs i 5 mul 1 add heights putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 5 mul 1 add 3.312 mul textyoffset textfont textsize] put
    } for

    % Put the checksum character
    /enc encs checksum get def
    /heights enc length array def
    0 1 enc length 1 sub {
        /j exch def
        heights j enc j 1 getinterval cvi height mul 5 div put
    } for
    bhs barlen 5 mul 1 add heights putinterval  
    
    includecheckintext {
        txt barlen [barchars checksum 1 getinterval barlen 5 mul 1 add 3.312 mul textyoffset textfont textsize] put
    } {
        txt barlen [( ) barlen 5 mul 1 add 72 mul 25 div textyoffset textfont textsize] put
    } ifelse
    
    % Put end character
    /enc encs 11 get def
    /heights enc length array def
    0 1 enc length 1 sub {
        /j exch def
        heights j enc j 1 getinterval cvi height mul 5 div put
    } for
    bhs barlen 5 mul 6 add heights putinterval  

    % Return the arguments
    <<
    /ren //renlinear
    /bhs bhs
    /bbs [bhs length {0} repeat]
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/postnet dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER postnet--

% --BEGIN ENCODER planet--
% --REQUIRES preamble raiseerror renlinear--
% --DESC: USPS PLANET
% --EXAM: 01234567890
% --EXOP: includetext includecheckintext
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp planet 0.0 2015050900 65565 65215
%%BeginData:        141 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/planet {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /includetext false def          % Enable/disable text
    /validatecheck false def
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 0.125 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def

    /barlen barcode length validatecheck {1 sub} if def

    % Validate the input
    barlen 11 ne barlen 13 ne and {
        /bwipp.planetBadLength (USPS PLANET must be 11 or 13 digits excluding check digit) //raiseerror exec
    } if
    barcode {
        dup 48 lt exch 57 gt or {
            /bwipp.planetBadCharacter (USPS PLANET must contain only digits) //raiseerror exec
        } if
    } forall

    % Create a string of the available characters
    /barchars (0123456789) def

    % Calculate the checksum
    /checksum 0 def
    0 1 barlen 1 sub {
        /i exch def
        /checksum checksum barcode i get 48 sub add def
    } for
    /checksum 10 checksum 10 mod sub 10 mod def
    validatecheck {
        barcode barlen get barchars checksum get ne {
            /bwipp.planetBadCheckDigit (Incorrect USPS PLANET check digit provided) //raiseerror exec
        } if
        /barcode barcode 0 barlen getinterval def
    } if

    % Create an array containing the character mappings
    /encs
    [ (22555) (55522) (55252) (55225) (52552)
      (52525) (52255) (25552) (25525) (25255)
      (5) (5)
    ] def

    /bhs barlen 5 mul 7 add array def
    /txt barlen 1 add array def

    % Put start character
    /enc encs 10 get def
    /heights enc length array def
    0 1 enc length 1 sub {
        /j exch def
        heights j enc j 1 getinterval cvi height mul 5 div put
    } for
    bhs 0 heights putinterval   % Put encoded digit into sbs

    0 1 barlen 1 sub {
        /i exch def
        /enc encs barcode i get 48 sub get def
        /heights enc length array def
        0 1 enc length 1 sub {
            /j exch def
            heights j enc j 1 getinterval cvi height mul 5 div put
        } for
        bhs i 5 mul 1 add heights putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 5 mul 1 add 3.312 mul textyoffset textfont textsize] put
    } for

    % Put the checksum character
    /enc encs checksum get def
    /heights enc length array def
    0 1 enc length 1 sub {
        /j exch def
        heights j enc j 1 getinterval cvi height mul 5 div put
    } for
    bhs barlen 5 mul 1 add heights putinterval  
    
    includecheckintext {
        txt barlen [barchars checksum 1 getinterval barlen 5 mul 1 add 3.312 mul textyoffset textfont textsize] put
    } {
        txt barlen [( ) barlen 5 mul 1 add 72 mul 25 div textyoffset textfont textsize] put
    } ifelse
    
    % Put end character
    /enc encs 11 get def
    /heights enc length array def
    0 1 enc length 1 sub {
        /j exch def
        heights j enc j 1 getinterval cvi height mul 5 div put
    } for
    bhs barlen 5 mul 6 add heights putinterval  

    % Return the arguments
    <<
    /ren //renlinear
    /bhs bhs
    /bbs [bhs length {0} repeat]
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/planet dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER planet--

% --BEGIN ENCODER royalmail--
% --REQUIRES preamble raiseerror renlinear--
% --DESC: Royal Mail 4 State Customer Code
% --EXAM: LE28HS9Z
% --EXOP: includetext barcolor=FF0000
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp royalmail 0.0 2015050900 66136 65853
%%BeginData:        145 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/royalmail {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /includetext false def          % Enable/disable text
    /validatecheck false def
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 0.175 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def

    % Create a string of the available characters
    /barchars (ZUVWXY501234B6789AHCDEFGNIJKLMTOPQRS) def
    /charvals 36 dict def
    0 1 35 {charvals exch dup barchars exch 1 getinterval exch put} for

    % Validate the input
    0 1 barcode length 1 sub {
        barcode exch 1 getinterval charvals exch known not {
            /bwipp.royalmailBadCharacter (RM4SCC must contain only capital letters and digits) //raiseerror exec
        } if
    } for

    /barlen barcode length validatecheck {1 sub} if def

    /checksumrow 0 def
    /checksumcol 0 def
    0 1 barlen 1 sub {
        /i exch def
        /indx charvals barcode i 1 getinterval get def
        /checksumrow checksumrow indx 6 idiv add def
        /checksumcol checksumcol indx 6 mod add def 
    } for
    /checksum checksumrow 6 mod 6 mul checksumcol 6 mod add def
    validatecheck {
        barcode barlen get barchars checksum get ne {
            /bwipp.royalmailBadCheckDigit (Incorrect RM4SCC check digit provided) //raiseerror exec
        } if
        /barcode barcode 0 barlen getinterval def
    } if

    % Create an array containing the character mappings
    /encs
    [ (3300) (2211) (2301) (2310) (3201) (3210) 
      (1122) (0033) (0123) (0132) (1023) (1032) 
      (1302) (0213) (0303) (0312) (1203) (1212) 
      (1320) (0231) (0321) (0330) (1221) (1230) 
      (3102) (2013) (2103) (2112) (3003) (3012) 
      (3120) (2031) (2121) (2130) (3021) (3030) 
      (2) (3)
    ] def

    /encstr barlen 4 mul 6 add string def
    /txt barlen 1 add array def

    % Put start character
    encstr 0 encs 36 get putinterval
    
    0 1 barlen 1 sub {
        /i exch def
        /indx charvals barcode i 1 getinterval get def
        encstr i 4 mul 1 add encs indx get putinterval
        txt i [barcode i 1 getinterval i 4 mul 1 add 3.312 mul textyoffset textfont textsize] put
    } for

    % Put the checksum character
    encstr barlen 4 mul 1 add encs checksum get putinterval
    includecheckintext {
        txt barlen [barchars checksum 1 getinterval barlen 4 mul 1 add 3.312 mul textyoffset textfont textsize] put
    } {
        txt barlen [( ) barlen 4 mul 1 add 3.312 mul textyoffset textfont textsize] put
    } ifelse
    
    % Put end character
    encstr barlen 4 mul 5 add encs 37 get putinterval  

    /bbs encstr length array def    
    /bhs encstr length array def
    0 1 encstr length 1 sub {
        /i exch def
        /enc encstr i 1 getinterval def
        enc (0) eq {
            bbs i 3 height mul 8 div put
            bhs i 2 height mul 8 div put
        } if
        enc (1) eq {
            bbs i 0 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (2) eq {
            bbs i 3 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (3) eq {
            bbs i 0 height mul 8 div put
            bhs i 8 height mul 8 div put
        } if
    } for
    
    % Return the arguments
    <<
    /ren //renlinear
    /bbs bbs
    /bhs bhs
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/royalmail dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER royalmail--

% --BEGIN ENCODER auspost--
% --REQUIRES preamble raiseerror renlinear--
% --DESC: AusPost 4 State Customer Code
% --EXAM: 5956439111ABA 9
% --EXOP: includetext custinfoenc=character
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp auspost 0.0 2015050900 75628 75331
%%BeginData:        202 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/auspost {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /includetext false def         % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 0.175 def
    /custinfoenc (character) def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def

    % Create an array containing the character mappings
    /encs
    [ (000) (001) (002) (010) (011) (012) (020) (021)
      (022) (100) (101) (102) (110) (111) (112) (120)
      (121) (122) (200) (201) (202) (210) (211) (212)
      (220) (221) (222) (300) (301) (302) (310) (311)
      (312) (320) (321) (322) (023) (030) (031) (032)
      (033) (103) (113) (123) (130) (131) (132) (133)
      (203) (213) (223) (230) (231) (232) (233) (303)
      (313) (323) (330) (331) (332) (333) (003) (013)
      (00) (01) (02) (10) (11) (12) (20) (21) (22) (30)
      (13) (3)
    ] def

    % Create a string of the available characters
    /barchars (ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz #) def
    
    /barlen barcode length def
    barcode 0 2 getinterval (11) eq {37} if
    barcode 0 2 getinterval (45) eq {37} if
    barcode 0 2 getinterval (59) eq {52} if
    barcode 0 2 getinterval (62) eq {67} if
    /encstr exch string def
    /txt barlen 2 sub array def

    % Put start character
    encstr 0 encs 74 get putinterval

    % Encode the FCC
    0 1 1 {
        /i exch def       
        encs barcode i 1 getinterval cvi 64 add get
        encstr i 2 mul 2 add 3 2 roll putinterval
    } for
    
    % Encode the DPID
    2 1 9 {
        /i exch def       
        encs barcode i 1 getinterval cvi 64 add get
        encstr i 2 mul 2 add 3 2 roll putinterval
        txt i 2 sub [barcode i 1 getinterval i 2 sub 2 mul 6 add 3.312 mul textyoffset textfont textsize] put
    } for
    
    % Encode the customer information   
    custinfoenc (numeric) eq {
        0 1 barlen 11 sub {
            /i exch def
            encs barcode i 10 add 1 getinterval cvi 64 add get
            encstr i 2 mul 22 add 3 2 roll putinterval
            txt i 8 add [barcode i 10 add 1 getinterval i 2 mul 22 add 3.312 mul textyoffset textfont textsize] put
        } for        
        /ciflen barlen 10 sub 2 mul def
    } {
        0 1 barlen 11 sub {
            /i exch def           
            barcode i 10 add 1 getinterval barchars exch search
            pop                                
            length /indx exch def           
            pop pop                            
            /enc encs indx get def          
            encstr i 3 mul 22 add enc putinterval
            txt i 8 add [barcode i 10 add 1 getinterval i 3 mul 22 add 3.312 mul textyoffset textfont textsize] put
        } for        
        /ciflen barlen 10 sub 3 mul def
    } ifelse

    % Add any filler characters
    22 ciflen add 1 encstr length 14 sub {        
        encstr exch encs 75 get putinterval
    } for
    
    % Create the 64x64 Reed-Solomon table
    /rstable 64 64 mul array def
    rstable 0 [ 64 {0} repeat ] putinterval
    rstable 64 [ 0 1 63 {} for ] putinterval
    /prev 1 def
    64 {       
        /next prev 1 bitshift def
        next 64 and 0 ne {
            /next next 67 xor def
        } if        
        0 1 63 {
            /j exch def
            /nextcell {rstable 64 next mul j add} def
            nextcell rstable 64 prev mul j add get 1 bitshift put
            nextcell get 64 and 0 ne {
                nextcell nextcell get 67 xor put
            } if
        } for
        /prev next def
    } repeat
    
    % Calculate the Reed-Solomon codes for triples
    /rscodes encstr length 16 sub 3 idiv 4 add array def
    rscodes 0 [ 4 {0} repeat ] putinterval
    2 3 encstr length 16 sub {
        /i exch def
        rscodes rscodes length i 2 sub 3 idiv sub 1 sub
        encstr i 1 getinterval cvi 16 mul
        encstr i 1 add 1 getinterval cvi 4 mul add
        encstr i 2 add 1 getinterval cvi add        
        put
    } for    
    rscodes length 5 sub -1 0 {
       /i exch def
       0 1 4 {
           /j exch def
           rscodes i j add rscodes i j add get
           rstable 64 [48 17 29 30 1] j get mul rscodes i 4 add get add get
           xor put
       } for
    } for
    /checkcode (000000000000) 12 string copy def
    0 1 3 {
        /i exch def
        /enc rscodes 3 i sub get 4 3 string cvrs def
        checkcode i 3 mul 3 enc length sub add enc putinterval
    } for
    
    % Put checkcode and end characters
    encstr encstr length 14 sub checkcode putinterval
    encstr encstr length 2 sub encs 74 get putinterval 

    /bbs encstr length array def    
    /bhs encstr length array def
    0 1 encstr length 1 sub {
        /i exch def
        /enc encstr i 1 getinterval def
        enc (0) eq {
            bbs i 0 height mul 8 div put
            bhs i 8 height mul 8 div put
        } if
        enc (1) eq {
            bbs i 3 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (2) eq {
            bbs i 0 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (3) eq {
            bbs i 3 height mul 8 div put
            bhs i 2 height mul 8 div put
        } if
    } for   
    
    % Return the arguments
    <<
    /ren //renlinear
    /bbs bbs
    /bhs bhs
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/auspost dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER auspost--

% --BEGIN ENCODER kix--
% --REQUIRES preamble raiseerror renlinear--
% --DESC: Royal Dutch TPG Post KIX
% --EXAM: 1231FZ13XHS
% --EXOP: includetext
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp kix 0.0 2015050900 61942 61672
%%BeginData:        111 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/kix {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /includetext false def          % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 0.175 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (0033) (0123) (0132) (1023) (1032) (1122)
      (0213) (0303) (0312) (1203) (1212) (1302) 
      (0231) (0321) (0330) (1221) (1230) (1320)
      (2013) (2103) (2112) (3003) (3012) (3102)
      (2031) (2121) (2130) (3021) (3030) (3120) 
      (2211) (2301) (2310) (3201) (3210) (3300) 
    ] def

    % Create a string of the available characters
    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ) def
    /charvals 36 dict def
    0 1 35 {charvals exch dup barchars exch 1 getinterval exch put} for

    % Validate the input
    0 1 barcode length 1 sub {
        barcode exch 1 getinterval charvals exch known not {
            /bwipp.kixBadCharacter (KIX must contain only capital letters and digits) //raiseerror exec
        } if
    } for

    /barlen barcode length def
    /encstr barlen 4 mul string def
    /txt barlen array def
    
    0 1 barlen 1 sub {
        /i exch def
        /indx charvals barcode i 1 getinterval get def
        encstr i 4 mul encs indx get putinterval
        txt i [barcode i 1 getinterval i 4 mul 3.312 mul textyoffset textfont textsize] put
    } for

    /bbs encstr length array def    
    /bhs encstr length array def
    0 1 encstr length 1 sub {
        /i exch def
        /enc encstr i 1 getinterval def
        enc (0) eq {
            bbs i 3 height mul 8 div put
            bhs i 2 height mul 8 div put
        } if
        enc (1) eq {
            bbs i 0 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (2) eq {
            bbs i 3 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (3) eq {
            bbs i 0 height mul 8 div put
            bhs i 8 height mul 8 div put
        } if
    } for
    
    % Return the arguments
    <<
    /ren //renlinear
    /bbs bbs
    /bhs bhs
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/kix dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER kix--

% --BEGIN ENCODER japanpost--
% --REQUIRES preamble raiseerror renlinear--
% --DESC: Japan Post 4 State Customer Code
% --EXAM: 6540123789-A-K-Z
% --EXOP: includetext includecheckintext
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp japanpost 0.0 2015050900 66345 66129
%%BeginData:        162 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/japanpost {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /includetext false def          % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 0.175 def
  
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    % 0123456789- C1C2C3C4C5C6C7C8 ST EN
    /encs
    [ (300) (330) (312) (132) (321) (303) (123) (231) (213) (033) (030)
      (120) (102) (210) (012) (201) (021) (003) (333) 
      (31) (13)
    ] def

    % Create a string of the available characters
    /barchars (0123456789-ABCDEFGHIJKLMNOPQRSTUVWXYZ) def
    /barlen barcode length def
    
    /encstr 20 1 add 3 mul 4 add string def
    /digits 20 array def
    /txt barlen 1 add array def

    % Put start character
    encstr 0 encs 19 get putinterval

    /checksum 0 def
    /j 0 def /i 0 def
    0 1 barlen 1 sub {
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                                  % Discard true leaving pre
        length /indx exch def                % indx is the length of pre
        pop pop                              % Discard match and post
        indx 11 ge indx 37 lt and {          % Insert escape
            j 18 gt {exit} if                % Should fit in 20 chars
                                             % 11-20: C1 (11)
                                             % 21-30: C2 (12)
                                             % 31-36: C3 (13)
            /digit indx 1 sub 10 idiv 10 add def
            encstr j 3 mul 2 add encs digit get putinterval
            /checksum checksum digit add def
            digits j digit put
            /j j 1 add def
        } if
        j 19 gt {exit} if                    % Should fit in 20 chars
        /digit 0 def
        indx 37 eq {
            /digit 14 def                    % space (C14)
        } if
        indx 11 ge indx 37 lt and {
            /digit indx 1 sub 10 mod def
        } if
        indx 11 lt {
            /digit indx def
        } if
        encstr j 3 mul 2 add encs digit get putinterval % space
        /checksum checksum digit add def
        digits j digit put
        txt i [barcode i 1 getinterval j 3 mul 2 add 3.312 mul textyoffset textfont textsize] put
        /j j 1 add def
    } for

    % Fill spaces (c14) at right end
    j 1 20 1 sub {
        /k exch def
        encstr k 3 mul 2 add encs 14 get putinterval
        /checksum checksum 14 add def
        digits k 14 put
    } for

    % Put the checksum character
    /checksum checksum 19 mod 19 exch sub def
    encstr 2 20 3 mul add encs checksum get putinterval

    % Put end character
    encstr 2 21 3 mul add encs 20 get putinterval
    /checkdigit ( ) def
    includecheckintext {
        /checkdigit barchars checksum 1 getinterval def
    } if
    txt i 1 add [ checkdigit 20 3 mul 2 add 3.312 mul textyoffset textfont textsize] put

    % Put end character
    encstr 20 1 add 3 mul 2 add encs 20 get putinterval

    /bbs 21 3 mul 4 add array def
    /bhs bbs length array def
    0 1 bbs length 1 sub {
        /i exch def
        /enc encstr i 1 getinterval def
        /bunit 0 def
        /hunit 0 def
        enc (0) eq {
            /bunit 3 def
            /hunit 2 def
        } if
        enc (1) eq {
            /bunit 0 def
            /hunit 5 def
        } if
        enc (2) eq {
            /bunit 3 def
            /hunit 5 def
        } if
        enc (3) eq {
            /bunit 0 def
            /hunit 8 def
        } if
        bbs i bunit height mul 8 div put
        bhs i hunit height mul 8 div put
    } for

    % Return the arguments
    <<
    /ren //renlinear
    /bbs bbs
    /bhs bhs
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/japanpost dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER japanpost--

% --BEGIN ENCODER msi--
% --REQUIRES preamble raiseerror renlinear--
% --DESC: MSI Modified Plessey
% --EXAM: 0123456789
% --EXOP: includetext includecheck includecheckintext
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp msi 0.0 2015050900 71052 70834
%%BeginData:        139 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/msi {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /includecheck false def  % Enable/disable checkdigit
    /includetext false def   % Enable/disable text
    /includecheckintext false def
    /checktype (mod10) def
    /badmod11 false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
    
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (12121212) (12121221) (12122112) (12122121) (12211212)
      (12211221) (12212112) (12212121) (21121212) (21121221)
      (21) (121)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    /barlen barcode length def     % Length of the code
    /txtlen barlen def

    /mod10 {
        /code exch def
        0 0 code {48 sub exch 10 mul add exch} forall pop 2 mul  
        0 {1 index 10 mod add exch 10 idiv dup 0 eq {pop exit} if exch} loop
        0 0 code {48 sub add exch} forall exch pop add
        10 mod 10 exch sub 10 mod
        code length 1 add string dup 0 code putinterval dup code length 4 -1 roll 48 add put
    } bind def

    /mod11 {
        /code exch def
        code length 1 sub code {48 sub exch dup 1 sub exch 6 mod 2 add exch} forall pop
        0 code length {3 1 roll mul add} repeat 
        11 mod 11 exch sub 11 mod
        dup 10 eq badmod11 and {
            pop code length 2 add string dup 0 code putinterval dup code length (10) putinterval
        } {
            code length 1 add string dup 0 code putinterval dup code length 4 -1 roll 48 add put
        } ifelse
    } bind def

    /ncrmod11 {
        /code exch def
        code length 1 sub code {48 sub exch dup 1 sub exch 8 mod 2 add exch} forall pop
        0 code length {3 1 roll mul add} repeat 
        11 mod 11 exch sub 11 mod
        dup 10 eq badmod11 and {
            pop code length 2 add string dup 0 code putinterval dup code length (10) putinterval
        } {
            code length 1 add string dup 0 code putinterval dup code length 4 -1 roll 48 add put
        } ifelse
    } bind def

    % Calculate checksum
    includecheck {
        checktype (mod10) eq      {barcode mod10} if
        checktype (mod1010) eq    {barcode mod10 mod10} if
        checktype (mod11) eq      {barcode mod11} if
        checktype (ncrmod11) eq   {barcode ncrmod11} if
        checktype (mod1110) eq    {barcode mod11 mod10} if
        checktype (ncrmod1110) eq {barcode ncrmod11 mod10} if
        /barcode exch def
        /barlen barcode length def
        includecheckintext {/txtlen barlen def} if
    } if

    /sbs barlen 8 mul 5 add string def
    /txt barlen array def

    % Put start character
    sbs 0 encs 10 get putinterval

    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 8 mul 2 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 12 mul 3 add textyoffset textfont textsize] put
    } for

    % Put the end character
    sbs barlen 8 mul 2 add encs 11 get putinterval

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt 0 txtlen getinterval
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/msi dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER msi--

% --BEGIN ENCODER plessey--
% --REQUIRES preamble raiseerror renlinear--
% --DESC: Plessey UK
% --EXAM: 01234ABCD
% --EXOP: includetext includecheckintext
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp plessey 0.0 2015050900 67754 67457
%%BeginData:        146 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/plessey {

    20 dict begin                  % Confine variables to local scope

    /options exch def        % We are given an option string
    /barcode exch def        % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /validatecheck false def
    /includecheckintext false def
    /unidirectional false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create a string of the available characters
    /barchars (0123456789ABCDEF) def
    /charvals 16 dict def
    0 1 15 {charvals exch dup barchars exch 1 getinterval exch put} for

    % Validate the input
    0 1 barcode length 1 sub {
        barcode exch 1 getinterval charvals exch known not {
            /bwipp.plesseyBadCharacter (Plessey must contain only digits and letters A B C D E F) //raiseerror exec
        } if
    } for

    /barlen barcode length validatecheck {2 sub} if def

    % Calculate the checksums
    /checkbits barlen 4 mul 8 add array def
    checkbits barlen 4 mul [ 0 0 0 0 0 0 0 0 ] putinterval
    0 1 barlen 1 sub {
        /i exch def
        /indx charvals barcode i 1 getinterval get def
        checkbits i 4 mul [
                indx 1 and
                indx -1 bitshift 1 and
                indx -2 bitshift 1 and
                indx -3 bitshift
        ] putinterval
    } for
    /checksalt [ 1 1 1 1 0 1 0 0 1 ] def
    0 1 barlen 4 mul 1 sub {
        /i exch def
        checkbits i get 1 eq {
            0 1 8 {
                /j exch def
                checkbits i j add checkbits i j add get checksalt j get xor put
            } for
        } if
    } for
    /checkval 0 def
    0 1 7 {
        /i exch def
        /checkval checkval 2 i exp cvi checkbits barlen 4 mul i add get mul add def
    } for
    /checksum1 checkval 15 and def
    /checksum2 checkval -4 bitshift def
    validatecheck {
        barcode barlen get barchars checksum1 get ne
        barcode barlen 1 add get barchars checksum2 get ne or {
            /bwipp.plesseyBadCheckDigits (Incorrect Plessey check digits provided) //raiseerror exec
        } if
        /barcode barcode 0 barlen getinterval def
    } if

    % Create an array containing the character mappings
    /encs
    [ (14141414) (32141414) (14321414) (32321414)
      (14143214) (32143214) (14323214) (32323214)
      (14141432) (32141432) (14321432) (32321432)
      (14143232) (32143232) (14323232) (32323232)
      (32321432) (541412323) (323)
    ] def

    /sbs barlen 8 mul unidirectional {27} {33} ifelse add string def
    /txt barlen 2 add array def

    % Put start character
    sbs 0 encs 16 get putinterval

    0 1 barlen 1 sub {
        /i exch def
        /indx charvals barcode i 1 getinterval get def
        sbs i 8 mul 8 add encs indx get putinterval
        txt i [barcode i 1 getinterval i 20 mul 20 add textyoffset textfont textsize] put
    } for

    % Put the checksum characters
    sbs barlen 8 mul 8 add encs checksum1 get putinterval
    sbs barlen 8 mul 16 add encs checksum2 get putinterval
    includecheckintext {
        txt barlen [barchars checksum1 1 getinterval barlen 20 mul 20 add textyoffset textfont textsize] put
        txt barlen 1 add [barchars checksum2 1 getinterval barlen 1 add 20 mul 20 add textyoffset textfont textsize] put
    } {
        txt barlen [( ) barlen 20 mul 20 add textyoffset textfont textsize] put
        txt barlen 1 add [( ) barlen 1 add 20 mul 20 add textyoffset textfont textsize] put
    } ifelse

    % Put end character
    sbs barlen 8 mul 24 add encs unidirectional {18} {17} ifelse get putinterval

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/plessey dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER plessey--

% --BEGIN ENCODER telepen--
% --REQUIRES preamble raiseerror renlinear--
% --DESC: Telepen
% --EXAM: ABCDEF
% --EXOP: includetext
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp telepen 0.0 2015050900 68624 68368
%%BeginData:        173 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/telepen {

    20 dict begin                  % Confine variables to local scope

    /options exch def        % We are given an option string
    /barcode exch def        % We are given a barcode string

    /numeric false def
    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    % Create an array containing the character mappings
    /encs
    [ (31313131)        (1131313111)     (33313111)       (1111313131)
      (3111313111)      (11333131)       (13133131)       (111111313111)
      (31333111)        (1131113131)     (33113131)       (1111333111)
      (3111113131)      (1113133111)     (1311133111)     (111111113131)
      (3131113111)      (11313331)       (333331)         (111131113111)
      (31113331)        (1133113111)     (1313113111)     (1111113331)
      (31131331)        (113111113111)   (3311113111)     (1111131331)
      (311111113111)    (1113111331)     (1311111331)     (11111111113111)
      (31313311)        (1131311131)     (33311131)       (1111313311)
      (3111311131)      (11333311)       (13133311)       (111111311131)
      (31331131)        (1131113311)     (33113311)       (1111331131)
      (3111113311)      (1113131131)     (1311131131)     (111111113311)
      (3131111131)      (1131131311)     (33131311)       (111131111131)
      (3111131311)      (1133111131)     (1313111131)     (111111131311)
      (3113111311)      (113111111131)   (3311111131)     (111113111311)
      (311111111131)    (111311111311)   (131111111311)   (11111111111131)
      (3131311111)      (11313133)       (333133)         (111131311111)
      (31113133)        (1133311111)     (1313311111)     (1111113133)
      (313333)          (113111311111)   (3311311111)     (11113333)
      (311111311111)    (11131333)       (13111333)       (11111111311111)
      (31311133)        (1131331111)     (33331111)       (1111311133)
      (3111331111)      (11331133)       (13131133)       (111111331111)
      (3113131111)      (1131111133)     (33111133)       (111113131111)
      (3111111133)      (111311131111)   (131111131111)   (111111111133)
      (31311313)        (113131111111)   (3331111111)     (1111311313)
      (311131111111)    (11331313)       (13131313)       (11111131111111)
      (3133111111)      (1131111313)     (33111313)       (111133111111)
      (3111111313)      (111313111111)   (131113111111)   (111111111313)
      (313111111111)    (1131131113)     (33131113)       (11113111111111)
      (3111131113)      (113311111111)   (131311111111)   (111111131113)
      (3113111113)      (11311111111111) (331111111111)   (111113111113)
      (31111111111111)  (111311111113)   (131111111113)   (1111111111111111)
    ] def

    /barlen barcode length def    % Length of the code
    /sbs barlen 16 mul 48 add string def
    /txt barlen array def

    % Put the start character ASCII 95
    /enc encs 95 get def
    sbs 0 enc putinterval
    /l enc length def

    /checksum 0 def
    /i 0 def /j 0 def
    { % loop
        i barlen eq {exit} if
        numeric {  % numeric mode: 00-99 & 0X-9X
            barcode i get 16 gt { 
                /np barcode i 2 getinterval def
                np 1 1 getinterval (X) eq {  % X in even position amongst digits
                    /indx np 0 1 getinterval cvi 17 add def
                } {
                    /indx np cvi 27 add def
                } ifelse
                txt j [np j 16 mul 16 add textyoffset textfont textsize] put
                /i i 2 add def
            } {
                /indx barcode i get def
                txt j [( ) j 16 mul 16 add textyoffset textfont textsize] put
                /i i 1 add def
            } ifelse
        } {  % ASCII mode
            /indx barcode i get def
            indx 32 ge indx 126 le and {
                txt j [barcode i 1 getinterval j 16 mul 16 add textyoffset textfont textsize] put
            } {
                txt j [( ) j 16 mul 16 add textyoffset textfont textsize] put
            } ifelse
            /i i 1 add def
        } ifelse
        /checksum checksum indx add def
        /enc encs indx get def
        sbs l enc putinterval          % Put encoded digit into sbs
        /l l enc length add def
        /j j 1 add def
    } loop

    % Put the checksum character
    /checksum 127 checksum 127 mod sub 127 mod def
    /enc encs checksum get def
    sbs l enc putinterval
    /l l enc length add def

    % Put the end character ASCII 122
    /enc encs 122 get def
    sbs l enc putinterval
    /l l enc length add def

    % Shrink sbs and txt to fit exactly
    /sbs sbs 0 l getinterval def
    /txt txt 0 j getinterval def

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/telepen dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER telepen--

% --BEGIN ENCODER telepennumeric--
% --REQUIRES preamble raiseerror renlinear telepen--
% --DESC: Telepen Numeric
% --EXAM: 01234567
% --EXOP: includetext
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp telepennumeric 0.0 2015050900 57870 57594
%%BeginData:         55 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /telepen dup /uk.co.terryburton.bwipp findresource put
begin
/telepennumeric {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 1 def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def 

    % Get the result of encoding with code2of5 with version=industrial
    options (dontdraw) true put
    options (numeric) true put

    /args barcode options //telepen exec def

    args (opt) options put
    args

    dontdraw not //renlinear if
 
    end

} bind def
/telepennumeric dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER telepennumeric--

% --BEGIN ENCODER posicode--
% --REQUIRES preamble raiseerror renlinear--
% --DESC: PosiCode
% --EXAM: ABC123
% --EXOP: version=b inkspread=-0.5 parsefnc includetext
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp posicode 0.0 2015050900 101857 104871
%%BeginData:        389 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/posicode {

    20 dict begin                  % Confine variables to local scope

    /options exch def        % We are given an option string
    /barcode exch def        % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 1 def
    /encoding (auto) def
    /version (a) def
    /checkoffset 0 def
    /raw false def
    /parse false def
    /parsefnc false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /encoding encoding cvlit def
    /version version cvlit def
    /checkoffset checkoffset cvi def
    /height height cvr def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    % Special function characters
    /la0  -1 def  /la1  -2 def  /la2  -3 def 
    /sf0  -4 def  /sf1  -5 def  /sf2  -6 def 
    /fn1  -7 def  /fn2  -8 def  /fn3  -9 def  /fn4 -10 def

    % Character maps for each state
    <<
    /normal
      [
          %  0    1    2        0    1    2        0    1    2
          [ (0)  (^)  (') ]  [ (1)  (;)   27 ]  [ (2)  (<)   28 ]  % 0-2 
          [ (3)  (=)   29 ]  [ (4)  (>)   30 ]  [ (5)  (?)   31 ]  % 3-5
          [ (6)  (@)  (!) ]  [ (7)  ([)  (") ]  [ (8)   92  (#) ]  % 6-8
          [ (9)  (])  (&) ]  [ (A)  (a)    1 ]  [ (B)  (b)    2 ]  % 9-11
          [ (C)  (c)    3 ]  [ (D)  (d)    4 ]  [ (E)  (e)    5 ]  % 12-14
          [ (F)  (f)    6 ]  [ (G)  (g)    7 ]  [ (H)  (h)    8 ]  % 15-17
          [ (I)  (i)    9 ]  [ (J)  (j)   10 ]  [ (K)  (k)   11 ]  % 18-20
          [ (L)  (l)   12 ]  [ (M)  (m)   13 ]  [ (N)  (n)   14 ]  % 21-23
          [ (O)  (o)   15 ]  [ (P)  (p)   16 ]  [ (Q)  (q)   17 ]  % 24-26
          [ (R)  (r)   18 ]  [ (S)  (s)   19 ]  [ (T)  (t)   20 ]  % 27-29
          [ (U)  (u)   21 ]  [ (V)  (v)   22 ]  [ (W)  (w)   23 ]  % 30-32
          [ (X)  (x)   24 ]  [ (Y)  (y)   25 ]  [ (Z)  (z)   26 ]  % 33-35
          [ (-)  (_)   40 ]  [ (.)  (`)   41 ]  [ ( )  127    0 ]  % 36-38
          [ ($)  ({)  (*) ]  [ (/)  (|)  (,) ]  [ (+)  (})  (:) ]  % 39-41
          [ (%)  (~)  fn1 ]  [ la1  la0  fn2 ]  [ sf1  sf0  fn3 ]  % 42-44
          [ sf2  sf2  fn4 ]                                        % 45
      ]
    /limited
      [
          [ (0)  -98  -98 ]  [ (1)  -98   -98 ]  [ (2)  -98  -98 ]  % 0-2
          [ (3)  -98  -98 ]  [ (4)  -98   -98 ]  [ (5)  -98  -98 ]  % 3-5
          [ (6)  -98  -98 ]  [ (7)  -98   -98 ]  [ (8)  -98  -98 ]  % 6-8
          [ (9)  -98  -98 ]  [ (A)  -98   -98 ]  [ (B)  -98  -98 ]  % 9-11
          [ (C)  -98  -98 ]  [ (D)  -98   -98 ]  [ (E)  -98  -98 ]  % 12-14
          [ (F)  -98  -98 ]  [ (G)  -98   -98 ]  [ (H)  -98  -98 ]  % 15-17
          [ (I)  -98  -98 ]  [ (J)  -98   -98 ]  [ (K)  -98  -98 ]  % 18-20
          [ (L)  -98  -98 ]  [ (M)  -98   -98 ]  [ (N)  -98  -98 ]  % 21-23
          [ (O)  -98  -98 ]  [ (P)  -98   -98 ]  [ (Q)  -98  -98 ]  % 24-26
          [ (R)  -98  -98 ]  [ (S)  -98   -98 ]  [ (T)  -98  -98 ]  % 27-29
          [ (U)  -98  -98 ]  [ (V)  -98   -98 ]  [ (W)  -98  -98 ]  % 30-32
          [ (X)  -98  -98 ]  [ (Y)  -98   -98 ]  [ (Z)  -98  -98 ]  % 33-35
          [ (-)  -98  -98 ]  [ (.)  -98   -98 ]                     % 36-37
      ]
    >> 
    version (a) eq version (b) eq or {/normal} {/limited} ifelse get 
    /charmaps exch def

    % Invert charmaps to give character to value maps for each state
    /charvals [
        charmaps length dict charmaps length dict charmaps length dict
    ] def
    0 1 charmaps length 1 sub {
        /i exch def
        /encs charmaps i get def
        0 1 2 {
            /j exch def
            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required
            charvals j get exch i put 
        } for
    } for
    /set0 charvals 0 get def
    /set1 charvals 1 get def
    /set2 charvals 2 get def

    raw {/encoding (raw) def} if

    encoding (raw) eq {
        /cws barlen array def
        /i 0 def /j 0 def
        { % loop
            i barlen eq {exit} if
            /cw barcode i 1 add 3 getinterval cvi def
            cws j cw put
            /i i 4 add def
            /j j 1 add def
        } loop
        /cws cws 0 j getinterval def
        /text () def
    } if

    encoding (auto) eq { 

        /fncvals <<
            (FNC1) fn1
            (FNC2) fn2
            (FNC3) fn3
            (FNC4) fn4
        >> def

        % Convert input into bytes accounting for FNC characters 
        /msg barlen array def
        /text barlen string def
        /i 0 def /j 0 def {
            i barlen eq {exit} if
            /char barcode i get def
            text j char put
            parsefnc char 94 eq and i barlen 4 sub lt and {
                barcode i 1 add get 94 ne {
                    /char fncvals barcode i 1 add 4 getinterval get def
                    text j ( ) putinterval
                    /i i 4 add def
                } {
                    /i i 1 add def
                } ifelse
            } if
            msg j char put
            /i i 1 add def
            /j j 1 add def
        } loop
        /msg msg 0 j getinterval def
        /msglen msg length def
        /text text 0 j getinterval def

        % Convert the input message to codewords
        /enc {
            exch get cws exch j exch put
            /j j 1 add def
        } bind def

        /cws barcode length 2 mul array def
        /i 0 def /j 0 def /cset (set0) def
        {
            i msglen eq {exit} if
       
            {  % common exit

                % Read next two characters
                /char1 msg i get def
                /char2 i 1 add msglen lt {msg i 1 add get} {-99} ifelse def

                % If current mode is sufficient then directly encode
                cset load char1 known { 
                    char1 cset load enc
                    /i i 1 add def
                    exit
                } if

                % If char1 is in set2 then shift encode
                set2 char1 known {
                    sf2 cset load enc
                    char1 set2 enc
                    /i i 1 add def
                    exit
                } if 

                % If char2 is also not in this set then latch else shift encode
                cset load char2 known not {
                    cset (set0) eq {
                       la1 cset load enc
                       /cset (set1) def
                    } {
                       la0 cset load enc
                       /cset (set0) def
                    } ifelse
                    exit
                } { 
                    cset (set0) eq {
                        sf1 cset load enc
                        char1 set1 enc
                    } {
                        sf0 cset load enc
                        char1 set0 enc
                    } ifelse 
                    /i i 1 add def
                    exit
                } ifelse

                exit
            } loop
        
        } loop
        /cws cws 0 j getinterval def
    } if  % auto encoding

    % Create an array containing the character mappings
    <<   % ";"=11, "<"=12
    /a
        [ (141112) (131212) (121312) (111412) (131113)
          (121213) (111313) (121114) (111214) (111115)
          (181111) (171211) (161311) (151411) (141511)
          (131611) (121711) (111811) (171112) (161212)
          (151312) (141412) (131512) (121612) (111712)
          (161113) (151213) (141313) (131413) (121513)
          (111613) (151114) (141214) (131314) (121414)
          (111514) (141115) (131215) (121315) (111415)
          (131116) (121216) (111316) (121117) (111217)
          (111118) (1<111112) (111111111;1)
        ]
    /b
        [ (151213) (141313) (131413) (121513) (141214)
          (131314) (121414) (131215) (121315) (121216)
          (191212) (181312) (171412) (161512) (151612)
          (141712) (131812) (121912) (181213) (171313)
          (161413) (151513) (141613) (131713) (121813)
          (171214) (161314) (151414) (141514) (131614)
          (121714) (161215) (151315) (141415) (131515)
          (121615) (151216) (141316) (131416) (121516)
          (141217) (131317) (121417) (131218) (121318)
          (121219) (1<121312) (121212121<1)
        ]
    /limiteda
        [ (111411) (111312) (111213) (111114) (121311)
          (121212) (121113) (141111) (131211) (131112)
          (171111) (161211) (151311) (141411) (131511)
          (121611) (111711) (161112) (151212) (141312)
          (131412) (121512) (111612) (151113) (141213)
          (131313) (121413) (111513) (141114) (131214)
          (121314) (111414) (131115) (121215) (111315)
          (121116) (111216) (111117) (151111) (1)
        ]
    /limitedb
        [ (121512) (121413) (121314) (121215) (131412)
          (131313) (131214) (151212) (141312) (141213)
          (181212) (171312) (161412) (151512) (141612)
          (131712) (121812) (171213) (161313) (151413)
          (141513) (131613) (121713) (161214) (151314)
          (141414) (131514) (121614) (151215) (141315)
          (131415) (121515) (141216) (131316) (121416)
          (131217) (121317) (121218) (141212) (1)
        ]
    >>
    version get /encs exch def

    /c2w [
        [ 495 330 210 126  70  35  15   5 ]
        [ 165 120  84  56  35  20  10   4 ]
        [  45  36  28  21  15  10   6   3 ] 
        [   9   8   7   6   5   4   3   2 ]
        [   1   1   1   1   1   1   1   1 ]
    ] def
    /v 0 def
    cws {
        /cw exch def
        6 {
            cw v xor 1 and 0 ne {
                /v v 7682 xor def
            } if
            /v v -1 bitshift def
            /cw cw -1 bitshift def
        } repeat 
    } forall
    /v v checkoffset add def

    version (limiteda) eq version (limitedb) eq or {
        /v v 1023 and def
        v 824 gt v 853 lt and {
            /v v 292 add def
        } if 
    } {
        /v v 1023 and 45 add def
    } ifelse

    /d [ 2 2 2 2 2 2 ] def
    /r 0 def /c 0 def /w 0 def /sum 0 def
    {
        sum v eq {exit} if
        /t sum c2w r get c get add def
        t v eq {
            /w w 1 add def
            d r w 2 add put
            /sum t def
        } if
        t v gt {
            d r w 2 add put
            /r r 1 add def
            /w 0 def
        } if
        t v lt {
            /c c 1 add def
            /w w 1 add def
            /sum t def
        } if
    } loop
    20 0 1 4 {d exch get sub} for
    d exch 5 exch put
    version (b) eq version (limitedb) eq or {  
        /d [ d {1 add} forall ] def
    } if
    /cbs (111111111111) 12 string copy def
    5 -1 0 {
        /i exch def
        cbs 5 i sub 2 mul 1 add d i get 47 add put
    } for

    % Concatenate the space bar successions
    /sbs cws length 6 mul 31 add string def
    encs encs length 2 sub get dup 
    sbs exch 0 exch putinterval 
    length /j exch def
    0 1 cws length 1 sub {
        /i exch def
        sbs j encs cws i get get putinterval
        /j j 6 add def
    } for
    sbs j cbs putinterval
    /j j 12 add def
    encs encs length 1 sub get dup
    sbs exch j exch putinterval
    length j add /j exch def
    /sbs sbs 0 j getinterval def

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    /txt [ [text textxoffset textyoffset textfont textsize] ]
    /textxalign (center)
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/posicode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER posicode--

% --BEGIN ENCODER codablockf--
% --REQUIRES preamble raiseerror renmatrix--
% --DESC: Codablock F
% --EXAM: CODABLOCK F 34567890123456789010040digit
% --EXOP: columns=8
% --RNDR: renmatrix
%%BeginResource: uk.co.terryburton.bwipp codablockf 0.0 2015050900 125044 131468
%%BeginData:        512 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/codablockf {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /rows -1 def
    /columns 8 def
    /rowheight 10 def
    /sepheight 1 def
    /encoding (auto) def
    /parse false def
    /parsefnc false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /rows rows cvi def
    /columns columns cvi def
    /rowheight rowheight cvi def
    /sepheight sepheight cvi def

    columns 4 ge columns 62 le and 
    rows 2 ge rows 44 le and rows -1 eq or and {/c columns def} if

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    % Convert input into bytes accounting for FNC characters 
    /swa -1 def  /swb -2 def  /swc -3 def  /sft -4 def
    /fn1 -5 def  /fn2 -6 def  /fn3 -7 def  /fn4 -8 def
    /sta -9 def  /stp -10 def

    % Character maps for each state
    /charmaps [
      %  A    B    C         A    B    C         A    B    C
      [  32   32  (00) ]  [ (!)  (!)  (01) ]  [ (")  (")  (02) ]  % 0-2 
      [ (#)  (#)  (03) ]  [ ($)  ($)  (04) ]  [ (%)  (%)  (05) ]  % 3-5
      [ (&)  (&)  (06) ]  [ (')  (')  (07) ]  [  40   40  (08) ]  % 6-8
      [  41   41  (09) ]  [ (*)  (*)  (10) ]  [ (+)  (+)  (11) ]  % 9-11
      [ (,)  (,)  (12) ]  [ (-)  (-)  (13) ]  [ (.)  (.)  (14) ]  % 12-14
      [ (/)  (/)  (15) ]  [ (0)  (0)  (16) ]  [ (1)  (1)  (17) ]  % 15-17
      [ (2)  (2)  (18) ]  [ (3)  (3)  (19) ]  [ (4)  (4)  (20) ]  % 18-20
      [ (5)  (5)  (21) ]  [ (6)  (6)  (22) ]  [ (7)  (7)  (23) ]  % 21-23
      [ (8)  (8)  (24) ]  [ (9)  (9)  (25) ]  [ (:)  (:)  (26) ]  % 24-26
      [ (;)  (;)  (27) ]  [ (<)  (<)  (28) ]  [ (=)  (=)  (29) ]  % 27-29
      [ (>)  (>)  (30) ]  [ (?)  (?)  (31) ]  [ (@)  (@)  (32) ]  % 30-32
      [ (A)  (A)  (33) ]  [ (B)  (B)  (34) ]  [ (C)  (C)  (35) ]  % 33-35
      [ (D)  (D)  (36) ]  [ (E)  (E)  (37) ]  [ (F)  (F)  (38) ]  % 36-38
      [ (G)  (G)  (39) ]  [ (H)  (H)  (40) ]  [ (I)  (I)  (41) ]  % 39-41
      [ (J)  (J)  (42) ]  [ (K)  (K)  (43) ]  [ (L)  (L)  (44) ]  % 42-44
      [ (M)  (M)  (45) ]  [ (N)  (N)  (46) ]  [ (O)  (O)  (47) ]  % 45-47
      [ (P)  (P)  (48) ]  [ (Q)  (Q)  (49) ]  [ (R)  (R)  (50) ]  % 48-50
      [ (S)  (S)  (51) ]  [ (T)  (T)  (52) ]  [ (U)  (U)  (53) ]  % 51-53
      [ (V)  (V)  (54) ]  [ (W)  (W)  (55) ]  [ (X)  (X)  (56) ]  % 54-56
      [ (Y)  (Y)  (57) ]  [ (Z)  (Z)  (58) ]  [ ([)  ([)  (59) ]  % 57-59
      [  92   92  (60) ]  [ (])  (])  (61) ]  [ (^)  (^)  (62) ]  % 60-62
      [ (_)  (_)  (63) ]  [   0  (`)  (64) ]  [   1  (a)  (65) ]  % 63-65
      [   2  (b)  (66) ]  [   3  (c)  (67) ]  [   4  (d)  (68) ]  % 66-68
      [   5  (e)  (69) ]  [   6  (f)  (70) ]  [   7  (g)  (71) ]  % 69-71
      [   8  (h)  (72) ]  [   9  (i)  (73) ]  [  10  (j)  (74) ]  % 72-74
      [  11  (k)  (75) ]  [  12  (l)  (76) ]  [  13  (m)  (77) ]  % 75-77
      [  14  (n)  (78) ]  [  15  (o)  (79) ]  [  16  (p)  (80) ]  % 78-80
      [  17  (q)  (81) ]  [  18  (r)  (82) ]  [  19  (s)  (83) ]  % 81-83
      [  20  (t)  (84) ]  [  21  (u)  (85) ]  [  22  (v)  (86) ]  % 84-86
      [  23  (w)  (87) ]  [  24  (x)  (88) ]  [  25  (y)  (89) ]  % 87-89
      [  26  (z)  (90) ]  [  27  ({)  (91) ]  [  28  (|)  (92) ]  % 90-92
      [  29  (})  (93) ]  [  30  (~)  (94) ]  [  31  127  (95) ]  % 93-95
      [ fn3  fn3  (96) ]  [ fn2  fn2  (97) ]  [ sft  sft  (98) ]  % 96-98
      [ swc  swc  (99) ]  [ swb  fn4  swb  ]  [ fn4  swa  swa  ]  % 99-101
      [ fn1  fn1  fn1  ]  [ sta  sta  sta  ]  [ stp  stp  stp  ]  % 102-104
    ] def
    
    % Invert charmaps to give character to value maps for each state
    /charvals [ 105 dict 105 dict 105 dict ] def
    0 1 charmaps length 1 sub {
        /i exch def
        /encs charmaps i get def
        0 1 2 {
            /j exch def
            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required
            charvals j get exch i put 
        } for
    } for
    /seta charvals 0 get def
    /setb charvals 1 get def
    /setc charvals 2 get def
    
    /fncvals <<
        (FNC1) fn1
        (FNC2) fn2
        (FNC3) fn3
        (FNC4) fn4
    >> def
    /msg barlen array def
    /i 0 def /j 0 def {
        i barlen eq {exit} if
        /char barcode i get def
        parsefnc char 94 eq and i barlen 4 sub lt and {
            barcode i 1 add get 94 ne {
                /char fncvals barcode i 1 add 4 getinterval get def
                /i i 4 add def
            } {
                /i i 1 add def
            } ifelse
        } if
        msg j char put
        /i i 1 add def
        /j j 1 add def
    } loop
    /msg msg 0 j getinterval def
    /msglen msg length def

    % Determine digit runlength and characters from given position
    /numsscr {
        /n 0 def /s 0 def
        /p exch def {
            p msglen ge {exit} if
            msg p get
            dup setc exch known not {pop exit} if
            fn1 eq {
                % FNC1 in odd position of run like two digits
                s 2 mod 0 eq {/s s 1 add def} {exit} ifelse
            } if
            /n n 1 add def
            /s s 1 add def
            /p p 1 add def
        } loop
        n s
    } bind def

    % Encoding for each alphabet
    /enca {
        seta exch get cws exch j exch put
        /j j 1 add def
    } bind def
    /encb {
        setb exch get cws exch j exch put
        /j j 1 add def
    } bind def
    /encc {
        dup type /arraytype ne {
            setc exch get
        } {
            aload pop 48 sub exch 48 sub 10 mul add
        } ifelse
        cws exch j exch put
        /j j 1 add def
    } bind def

    % Character exclusively in either alphabet A or B
    /anotb {dup seta exch known exch setb exch known not and} bind def
    /bnota {dup setb exch known exch seta exch known not and} bind def

    % Pre-compute relative position of next anotb and next bnota characters
    /nextanotb [ msg length {0} repeat 9999 ] def
    /nextbnota [ msg length {0} repeat 9999 ] def
    msg length 1 sub -1 0 {
        /i exch def
        msg i get anotb {
            nextanotb i 0 put
        } {
            nextanotb i nextanotb i 1 add get 1 add put
        } ifelse
        msg i get bnota {
            nextbnota i 0 put
        } {
            nextbnota i nextbnota i 1 add get 1 add put
        } ifelse
    } for

    % Does a-only come before b-only after given position and vice versa
    /abeforeb {dup nextanotb exch get exch nextbnota exch get lt} bind def
    /bbeforea {dup nextbnota exch get exch nextanotb exch get lt} bind def

    % Add padding to row
    /padrow {
        {
           {  % common exit
               cset (seta) eq {swc enca /cset (setc) def exit} if
               cset (setb) eq {swc encb /cset (setc) def exit} if
               cset (setc) eq {swb encc /cset (setb) def exit} if
           } loop
        } repeat
    } bind def

    % Convert message to codewords
    /cws c 5 add rows -1 ne {rows} {44} ifelse mul array def

    /i 0 def /j 0 def /r 1 def
    /lastrow false def {
        
        lastrow {exit} if

        % Add start character and code subset selector
        sta enca
        i msglen lt {i numsscr} {-1 -1} ifelse /nums exch def /nchars exch def
        {  % common exit
            msglen 0 eq {
                swb enca
                /cset (setb) def
                exit
            } if
            nums 2 ge {
                swc enca
                /cset (setc) def
                exit
            } if
            i abeforeb { 
                sft enca
                /cset (seta) def
                exit 
            } if 
            swb enca
            /cset (setb) def
            exit
        } loop
        /j j 1 add def  % Skip row indicator position

        % Main encoding loop
        /endofrow false def {
            /rem c 3 add j c 5 add mod sub def  % Codewords to end of row

            i msglen eq endofrow or {exit} if
        
            i numsscr /nums exch def /nchars exch def

            % Determine switches and shifts
            {  % common exit
                cset (seta) eq cset (setb) eq or nums 4 ge and 
                msg i get fn1 ne and {
                    nums 2 mod 0 eq
                    rem 3 ge and {
                        swc cset (seta) eq {enca} {encb} ifelse
                        /cset (setc) def
                        2 {
                            msg i get fn1 eq {
                                fn1 encc
                                /i i 1 add def
                            } {
                                msg i 2 getinterval encc
                                /i i 2 add def
                            } ifelse
                        } repeat
                        exit
                    } if
                    nums 2 mod 0 ne
                    rem 4 ge and {
                        msg i get cset (seta) eq {enca} {encb} ifelse
                        /i i 1 add def
                        swc cset (seta) eq {enca} {encb} ifelse
                        /cset (setc) def
                        2 {
                            msg i get fn1 eq {
                                fn1 encc
                                /i i 1 add def
                            } {
                                msg i 2 getinterval encc
                                /i i 2 add def
                            } ifelse
                        } repeat
                        exit
                    } if
                } if
                cset (setb) eq msg i get anotb and 
                rem 2 ge and { 
                    i msglen 1 sub lt {
                        i 1 add bbeforea { 
                            sft encb
                            msg i get enca
                            /i i 1 add def
                            exit
                        } if
                    } if
                    swa encb
                    /cset (seta) def
                    msg i get enca
                    /i i 1 add def
                    exit
                } if
                cset (seta) eq msg i get bnota and
                rem 2 ge and {
                    i msglen 1 sub lt {
                        i 1 add abeforeb {
                            sft enca
                            msg i get encb
                            /i i 1 add def
                            exit
                        } if
                    } if
                    swb enca
                    /cset (setb) def
                    msg i get encb
                    /i i 1 add def
                    exit
                } if
                cset (setc) eq nums 2 lt and
                rem 2 ge and {
                    i abeforeb {
                        swa encc
                        /cset (seta) def
                        msg i get enca
                        /i i 1 add def
                        exit
                    } if
                    swb encc
                    /cset (setb) def
                    msg i get encb
                    /i i 1 add def
                    exit
                } if
        
                % No switches or latches so try to encode
                cset (seta) eq seta msg i get known and
                rem 1 ge and {
                    msg i get enca
                    /i i 1 add def
                    exit
                } if
                cset (setb) eq setb msg i get known and
                rem 1 ge and {
                    msg i get encb
                    /i i 1 add def
                    exit
                } if
                cset (setc) eq nums 2 ge and
                rem 1 ge and {
                    msg i get fn1 eq {
                        fn1 encc
                        /i i 1 add def
                    } {
                        msg i 2 getinterval encc
                        /i i 2 add def 
                    } ifelse
                    exit
                } if

                % Encoding does not fit in the row
                /endofrow true def
                exit

            } loop  % common exit

        } loop

        % Determine whether this is the final row
        r rows eq rows -1 eq or r 1 gt and i msglen eq and rem 2 ge and {
            rem 2 sub padrow
            /j j 3 add def  % Skip symbol and row checksum character positions
            stp enca
            /lastrow true def
        } {
            rem padrow
            /j j 1 add def  % Skip row checksum character positions
            stp enca
            /r r 1 add def
        } ifelse

    } loop
    /cws cws 0 j getinterval def

    % Maps for row indicators and symbol checksums
    /abmap [
        64 1 95 {} for
         0 1 15 {} for
        26 1 63 {} for
    ] def
    /cmap [ 0 1 85 {} for ] def
    
    % Add symbol check characters to last row
    /chkmsg msglen array def
    /j 0 def
    0 1 msglen 1 sub {
        /i exch def
        /char msg i get def
        char 0 ge {chkmsg j char put /j j 1 add def} if
        char fn1 eq i 0 ne and {chkmsg j 29 put /j j 1 add def} if
    } for
    /t1 0 def /t2 0 def /k1 0 def /k2 0 def
    0 1 j 1 sub {
        /i exch def
        /t1 chkmsg i get i mul 86 mod def
        /t2 t1 chkmsg i get add 86 mod def
        /k1 k1 t2 add 86 mod def
        /k2 k2 t1 add 86 mod def
    } for
    cws cws length 4 sub cset (setc) ne {abmap} {cmap} ifelse k1 get put
    cws cws length 3 sub cset (setc) ne {abmap} {cmap} ifelse k2 get put

    % Populate row indicators
    cws 2 2 copy 1 sub get 99 ne {abmap} {cmap} ifelse r 2 sub get put
    1 1 r 1 sub {
        /i exch def
        cws i c 5 add mul 2 add 2 copy 1 sub get 99 ne {abmap} {cmap} ifelse i 42 add get put
    } for

    % Calculate row check characters
    0 1 r 1 sub {
        cws exch c 5 add mul c 4 add getinterval /rcws exch def
        /csum rcws 0 get def
        1 1 rcws length 2 sub {
            /i exch def
            /csum csum rcws i get i mul add def
        } for
        rcws rcws length 1 sub csum 103 mod put
    } for

    % Create an array containing the character mappings
    /encs
    [ (212222) (222122) (222221) (121223) (121322) (131222) (122213)
      (122312) (132212) (221213) (221312) (231212) (112232) (122132)
      (122231) (113222) (123122) (123221) (223211) (221132) (221231)
      (213212) (223112) (312131) (311222) (321122) (321221) (312212)
      (322112) (322211) (212123) (212321) (232121) (111323) (131123)
      (131321) (112313) (132113) (132311) (211313) (231113) (231311)
      (112133) (112331) (132131) (113123) (113321) (133121) (313121)
      (211331) (231131) (213113) (213311) (213131) (311123) (311321)
      (331121) (312113) (312311) (332111) (314111) (221411) (431111)
      (111224) (111422) (121124) (121421) (141122) (141221) (112214)
      (112412) (122114) (122411) (142112) (142211) (241211) (221114)
      (413111) (241112) (134111) (111242) (121142) (121241) (114212)
      (124112) (124211) (411212) (421112) (421211) (212141) (214121)
      (412121) (111143) (111341) (131141) (114113) (114311) (411113)
      (411311) (113141) (114131) (311141) (411131) (211412) (2331112)
    ] def

    % Derive the bits for each row
    /rowbits r array def
    0 1 r 1 sub {
        /i exch def
        /sbs [
            cws i c 5 add mul c 5 add getinterval {
                encs exch get {48 sub} forall
            } forall 
        ] def
        mark
        0 sbs {1 index 1 eq {{0}} {{1}} ifelse repeat} forall
        counttomark 1 sub array astore exch pop exch pop
        rowbits i 3 -1 roll put
    } for

    % Populate the bitmap
    /symwid c 11 mul 57 add def
    /pixs [
        symwid sepheight mul {1} repeat
        0 1 r 2 sub {
            /i exch def
            rowheight {rowbits i get aload pop} repeat
            sepheight {
                1 1 0 1 0 0 0 0 1 0 0
                symwid 24 sub {1} repeat
                1 1 0 0 0 1 1 1 0 1 0 1 1
            } repeat
        } for
        rowheight {rowbits r 1 sub get aload pop} repeat
        symwid sepheight mul {1} repeat
    ] def
    
    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx symwid
    /pixy pixs length symwid idiv
    /height pixs length symwid idiv 72 div
    /width symwid 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/codablockf dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER codablockf--

% --BEGIN ENCODER code16k--
% --REQUIRES preamble raiseerror renmatrix--
% --DESC: Code 16K
% --EXAM: Abcd-1234567890-wxyZ
% --EXOP:
% --RNDR: renmatrix
%%BeginResource: uk.co.terryburton.bwipp code16k 0.0 2015050900 142769 155916
%%BeginData:        710 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/code16k {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /mode -1 def
    /pos -1 def
    /rows 0 def
    /rowheight 8 def
    /sepheight 1 def
    /encoding (auto) def
    /raw false def
    /parse false def
    /parsefnc false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /mode mode cvi def
    /pos pos cvi def
    /rows rows cvi def
    /rowheight rowheight cvi def
    /sepheight sepheight cvi def

    pos -1 ne {/rows 16 def} if

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    % Convert input into bytes accounting for FNC characters 
    /swa  -1 def  /swb  -2 def  /swc  -3 def 
    /sa1  -4 def  /sb1  -5 def  /sc1  -6 def 
    /sa2  -7 def  /sb2  -8 def  /sc2  -9 def 
    /pad -10 def  /sb3 -11 def  /sc3 -12 def
    /fn1 -13 def  /fn2 -14 def  /fn3 -15 def  /fn4 -16 def

    % Character maps for each state
    /charmaps [
      %  A    B    C         A    B    C         A    B    C
      [  32   32  (00) ]  [ (!)  (!)  (01) ]  [ (")  (")  (02) ]  % 0-2 
      [ (#)  (#)  (03) ]  [ ($)  ($)  (04) ]  [ (%)  (%)  (05) ]  % 3-5
      [ (&)  (&)  (06) ]  [ (')  (')  (07) ]  [  40   40  (08) ]  % 6-8
      [  41   41  (09) ]  [ (*)  (*)  (10) ]  [ (+)  (+)  (11) ]  % 9-11
      [ (,)  (,)  (12) ]  [ (-)  (-)  (13) ]  [ (.)  (.)  (14) ]  % 12-14
      [ (/)  (/)  (15) ]  [ (0)  (0)  (16) ]  [ (1)  (1)  (17) ]  % 15-17
      [ (2)  (2)  (18) ]  [ (3)  (3)  (19) ]  [ (4)  (4)  (20) ]  % 18-20
      [ (5)  (5)  (21) ]  [ (6)  (6)  (22) ]  [ (7)  (7)  (23) ]  % 21-23
      [ (8)  (8)  (24) ]  [ (9)  (9)  (25) ]  [ (:)  (:)  (26) ]  % 24-26
      [ (;)  (;)  (27) ]  [ (<)  (<)  (28) ]  [ (=)  (=)  (29) ]  % 27-29
      [ (>)  (>)  (30) ]  [ (?)  (?)  (31) ]  [ (@)  (@)  (32) ]  % 30-32
      [ (A)  (A)  (33) ]  [ (B)  (B)  (34) ]  [ (C)  (C)  (35) ]  % 33-35
      [ (D)  (D)  (36) ]  [ (E)  (E)  (37) ]  [ (F)  (F)  (38) ]  % 36-38
      [ (G)  (G)  (39) ]  [ (H)  (H)  (40) ]  [ (I)  (I)  (41) ]  % 39-41
      [ (J)  (J)  (42) ]  [ (K)  (K)  (43) ]  [ (L)  (L)  (44) ]  % 42-44
      [ (M)  (M)  (45) ]  [ (N)  (N)  (46) ]  [ (O)  (O)  (47) ]  % 45-47
      [ (P)  (P)  (48) ]  [ (Q)  (Q)  (49) ]  [ (R)  (R)  (50) ]  % 48-50
      [ (S)  (S)  (51) ]  [ (T)  (T)  (52) ]  [ (U)  (U)  (53) ]  % 51-53
      [ (V)  (V)  (54) ]  [ (W)  (W)  (55) ]  [ (X)  (X)  (56) ]  % 54-56
      [ (Y)  (Y)  (57) ]  [ (Z)  (Z)  (58) ]  [ ([)  ([)  (59) ]  % 57-59
      [  92   92  (60) ]  [ (])  (])  (61) ]  [ (^)  (^)  (62) ]  % 60-62
      [ (_)  (_)  (63) ]  [   0  (`)  (64) ]  [   1  (a)  (65) ]  % 63-65
      [   2  (b)  (66) ]  [   3  (c)  (67) ]  [   4  (d)  (68) ]  % 66-68
      [   5  (e)  (69) ]  [   6  (f)  (70) ]  [   7  (g)  (71) ]  % 69-71
      [   8  (h)  (72) ]  [   9  (i)  (73) ]  [  10  (j)  (74) ]  % 72-74
      [  11  (k)  (75) ]  [  12  (l)  (76) ]  [  13  (m)  (77) ]  % 75-77
      [  14  (n)  (78) ]  [  15  (o)  (79) ]  [  16  (p)  (80) ]  % 78-80
      [  17  (q)  (81) ]  [  18  (r)  (82) ]  [  19  (s)  (83) ]  % 81-83
      [  20  (t)  (84) ]  [  21  (u)  (85) ]  [  22  (v)  (86) ]  % 84-86
      [  23  (w)  (87) ]  [  24  (x)  (88) ]  [  25  (y)  (89) ]  % 87-89
      [  26  (z)  (90) ]  [  27  ({)  (91) ]  [  28  (|)  (92) ]  % 90-92
      [  29  (})  (93) ]  [  30  (~)  (94) ]  [  31  127  (95) ]  % 93-95
      [ fn3  fn3  (96) ]  [ fn2  fn2  (97) ]  [ sb1  sa1  (98) ]  % 96-98
      [ swc  swc  (99) ]  [ swb  fn4  swb  ]  [ fn4  swa  swa  ]  % 99-101
      [ fn1  fn1  fn1  ]  [ pad  pad  pad  ]  [ sb2  sa2  sb1  ]  % 102-104
      [ sc2  sc2  sb2  ]  [ sc3  sc3  sb3  ]                      % 105-106
    ] def 
    
    % Invert charmaps to give character to value maps for each state
    /charvals [ 109 dict 109 dict 109 dict ] def
    0 1 charmaps length 1 sub {
        /i exch def
        /encs charmaps i get def
        0 1 2 {
            /j exch def
            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required
            charvals j get exch i put 
        } for
    } for
    /seta charvals 0 get def
    /setb charvals 1 get def
    /setc charvals 2 get def

    raw {/encoding (raw) def} if

    encoding (raw) eq {
        /cws barlen array def
        /i 0 def /j 0 def
        { % loop
            i barlen eq {exit} if
            /cw barcode i 1 add 3 getinterval cvi def
            cws j cw put
            /i i 4 add def
            /j j 1 add def
        } loop
        /cws cws 0 j getinterval def
        /text () def
    } if

    encoding (auto) eq { 

        /fncvals <<
            (FNC1) fn1
            (FNC2) fn2
            (FNC3) fn3
            (FNC4) fn4
        >> def
        /msg barlen array def
        /i 0 def /j 0 def {
            i barlen eq {exit} if
            /char barcode i get def
            parsefnc char 94 eq and i barlen 4 sub lt and {
                barcode i 1 add get 94 ne {
                    /char fncvals barcode i 1 add 4 getinterval get def
                    /i i 4 add def
                } {
                    /i i 1 add def
                } ifelse
            } if
            msg j char put
            /i i 1 add def
            /j j 1 add def
        } loop
        /msg msg 0 j getinterval def
        /msglen msg length def
    
        % Determine digit runlength and characters from given position
        /numsscr {
            /n 0 def /s 0 def
            /p exch def {
                p msglen ge {exit} if
                msg p get
                dup setc exch known not {pop exit} if
                fn1 eq {
                    % FNC1 in odd position of run like two digits
                    s 2 mod 0 eq {/s s 1 add def} {exit} ifelse
                } if
                /n n 1 add def
                /s s 1 add def
                /p p 1 add def
            } loop
            n s
        } bind def

        % Encoding for each alphabet
        /enca {
            seta exch get cws exch j exch put
            /j j 1 add def
        } bind def
        /encb {
            setb exch get cws exch j exch put
            /j j 1 add def
        } bind def
        /encc {
            dup type /arraytype ne {
                setc exch get
            } {
                aload pop 48 sub exch 48 sub 10 mul add
            } ifelse
            cws exch j exch put
            /j j 1 add def
        } bind def

        % Character exclusively in either alphabet A or B
        /anotb {dup seta exch known exch setb exch known not and} bind def
        /bnota {dup setb exch known exch seta exch known not and} bind def

        % Pre-compute relative position of next anotb and next bnota characters
        /nextanotb [ msg length {0} repeat 9999 ] def
        /nextbnota [ msg length {0} repeat 9999 ] def
        msg length 1 sub -1 0 {
            /i exch def
            msg i get anotb {
                nextanotb i 0 put
            } {
                nextanotb i nextanotb i 1 add get 1 add put
            } ifelse
            msg i get bnota {
                nextbnota i 0 put
            } {
                nextbnota i nextbnota i 1 add get 1 add put
            } ifelse
        } for

        % Does a-only come before b-only after given position and vice versa
        /abeforeb {dup nextanotb exch get exch nextbnota exch get lt} bind def
        /bbeforea {dup nextbnota exch get exch nextanotb exch get lt} bind def
 
        /cws barcode length 2 mul 3 add array def
       
        % Select mode and encode first characters
        /i 0 def /j 0 def
        {  % common exit
            % extended data length
            pos -1 ne {
                % encode one and two
                cws 0 pos 10 idiv 1 sub put
                cws 1 pos 10 mod 1 sub put 
                /j 2 def
                /cset (setb) def
                /mode 7 def
                exit
            } if
            % empty => b
            msglen 0 eq {
                /cset (setb) def
                /mode 1 def
                exit
            } if
            % FNC1 . 2+ nums => c fnc1
            msglen 2 ge {
                msg 0 get fn1 eq 1 numsscr exch pop 2 ge and {
                    /cset (setc) def
                    /mode 4 def
                    /i 1 def
                    exit
                } if
            } if
            % FNC1 => b fnc1
            msg 0 get fn1 eq {
                /cset (setb) def
                /mode 3 def
                /i 1 def
                exit
            } if
            msglen 2 ge {
                % 2+ even nums => c
                0 numsscr exch pop dup 2 ge exch 2 mod 0 eq and {
                    /cset (setc) def
                    /mode 2 def
                    exit
                } if
                % 3+ odd nums => c sb1 encode
                0 numsscr exch pop dup 3 ge exch 2 mod 1 eq and {
                    msg 0 get encb
                    /cset (setc) def
                    /mode 5 def
                    /i 1 def
                    exit
                } if
                % b . 2+ even nums => c sb1 encode
                setb msg 0 get known
                1 numsscr exch pop dup 2 ge exch 2 mod 0 eq and and {
                    msg 0 get encb
                    /cset (setc) def
                    /mode 5 def
                    /i 1 def
                    exit
                } if
                % b . 3+ odd nums => c sb2 encode 
                setb msg 0 get known
                1 numsscr exch pop dup 3 ge exch 2 mod 1 eq and and {
                    msg 0 get encb
                    msg 1 get encb
                    /cset (setc) def
                    /mode 6 def
                    /i 2 def
                    exit
                } if
                % b . b . 2+ even nums => c sb2 encode
                setb msg 0 get known
                setb msg 1 get known and
                2 numsscr exch pop dup 2 ge exch 2 mod 0 eq and and {
                    msg 0 get encb
                    msg 1 get encb
                    /cset (setc) def
                    /mode 6 def
                    /i 2 def
                    exit
                } if
            } if
            % anotb before bnota => a
            0 abeforeb {
                /cset (seta) def
                /mode 0 def
                exit
            } if
            % otherwise => b
            /cset (setb) def
            /mode 1 def
            exit
        } loop

        {  % Encode remainder
            i msglen eq {exit} if
        
            i numsscr /nums exch def /nchars exch def
        
            % Determine switches and shifts
            {  % common exit
                cset (seta) eq {
                    % bnota . anotb before bnota => sb1 encode
                    i msglen 1 sub lt {
                        msg i get bnota
                        i 1 add abeforeb and {
                            sb1 enca
                            msg i get encb
                            /i i 1 add def
                            exit
                        } if
                    } if
                    % bnota . bnota . anotb before bnota => sb2 encode
                    i msglen 2 sub lt {
                        msg i get bnota
                        msg i 1 add get bnota and
                        i 2 add abeforeb and {
                            sb2 enca
                            msg i get encb
                            msg i 1 add get encb
                            /i i 2 add def
                            exit
                        } if
                    } if
                    % bnota => swb
                    msg i get bnota {
                        swb enca
                        /cset (setb) def
                        exit
                    } if
                    % 4 nums . a => sc2 encode
                    i msglen 4 sub lt {
                        nums 4 eq 
                        seta msg i 4 add get known and {
                            sc2 enca
                            2 {
                                msg i get fn1 eq {
                                    fn1 encc
                                    /i i 1 add def
                                } {
                                    msg i 2 getinterval encc
                                    /i i 2 add def 
                                } ifelse
                            } repeat
                            exit
                        } if
                    } if
                    % 6 nums . a => sc3 encode
                    i msglen 6 sub lt { 
                        nums 6 eq 
                        seta msg i 6 add get known and {
                            sc3 enca
                            3 {
                                msg i get fn1 eq {
                                    fn1 encc
                                    /i i 1 add def
                                } {
                                    msg i 2 getinterval encc
                                    /i i 2 add def
                                } ifelse
                            } repeat
                            exit
                        } if
                    } if
                    % 4+ even nums => swc
                    nums 4 ge nums 2 mod 0 eq and {
                        swc enca
                        /cset (setc) def
                        exit
                    } if
                    % otherwise => encode
                    msg i get enca
                    /i i 1 add def
                    exit
                } if
                cset (setb) eq {
                    % anotb . bnota before anotb => sa1 encode
                    i msglen 1 sub lt {
                        msg i get anotb
                        i 1 add bbeforea and {
                            sa1 encb
                            msg i get enca
                            /i i 1 add def
                            exit
                        } if
                    } if
                    % anotb . anotb . bnota before anotb => sa2 encode
                    i msglen 2 sub lt {
                        msg i get anotb 
                        msg i 1 add get anotb and
                        i 2 add bbeforea and {
                            sa2 encb
                            msg i get enca
                            msg i 1 add get enca
                            /i i 2 add def
                            exit
                        } if
                    } if
                    % anotb => swa
                    msg i get anotb {
                        swa encb
                        /cset (seta) def
                        exit
                    } if
                    % 4 nums . b => sc2 encode
                    i msglen 4 sub lt {
                        nums 4 eq
                        setb msg i 4 add get known and {
                            sc2 encb
                            2 {
                                msg i get fn1 eq {
                                    fn1 encc
                                    /i i 1 add def
                                } {
                                    msg i 2 getinterval encc
                                    /i i 2 add def
                                } ifelse
                            } repeat
                            exit
                        } if
                    } if
                    % 6 nums . b => sc3 encode
                    i msglen 6 sub lt {
                        nums 6 eq
                        setb msg i 6 add get known and {
                            sc3 encb
                            3 {
                                msg i get fn1 eq {
                                    fn1 encc
                                    /i i 1 add def
                                } {
                                    msg i 2 getinterval encc
                                    /i i 2 add def
                                } ifelse
                            } repeat
                            exit
                        } if
                    } if
                    % 4+ even nums => swc
                    nums 4 ge nums 2 mod 0 eq and {
                        swc encb
                        /cset (setc) def
                        exit
                    } if
                    % otherwise => encode
                    msg i get encb
                    /i i 1 add def
                    exit 
                } if
                cset (setc) eq {
                    % 2+ nums => encode
                    nums 2 ge {
                        msg i get fn1 eq {
                            fn1 encc
                            /i i 1 add def
                        } {
                            msg i 2 getinterval encc
                            /i i 2 add def
                        } ifelse
                        exit
                    } if
                    % b . 2+ even nums => sb1 encode
                    i msglen 1 sub lt {
                        setb msg i get known
                        i 1 add numsscr exch pop dup 2 ge exch 2 mod 0 eq and and {
                            sb1 encc
                            msg i get encb
                            /i i 1 add def
                            exit
                        } if
                    } if
                    % b . 3+ odd nums => sb2 encode
                    i msglen 1 sub lt {
                        setb msg i get known
                        i 1 add numsscr exch pop dup 3 ge exch 2 mod 1 eq and and {
                            sb2 encc
                            msg i get encb
                            msg i 1 add get encb
                            /i i 2 add def
                            exit
                        } if
                    } if
                    % b . b . 2+ even nums => sb2 encode
                    i msglen 2 sub lt {
                        setb msg i get known
                        setb msg i 1 add get known and
                        i 2 add numsscr exch pop dup 2 ge exch 2 mod 0 eq and and {
                            sb2 encc
                            msg i get encb
                            msg i 1 add get encb
                            /i i 2 add def
                            exit
                        } if
                    } if
                    % b . b . 3+ odd nums => sb3 encode
                    i msglen 3 sub lt {
                        setb msg i get known
                        setb msg i 1 add get known and
                        i 2 add numsscr exch pop dup 3 ge exch 2 mod 1 eq and and {
                            sb3 encc
                            msg i get encb
                            msg i 1 add get encb
                            msg i 2 add get encb
                            /i i 3 add def
                            exit
                        } if
                    } if
                    % b . b . b . 2+ even nums => sb3 encode
                    i msglen 3 sub lt {
                        setb msg i get known 
                        setb msg i 1 add get known and
                        setb msg i 2 add get known and
                        i 3 add numsscr exch pop dup 2 ge exch 2 mod 0 eq and and {
                            sb3 encc
                            msg i get encb
                            msg i 1 add get encb
                            msg i 2 add get encb
                            /i i 3 add def
                            exit 
                        } if
                    } if
                    % anotb before bnota => swa
                    i abeforeb {
                        swa encc
                        /cset (seta) def
                        exit
                    } if
                    % otherwise => swb
                    swb encc
                    /cset (setb) def
                    exit
                } if
                exit
            } loop
        
        } loop
        /cws cws 0 j getinterval def
    } if  % auto encoding
    
    % Basic metrics for the each symbol
    %     r  dcws 
    /metrics [
        [  2    7 ]
        [  3   12 ]
        [  4   17 ]
        [  5   22 ]
        [  6   27 ]
        [  7   32 ]
        [  8   37 ]
        [  9   42 ]
        [ 10   47 ]
        [ 11   52 ]
        [ 12   57 ]
        [ 13   62 ]
        [ 14   67 ]
        [ 15   72 ]
        [ 16   77 ]
    ] def

    % Select metrics of an appropriate symbol
    /urows rows def
    /i 0 def
    { % loop
        /m metrics i get def
        /r    m 0 get def        % Columns in symbol
        /dcws m 1 get def        % Data codewords in symbol
        /okay true def
        urows 0 ne urows r ne and {/okay false def} if
        cws length dcws gt {/okay false def} if
        okay {exit} if
        /i i 1 add def
    } loop

    % Extend cws to ncws codewords by addition of pad characters
    /cws [ cws aload pop dcws cws length sub {103} repeat ] def

    % Add the start character
    /cws [ r 2 sub 7 mul mode add cws aload pop ] def

    % Calculate the check characters
    0 0 1 dcws {dup 2 add exch cws exch get mul add} for 
    107 mod /c1 exch def
    0 0 1 dcws {dup 1 add exch cws exch get mul add} for 
    c1 dcws 2 add mul add 107 mod /c2 exch def
    /cws [ cws aload pop c1 c2 ] def

    % Create an array containing the character mappings
    /encs
    [ (212222) (222122) (222221) (121223) (121322) (131222) (122213)
      (122312) (132212) (221213) (221312) (231212) (112232) (122132)
      (122231) (113222) (123122) (123221) (223211) (221132) (221231)
      (213212) (223112) (312131) (311222) (321122) (321221) (312212)
      (322112) (322211) (212123) (212321) (232121) (111323) (131123)
      (131321) (112313) (132113) (132311) (211313) (231113) (231311)
      (112133) (112331) (132131) (113123) (113321) (133121) (313121)
      (211331) (231131) (213113) (213311) (213131) (311123) (311321)
      (331121) (312113) (312311) (332111) (314111) (221411) (431111)
      (111224) (111422) (121124) (121421) (141122) (141221) (112214)
      (112412) (122114) (122411) (142112) (142211) (241211) (221114)
      (413111) (241112) (134111) (111242) (121142) (121241) (114212)
      (124112) (124211) (411212) (421112) (421211) (212141) (214121)
      (412121) (111143) (111341) (131141) (114113) (114311) (411113)
      (411311) (113141) (114131) (311141) (411131) (211412) (211214)
      (211232) (211133)
    ] def

    % Start/stop character encodings
    /startencs [ 
        (3211) (2221) (2122) (1411) (1132) (1231) (1114) (3112)
        (3211) (2221) (2122) (1411) (1132) (1231) (1114) (3112)
    ] def
    /stopencsodd [
        (3211) (2221) (2122) (1411) (1132) (1231) (1114) (3112)
        (1132) (1231) (1114) (3112) (3211) (2221) (2122) (1411)
    ] def
    /stopencseven [
        (2122) (1411) (1132) (1231) (1114) (3112) (1132) (1231)
        (1114) (3112) (3211) (2221) (2122) (1411) (3211) (2221)
    ] def
    pos -1 eq pos 10 idiv 2 mod 1 eq or {
        /stopencs stopencsodd def
    } {
        /stopencs stopencseven def
    } ifelse
 
    % Derive the bits for each row
    /rowbits r array def
    0 1 r 1 sub {
        /i exch def
        /sbs [
            10
            startencs i get {48 sub} forall
            1
            cws i 5 mul 5 getinterval {
                encs exch get {48 sub} forall
            } forall 
            stopencs i get {48 sub} forall
            1
        ] def
        mark
        1 sbs {1 index 0 eq {{1}} {{0}} ifelse repeat} forall
        counttomark 1 sub array astore exch pop exch pop
        rowbits i 3 -1 roll put
    } for

    % Populate the bitmap
    /pixs [
        81 sepheight mul {1} repeat
        0 1 r 2 sub {
            /i exch def
            rowheight {rowbits i get aload pop} repeat
            sepheight {10 {0} repeat 70 {1} repeat 0} repeat
        } for
        rowheight {rowbits r 1 sub get aload pop} repeat
        81 sepheight mul {1} repeat
    ] def
    
    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx 81
    /pixy pixs length 81 idiv
    /height pixs length 81 idiv 72 div
    /width 81 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/code16k dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER code16k--

% --BEGIN ENCODER code49--
% --REQUIRES preamble raiseerror renmatrix--
% --DESC: Code 49
% --EXAM: MULTIPLE ROWS IN CODE 49
% --EXOP:
% --RNDR: renmatrix
%%BeginResource: uk.co.terryburton.bwipp code49 0.0 2015050900 218104 234960
%%BeginData:       1076 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/code49 {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /mode -1 def
    /pos -1 def
    /rows 0 def
    /rowheight 8 def
    /sepheight 1 def
    /parse false def
    /parsefnc false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /mode mode cvi def
    /pos pos cvi def
    /rows rows cvi def
    /rowheight rowheight cvi def
    /sepheight sepheight cvi def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    % Convert input into bytes accounting for FNC characters 
    /s1 -1 def /s2 -2 def /fn1 -3 def /fn2 -4 def /fn3 -5 def /ns -6 def
    /fncvals <<
        (FNC1) fn1
        (FNC2) fn2
        (FNC3) fn3
    >> def
    /msg barlen array def
    /i 0 def /j 0 def {
        i barlen eq {exit} if
        /char barcode i get def
        parsefnc char 94 eq and i barlen 4 sub lt and {
            barcode i 1 add get 94 ne {
                /char fncvals barcode i 1 add 4 getinterval get def
                /i i 4 add def
            } {
                /i i 1 add def
            } ifelse
        } if
        msg j char put
        /i i 1 add def
        /j j 1 add def
    } loop
    /msg msg 0 j getinterval def
    /msglen msg length def

    % Character encodings
    /charmap [
        (0) (1) (2) (3) (4) (5) (6) (7) (8) (9)
        (A) (B) (C) (D) (E) (F) (G) (H) (I) (J) (K) (L) (M)
        (N) (O) (P) (Q) (R) (S) (T) (U) (V) (W) (X) (Y) (Z)
        (-) (.) ( ) ($) (/) (+) (%)
        s1  s2  fn1 fn2 fn3 ns
    ] def

    % Invert charmap to give character to value map
    /charvals 49 dict def
    0 1 48 {
        /i exch def
        charmap i get 
        dup type /stringtype eq {0 get} if  % convert string to ASCII if required
        charvals exch i put 
    } for

    % Shifted character encodings
    /combos
    [ (1 ) (1A) (1B) (1C) (1D) (1E) (1F) (1G) (1H) (1I) (1J) (1K) (1L) (1M) (1N) (1O)
      (1P) (1Q) (1R) (1S) (1T) (1U) (1V) (1W) (1X) (1Y) (1Z) (11) (12) (13) (14) (15)
      (  ) (16) (17) (18) ( $) ( %) (19) (10) (1-) (1.) (1$) ( +) (1/) ( -) ( .) ( /)
      ( 0) ( 1) ( 2) ( 3) ( 4) ( 5) ( 6) ( 7) ( 8) ( 9) (1+) (21) (22) (23) (24) (25)
      (26) ( A) ( B) ( C) ( D) ( E) ( F) ( G) ( H) ( I) ( J) ( K) ( L) ( M) ( N) ( O)
      ( P) ( Q) ( R) ( S) ( T) ( U) ( V) ( W) ( X) ( Y) ( Z) (27) (28) (29) (20) (2-)
      (2.) (2A) (2B) (2C) (2D) (2E) (2F) (2G) (2H) (2I) (2J) (2K) (2L) (2M) (2N) (2O)
      (2P) (2Q) (2R) (2S) (2T) (2U) (2V) (2W) (2X) (2Y) (2Z) (2$) (2/) (2+) (2%) (2 )
    ] def
    0 1 127 {
        /i exch def
        combos i get dup 0 get /c1 exch def 1 get /c2 exch def
        c1 49 eq {  % s1 char
            charvals i [ charvals s1 get charvals c2 get ] put
        } if
        c1 50 eq {  % s2 char
            charvals i [ charvals s2 get charvals c2 get ] put
        } if
    } for

    /encodealpha {
        charvals exch get
        dup type /arraytype ne {1 array astore} if
        dup cws exch j exch putinterval
        length j add /j exch def
    } bind def

    /base48 {
        0 exch {48 sub exch 10 mul add} forall
        [ 3 1 roll exch 1 sub {dup 48 mod exch 48 idiv} repeat ]
        [ exch dup length 1 sub -1 0 {1 index exch get exch} for pop ]
        dup cws exch j exch putinterval
        length j add /j exch def
    } bind def

    /encodenumeric {
        /nums exch def
        /pre nums length dup 5 mod dup 2 ne {sub} {sub 5 sub} ifelse def
        0 5 pre 1 sub {nums exch 5 getinterval 3 exch base48} for
        /nums nums pre nums length pre sub getinterval def
        nums length
        dup 1 eq {nums i get encodealpha} if
        dup 3 eq {2 nums base48} if
        dup 4 eq {3 [49 48 nums aload pop] base48} if
        7 eq {
            3 [49 48 nums 0 4 getinterval aload pop] base48
            2 nums 4 3 getinterval base48
        } if
    } bind def

    % Pre-compute alphanumeric and numeric runlengths
    /numericruns [ msglen {0} repeat 0 ] def
    msglen 1 sub -1 0 {
        /i exch def
        msg i get
        dup 48 ge exch 57 le and {
            numericruns i numericruns i 1 add get 1 add put
        } {
            numericruns i 0 put
        } ifelse
    } for

    % Autoselect mode
    mode -1 eq {
        {  % common exit
            pos -1 ne {/mode 3 def exit} if
            numericruns 0 get 5 ge {/mode 2 def exit} if
            charvals msg 0 get get
            dup type /arraytype ne {pop /mode 0 def exit} if
            0 get 43 eq {4} {5} ifelse /mode exch def
            exit
        } loop
    } if

    /cws msglen 2 mul 1 add array def
    /method (alpha) def /i -1 def /j -1 def

    % Handle start for each mode
    mode 0 eq mode 1 eq or {/method (alpha) def /i 0 def /j 0 def} if 
    mode 2 eq {/method (numeric) def /i 0 def /j 0 def} if
    mode 3 eq {
        /posval [ 
            12 22
            13 23 33
            14 24 34 44
            15 25 35 45 55
            16 26 36 46 56 66
            17 27 37 47 57 67 77 
            18 28 38 48 58 68 78 88 
            19 29 39 49 59 69 79 89 99
        ] def
        cws 0 0 1 43 {dup posval exch get pos ne {pop} if} for 1 add put
        /method (alpha) def /i 0 def /j 1 def
    } if
    mode 4 eq mode 5 eq or {
        cws 0 charvals msg 0 get get 1 get put
        /method (alpha) def /i 1 def /j 1 def
    } if

    % Encode remainder
    {
        i msglen eq {exit} if
        {  % not a loop but common exit point
            method (alpha) eq {
                numericruns i get 5 ge {
                    ns encodealpha
                    /method (numeric) def
                    exit
                } if
                msg i get encodealpha
                /i i 1 add def
                exit
            } if
            method (numeric) eq {
                numericruns i get 5 lt {
                    ns encodealpha
                    /method (alpha) def
                    exit
                } if
                msg i numericruns i get getinterval encodenumeric
                /i i numericruns i get add def
                exit
            } if
        } loop
    } loop
    /cws cws 0 j getinterval def

    % Basic metrics for the each symbol
    %     r dcws 
    /metrics [
        [ 2    9 ]
        [ 3   16 ]
        [ 4   23 ]
        [ 5   30 ]
        [ 6   37 ]
        [ 7   42 ]
        [ 8   49 ]
    ] def

    % Select metrics of an appropriate symbol
    /urows rows def
    /i 0 def
    { % loop
        /m metrics i get def
        /r    m 0 get def        % Columns in symbol
        /dcws m 1 get def        % Data codewords in symbol
        /okay true def
        urows 0 ne urows r ne and {/okay false def} if
        cws length dcws gt {/okay false def} if
        okay {exit} if
        /i i 1 add def
    } loop

    % Extend cws to ncws codewords by addition of pad characters
    /cws [ cws aload pop dcws cws length sub {48} repeat ] def

    % Populate code character array and add row check characters
    /ccs r 8 mul array def
    /j 0 def
    0 1 r 2 sub {
        /i exch def
        /cc cws j 7 getinterval def
        ccs i 8 mul cc putinterval       
        ccs i 8 mul 7 add 0 cc {add} forall 49 mod put
        /j j 7 add def
    } for
    j dcws lt {
        ccs ccs length 8 sub cws j dcws j sub getinterval putinterval
    } if

    % Place row count character
    /cr7 r 2 sub 7 mul mode add def
    ccs ccs length 2 sub cr7 put

    % Calculate the symbol check characters
    [  1  9 31 26  2 12 17 23 37 18 22  6 27 44 15 43 39
      11 13  5 41 33 36  8  4 32  3 19 40 25 29 10 24 30 ]
    dup [ exch 20 exch 0 32 getinterval aload pop ] /weightx exch def
    dup [ exch 16 exch 1 32 getinterval aload pop ] /weighty exch def
        [ exch 38 exch 2 32 getinterval aload pop ] /weightz exch def
    /calccheck {
        /weights exch def
        /score 0 def
        0 1 r 1 sub 8 mul 2 idiv 1 sub {
            /i exch def
            ccs i 2 mul get 49 mul ccs i 2 mul 1 add get add 
            weights i 1 add get mul /score exch score add def
        } for
        score
    } bind def
    /lastrow ccs ccs length 8 sub 8 getinterval def

    % wr1 check character
    r 7 ge {
        cr7 weightz 0 get mul weightz calccheck add 2401 mod
        dup 49 idiv exch 49 mod 2 array astore
        lastrow 0 3 -1 roll putinterval
    } if
    /wr1 lastrow 0 get 49 mul lastrow 1 get add def

    % wr2 check character
    cr7 weighty 0 get mul weighty calccheck add 
    wr1 weighty r 4 mul 3 sub get mul add
    2401 mod dup /wr2 exch def
    dup 49 idiv exch 49 mod 2 array astore        
    lastrow 2 3 -1 roll putinterval

    % wr3 check character
    cr7 weightx 0 get mul weightx calccheck add
    wr1 weightx r 4 mul 3 sub get mul add
    wr2 weightx r 4 mul 2 sub get mul add
    2401 mod
    dup 49 idiv exch 49 mod 2 array astore        
    lastrow 4 3 -1 roll putinterval

    % Place last row check character
    ccs ccs length 8 sub 7 getinterval 0 exch {add} forall 49 mod
    ccs ccs length 1 sub 3 -1 roll put

    /patterns [
        [  % Even parity
            (11521132) (25112131) (14212132) (25121221) (14221222) (12412132) (23321221)
            (12421222) (21521221) (15112222) (15121312) (13312222) (24221311) (13321312)
            (11512222) (22421311) (11521312) (25112311) (14212312) (23312311) (12412312)
            (21512311) (16121131) (14321131) (12521131) (15212131) (15221221) (13412131)
            (13421221) (11612131) (16112221) (16121311) (14312221) (14321311) (12512221)
            (12521311) (15212311) (13412311) (11612311) (11131135) (31131133) (51131131)
            (21122134) (41122132) (21131224) (41131222) (11113135) (31113133) (51113131)
            (11122225) (31122223) (51122221) (11131315) (31131313) (51131311) (21113224)
            (41113222) (21122314) (41122312) (11113315) (31113313) (51113311) (12131134)
            (32131132) (21231133) (41231131) (22122133) (42122131) (11222134) (22131223)
            (42131221) (11231224) (31231222) (12113134) (32113132) (12122224) (32122222)
            (12131314) (32131312) (21231313) (41231311) (22113223) (42113221) (11213224)
            (22122313) (42122311) (11222314) (31222312) (12113314) (32113312) (21213313)
            (41213311) (13131133) (33131131) (22231132) (11331133) (31331131) (23122132)
            (12222133) (23131222) (12231223) (32231221) (21331222) (13113133) (33113131)
            (13122223) (33122221) (11313133) (13131313) (33131311) (11322223) (22231312)
            (11331313) (31331311) (23113222) (12213223) (23122312) (12222313) (32222311)
            (21322312) (13113313) (33113311) (22213312) (11313313) (31313311) (14131132)
            (23231131) (12331132) (21431131) (24122131) (13222132) (24131221) (13231222)
            (11422132) (22331221) (11431222) (14113132) (14122222) (12313132) (14131312)
            (12322222) (23231311) (12331312) (21431311) (24113221) (13213222) (24122311)
            (13222312) (11413222) (22322311) (11422312) (14113312) (23213311) (12313312)
            (21413311) (15131131) (13331131) (14222131) (14231221) (12422131) (12431221)
            (15113131) (15122221) (13313131) (15131311) (13322221) (11513131) (13331311)
            (11522221) (14213221) (14222311) (12413221) (12422311) (15113311) (13313311)
            (11513311) (11141134) (31141132) (21132133) (41132131) (21141223) (41141221)
            (11123134) (31123132) (11132224) (31132222) (11141314) (31141312) (21114133)
            (41114131) (21123223) (41123221) (21132313) (41132311) (11114224) (31114222)
            (11123314) (31123312) (21114313) (41114311) (12141133) (32141131) (21241132)
            (22132132) (11232133) (22141222) (11241223) (31241221) (12123133) (32123131)
            (12132223) (32132221) (12141313) (32141311) (21241312) (22114132) (11214133)
            (22123222) (11223223) (22132312) (11232313) (31232311) (12114223) (32114221)
            (12123313) (32123311) (21223312) (22114312) (11214313) (31214311) (13141132)
            (22241131) (11341132) (23132131) (12232132) (23141221) (12241222) (21341221)
            (13123132) (13132222) (11323132) (13141312) (11332222) (22241311) (11341312)
            (23114131) (12214132) (23123221) (12223222) (23132311) (12232312) (21332311)
            (13114222) (13123312) (11314222) (22223311) (11323312) (23114311) (12214312)
            (21314311) (14141131) (12341131) (13232131) (13241221) (11432131) (14123131)
            (14132221) (12323131) (14141311) (12332221) (12341311) (13214131) (13223221)
            (11414131) (13232311) (11423221) (11432311) (14114221) (14123311) (12314221)
            (12323311) (13214311) (11414311) (11151133) (31151131) (21142132) (21151222)
            (11133133) (31133131) (11142223) (31142221) (11151313) (31151311) (21124132)
            (21133222) (21142312) (11115133) (31115131) (11124223) (31124221) (11133313)
            (31133311) (21115222) (21124312) (12151132) (21251131) (22142131) (11242132)
            (22151221) (11251222) (12133132) (12142222) (12151312) (21251311) (22124131)
            (11224132) (22133221) (11233222) (22142311) (11242312) (12115132) (12124222)
            (12133312) (21233311) (22115221) (11215222) (22124311) (11224312) (13151131)
            (12242131) (12251221) (13133131) (13142221) (11333131) (13151311) (11342221)
            (12224131) (12233221) (12242311) (13115131) (13124221) (11315131) (13133311)
            (11324221) (11333311) (12215221) (12224311) (11161132) (21152131) (21161221)
            (11143132) (11152222) (11161312) (21134131) (21143221) (21152311) (11125132)
            (11134222) (11143312) (21116131) (21125221) (21134311) (12161131) (11252131)
            (12143131) (12152221) (12161311) (11234131) (11243221) (11252311) (12125131)
            (12134221) (12143311) (11216131) (11225221) (11234311) (11111236) (31111234)
            (51111232) (21111325) (41111323) (61111321) (11111416) (31111414) (51111412)
            (31211143) (51211141) (12111235) (32111233) (52111231) (21211234) (41211232)
            (22111324) (42111322) (11211325) (31211323) (51211321) (12111415) (32111413)
            (52111411) (21211414) (41211412) (12211144) (32211142) (21311143) (41311141)
            (13111234) (33111232) (22211233) (42211231) (11311234) (31311232) (23111323)
            (43111321) (12211324) (32211322) (21311323) (41311321) (13111414) (33111412)
            (22211413) (42211411) (11311414) (31311412) (13211143) (33211141) (22311142)
            (11411143) (31411141) (14111233) (34111231) (23211232) (12311233) (32311231)
            (21411232) (24111322) (13211323) (33211321) (22311322) (11411323) (31411321)
            (14111413) (34111411) (23211412) (12311413) (32311411) (21411412) (14211142)
            (23311141) (12411142) (21511141) (15111232) (24211231) (13311232) (22411231)
            (11511232) (25111321) (14211322) (23311321) (12411322) (21511321) (15111412)
            (24211411) (13311412) (22411411) (11511412) (15211141) (13411141) (11611141)
            (16111231) (14311231) (12511231) (15211321) (13411321) (11611321) (16111411)
            (14311411) (12511411) (21121144) (41121142) (11112145) (31112143) (51112141)
            (11121235) (31121233) (51121231) (21112234) (41112232) (21121324) (41121322)
            (11112325) (31112323) (51112321) (11121415) (31121413) (51121411) (21112414)
            (41112412) (22121143) (42121141) (11221144) (31221142) (12112144) (32112142)
            (12121234) (32121232) (21221233) (41221231) (22112233) (42112231) (11212234)
            (22121323) (42121321) (11221324) (31221322) (12112324) (32112322) (12121414)
            (32121412) (21221413) (41221411) (22112413) (42112411) (11212414) (31212412)
            (23121142) (12221143) (32221141) (21321142) (13112143) (33112141) (13121233)
            (33121231) (11312143) (22221232) (11321233) (31321231) (23112232) (12212233)
            (23121322) (12221323) (32221321) (21321322) (13112323) (33112321) (13121413)
            (33121411) (11312323) (22221412) (11321413) (31321411) (23112412) (12212413)
            (32212411) (21312412) (24121141) (13221142) (22321141) (11421142) (14112142)
            (14121232) (12312142) (23221231) (12321232) (21421231) (24112231) (13212232)
            (24121321) (13221322) (11412232) (22321321) (11421322) (14112322) (14121412)
            (12312322) (23221411) (12321412) (21421411) (24112411) (13212412) (22312411)
            (11412412) (14221141) (12421141) (15112141) (15121231) (13312141) (13321231)
            (11512141) (11521231) (14212231) (14221321) (12412231) (12421321) (15112321)
            (15121411) (13312321) (13321411) (11512321) (11521411) (14212411) (12412411)
            (21131143) (41131141) (11122144) (31122142) (11131234) (31131232) (21113143)
            (41113141) (21122233) (41122231) (21131323) (41131321) (11113234) (31113232)
            (11122324) (31122322) (11131414) (31131412) (21113323) (41113321) (21122413)
            (41122411) (11113414) (31113412) (22131142) (11231143) (31231141) (12122143)
            (32122141) (12131233) (32131231) (21231232) (22113142) (11213143) (22122232)
            (11222233) (22131322) (11231323) (31231321) (12113233) (32113231) (12122323)
            (32122321) (12131413) (32131411) (21231412) (22113322) (11213323) (22122412)
            (11222413) (31222411) (12113413) (32113411) (21213412) (23131141) (12231142)
            (21331141) (13122142) (13131232) (11322142) (22231231) (11331232) (23113141)
            (12213142) (23122231) (12222232) (23131321) (12231322) (21331321) (13113232)
            (13122322) (11313232) (13131412) (11322322) (22231411) (11331412) (23113321)
            (12213322) (23122411) (12222412) (21322411) (13113412) (22213411) (11313412)
            (13231141) (11431141) (14122141) (14131231) (12322141) (12331231) (13213141)
            (13222231) (11413141) (13231321) (11422231) (11431321) (14113231) (14122321)
            (12313231) (14131411) (12322321) (12331411) (13213321) (13222411) (11413321)
            (11422411) (14113411) (12313411) (21141142) (11132143) (31132141) (11141233)
            (31141231) (21123142) (21132232) (21141322) (11114143) (31114141) (11123233)
            (31123231) (11132323) (31132321) (11141413) (31141411) (21114232) (21123322)
            (21132412) (11114323) (31114321) (11123413) (31123411) (22141141) (11241142)
            (12132142) (12141232) (21241231) (22123141) (11223142) (22132231) (11232232)
            (22141321) (11241322) (12114142) (12123232) (12132322) (12141412) (21241411)
            (22114231) (11214232) (22123321) (11223322) (22132411) (11232412) (12114322)
            (12123412) (21223411) (12241141) (13132141) (13141231) (11332141) (11341231)
            (12223141) (12232231) (12241321) (13114141) (13123231) (11314141) (13132321)
            (11323231) (13141411) (11332321) (11341411) (12214231) (12223321) (12232411)
            (13114321) (13123411) (11314321) (11323411) (21151141) (11142142) (11151232)
            (21133141) (21142231) (21151321) (11124142) (11133232) (11142322) (11151412)
            (21115141) (21124231) (21133321) (21142411) (11115232) (11124322) (11133412)
            (11251141) (12142141) (12151231) (11233141) (11242231) (11251321) (12124141)
            (12133231) (12142321) (12151411) (11215141) (11224231) (11233321) (11242411)
            (12115231) (12124321) (12133411) (11152141) (11161231) (11134141) (11143231)
            (11152321) (11161411) (11116141) (11125231) (11134321) (11143411) (21111244)
            (41111242) (11111335) (31111333) (51111331) (21111424) (41111422) (11111515)
            (31111513) (51111511) (21211153) (41211151) (22111243) (42111241) (11211244)
            (31211242) (12111334) (32111332) (21211333) (41211331) (22111423) (42111421)
            (11211424) (31211422) (12111514) (32111512) (21211513) (41211511) (22211152)
            (11311153) (31311151) (23111242) (12211243) (32211241) (21311242) (13111333)
            (33111331) (22211332) (11311333) (31311331) (23111422) (12211423) (32211421)
            (21311422) (13111513) (33111511) (22211512) (11311513) (31311511) (23211151)
            (12311152) (21411151) (24111241) (13211242) (22311241) (11411242) (14111332)
            (23211331) (12311332) (21411331) (24111421) (13211422) (22311421) (11411422)
            (14111512) (23211511) (12311512) (21411511) (13311151) (11511151) (14211241)
            (12411241) (15111331) (13311331) (11511331) (14211421) (12411421) (15111511)
            (13311511) (11511511) (31121152) (21112153) (41112151) (21121243) (41121241)
            (11112244) (31112242) (11121334) (31121332) (21112333) (41112331) (21121423)
            (41121421) (11112424) (31112422) (11121514) (31121512) (21112513) (41112511)
            (12121153) (32121151) (21221152) (22112152) (11212153) (22121242) (11221243)
            (31221241) (12112243) (32112241) (12121333) (32121331) (21221332) (22112332)
            (11212333) (22121422) (11221423) (31221421) (12112423) (32112421) (12121513)
            (32121511) (21221512) (22112512) (11212513) (31212511) (13121152) (22221151)
            (11321152) (23112151) (12212152) (23121241) (12221242) (21321241) (13112242)
            (13121332) (11312242) (22221331) (11321332) (23112331) (12212332) (23121421)
            (12221422) (21321421) (13112422) (13121512) (11312422) (22221511) (11321512)
            (23112511) (12212512) (21312511) (14121151) (12321151) (13212151) (13221241)
            (11412151) (11421241) (14112241) (14121331) (12312241) (12321331) (13212331)
            (13221421) (11412331) (11421421) (14112421) (14121511) (12312421) (12321511)
            (13212511) (11412511) (11131153) (31131151) (21122152) (21131242) (11113153)
            (31113151) (11122243) (31122241) (11131333) (31131331) (21113242) (21122332)
            (21131422) (11113333) (31113331) (11122423) (31122421) (11131513) (31131511)
            (21113422) (21122512) (12131152) (21231151) (22122151) (11222152) (22131241)
            (11231242) (12113152) (12122242) (12131332) (21231331) (22113241) (11213242)
            (22122331) (11222332) (22131421) (11231422) (12113332) (12122422) (12131512)
            (21231511) (22113421) (11213422) (22122511) (11222512) (13131151) (11331151)
            (12222151) (12231241) (13113151) (13122241) (11313151) (13131331) (11322241)
            (11331331) (12213241) (12222331) (12231421) (13113331) (13122421) (11313331)
            (13131511) (11322421) (11331511) (12213421) (12222511) (11141152) (21132151)
            (21141241) (11123152) (11132242) (11141332) (21114151) (21123241) (21132331)
            (21141421) (11114242) (11123332) (11132422) (11141512) (21114331) (21123421)
            (21132511) (12141151) (11232151) (11241241) (12123151) (12132241) (12141331)
            (11214151) (11223241) (11232331) (11241421) (12114241) (12123331) (12132421)
            (12141511) (11214331) (11223421) (11232511) (11151151) (11133151) (11142241)
            (11151331) (11115151) (11124241) (11133331) (11142421) (11151511) (11111254)
            (31111252) (21111343) (41111341) (11111434) (31111432) (21111523) (41111521)
            (11111614) (31111612) (31211161) (12111253) (32111251) (21211252) (22111342)
            (11211343) (31211341) (12111433) (32111431) (21211432) (22111522) (11211523)
            (31211521) (12111613) (32111611) (21211612) (12211162) (21311161) (13111252)
            (22211251) (11311252) (23111341) (12211342) (21311341) (13111432) (22211431)
            (11311432) (23111521) (12211522) (21311521) (13111612) (22211611) (11311612)
            (13211161) (11411161) (14111251) (12311251) (13211341) (11411341) (14111431)
            (12311431) (13211521) (11411521) (14111611) (12311611) (21121162) (11112163)
            (31112161) (11121253) (31121251) (21112252) (21121342) (11112343) (31112341)
            (11121433) (31121431) (21112432) (21121522) (11112523) (31112521) (11121613)
            (31121611) (22121161) (11221162) (12112162) (12121252) (21221251) (22112251)
            (11212252) (22121341) (11221342) (12112342) (12121432) (21221431) (22112431)
            (11212432) (22121521) (11221522) (12112522) (12121612) (21221611) (12221161)
            (13112161) (13121251) (11312161) (11321251) (32121115) (52121113) (21221116)
            (41221114) (61221112) (22112116) (42112114) (31212115) (51212113) (13121116)
            (33121114) (22221115) (42221113) (11321116) (31321114) (51321112) (23112115)
            (43112113) (12212116) (32212114) (52212112) (21312115) (41312113) (61312111)
            (14121115) (34121113) (23221114) (43221112) (12321115) (32321113) (52321111)
            (21421114) (41421112) (24112114) (13212115) (33212113) (22312114) (42312112)
            (11412115) (31412113) (51412111) (15121114) (24221113) (13321114) (33321112)
            (22421113) (42421111) (11521114) (31521112) (25112113) (14212114) (34212112)
            (23312113) (43312111) (12412114) (32412112) (21512113) (41512111) (16121113)
            (25221112) (14321113) (34321111) (23421112) (12521113) (32521111) (15212113)
            (24312112) (13412113) (33412111) (22512112) (11612113) (31612111) (31131115)
            (51131113) (21122116) (41122114) (61122112) (31113115) (51113113) (12131116)
            (32131114) (52131112) (21231115) (41231113) (61231111) (22122115) (42122113)
            (11222116) (31222114) (51222112) (12113116) (32113114) (52113112) (21213115)
            (41213113) (61213111) (13131115) (33131113) (22231114) (42231112) (11331115)
            (31331113) (51331111) (23122114) (43122112) (12222115) (32222113) (52222111)
            (21322114) (41322112) (13113115) (33113113) (22213114) (42213112) (11313115)
            (31313113) (51313111) (14131114) (34131112) (23231113) (43231111) (12331114)
            (32331112) (21431113) (41431111) (24122113) (13222114) (33222112) (22322113)
            (42322111) (11422114) (31422112) (14113114) (34113112) (23213113) (43213111)
            (12313114) (32313112) (21413113) (41413111) (15131113) (24231112) (13331113)
            (33331111) (22431112) (25122112) (14222113) (34222111) (23322112) (12422113)
            (32422111) (21522112) (15113113) (24213112) (13313113) (33313111) (22413112)
            (11513113) (31513111) (16131112) (25231111) (14331112) (23431111) (15222112)
            (24322111) (13422112) (22522111) (16113112) (25213111) (14313112) (23413111)
            (12513112) (21613111) (11141116) (31141114) (51141112) (21132115) (41132113)
            (61132111) (11123116) (31123114) (51123112) (21114115) (41114113) (61114111)
            (12141115) (32141113) (52141111) (21241114) (41241112) (22132114) (42132112)
            (11232115) (31232113) (51232111) (12123115) (32123113) (52123111) (21223114)
            (41223112) (22114114) (42114112) (11214115) (31214113) (51214111) (13141114)
            (33141112) (22241113) (42241111) (11341114) (31341112) (23132113) (43132111)
            (12232114) (32232112) (21332113) (41332111) (13123114) (33123112) (22223113)
            (42223111) (11323114) (31323112) (23114113) (43114111) (12214114) (32214112)
            (21314113) (41314111) (14141113) (34141111) (23241112) (12341113) (32341111)
            (24132112) (13232113) (33232111) (22332112) (11432113) (31432111) (14123113)
            (34123111) (23223112) (12323113) (32323111) (21423112) (24114112) (13214113)
            (33214111) (22314112) (11414113) (31414111) (15141112) (24241111) (13341112)
            (25132111) (14232112) (23332111) (12432112) (15123112) (24223111) (13323112)
            (22423111) (11523112) (25114111) (14214112) (23314111) (12414112) (21514111)
            (16141111) (14341111) (15232111) (13432111) (16123111) (14323111) (12523111)
            (15214111) (13414111) (11614111) (11151115) (31151113) (51151111) (21142114)
            (41142112) (11133115) (31133113) (51133111) (21124114) (41124112) (11115115)
            (31115113) (51115111) (12151114) (32151112) (21251113) (41251111) (22142113)
            (42142111) (11242114) (31242112) (12133114) (32133112) (21233113) (41233111)
            (22124113) (42124111) (11224114) (31224112) (12115114) (32115112) (21215113)
            (41215111) (13151113) (33151111) (22251112) (23142112) (12242113) (32242111)
            (21342112) (13133113) (33133111) (22233112) (11333113) (31333111) (23124112)
            (12224113) (32224111) (21324112) (13115113) (33115111) (22215112) (11315113)
            (31315111) (14151112) (23251111) (24142111) (13242112) (22342111) (14133112)
            (23233111) (12333112) (21433111) (24124111) (13224112) (22324111) (11424112)
            (14115112) (23215111) (12315112) (21415111) (15151111) (14242111) (15133111)
            (13333111) (14224111) (12424111) (15115111) (13315111) (11515111) (11161114)
            (31161112) (21152113) (41152111) (11143114) (31143112) (21134113) (41134111)
            (11125114) (31125112) (21116113) (41116111) (12161113) (32161111) (22152112)
            (11252113) (31252111) (12143113) (32143111) (21243112) (22134112) (11234113)
            (31234111) (12125113) (32125111) (21225112) (22116112) (11216113) (31216111)
            (13161112) (23152111) (12252112) (13143112) (22243111) (11343112) (23134111)
            (12234112) (21334111) (13125112) (22225111) (11325112) (23116111) (12216112)
            (21316111) (14161111) (13252111) (14143111) (12343111) (13234111) (11434111)
            (14125111) (12325111) (13216111) (11416111) (31111216) (51111214) (31211125)
            (51211123) (32111215) (52111213) (21211216) (41211214) (61211212) (12211126)
            (32211124) (52211122) (21311125) (41311123) (61311121) (13111216) (33111214)
            (22211215) (42211213) (11311216) (31311214) (51311212) (13211125) (33211123)
            (22311124) (42311122) (11411125) (31411123) (51411121) (14111215) (34111213)
            (23211214) (43211212) (12311215) (32311213) (52311211) (21411214) (41411212)
            (14211124) (34211122) (23311123) (43311121) (12411124) (32411122) (21511123)
            (41511121) (15111214) (24211213) (13311214) (33311212) (22411213) (42411211)
            (11511214) (31511212) (15211123) (24311122) (13411123) (33411121) (22511122)
            (11611123) (31611121) (16111213) (25211212) (14311213) (34311211) (23411212)
            (12511213) (32511211) (21611212) (21121126) (41121124) (61121122) (31112125)
            (51112123) (31121215) (51121213) (21112216) (41112214) (61112212) (22121125)
            (42121123) (11221126) (31221124) (51221122) (12112126) (32112124) (52112122)
            (12121216) (32121214) (52121212) (21221215) (41221213) (61221211) (22112215)
            (42112213) (11212216) (31212214) (51212212) (23121124) (43121122) (12221125)
            (32221123) (52221121) (21321124) (41321122) (13112125) (33112123) (13121215)
            (33121213) (11312125) (22221214) (42221212) (11321215) (31321213) (51321211)
            (23112214) (43112212) (12212215) (32212213) (52212211) (21312214) (41312212)
            (24121123) (13221124) (33221122) (22321123) (42321121) (11421124) (31421122)
            (14112124) (34112122) (14121214) (34121212) (12312124) (23221213) (43221211)
            (12321214) (32321212) (21421213) (41421211) (24112213) (13212214) (33212212)
            (22312213) (42312211) (11412214) (31412212) (25121122) (14221123) (34221121)
            (23321122) (12421123) (32421121) (21521122) (15112123) (15121213) (13312123)
            (24221212) (13321213) (33321211) (11512123) (22421212) (11521213) (31521211)
            (25112212) (14212213) (34212211) (23312212) (12412213) (32412211) (21512212)
            (15221122) (24321121) (13421122) (22521121) (16112122) (16121212) (14312122)
            (25221211) (14321212) (12512122) (23421211) (12521212) (15212212) (24312211)
            (13412212) (22512211) (11612212) (21131125) (41131123) (61131121) (11122126)
            (31122124) (51122122) (11131216) (31131214) (51131212) (21113125) (41113123)
            (61113121) (21122215) (41122213) (61122211) (11113216) (31113214) (51113212)
            (22131124) (42131122) (11231125) (31231123) (51231121) (12122125) (32122123)
            (52122121) (12131215) (32131213) (52131211) (21231214) (41231212) (22113124)
            (42113122) (11213125) (22122214) (42122212) (11222215) (31222213) (51222211)
            (12113215) (32113213) (52113211) (21213214) (41213212) (23131123) (43131121)
            (12231124) (32231122) (21331123) (41331121) (13122124) (33122122) (13131214)
            (33131212) (11322124) (22231213) (42231211) (11331214) (31331212) (23113123)
            (43113121) (12213124) (23122213) (43122211) (12222214) (32222212) (21322213)
            (41322211) (13113214) (33113212) (22213213) (42213211) (11313214) (31313212)
            (24131122) (13231123) (33231121) (22331122) (11431123) (31431121) (14122123)
            (34122121) (14131213) (34131211) (12322123) (23231212) (12331213) (32331211)
            (21431212) (24113122) (13213123) (24122212) (13222213) (33222211) (11413123)
            (22322212) (11422213) (31422211) (14113213) (34113211) (23213212) (12313213)
            (32313211) (21413212) (25131121) (14231122) (23331121) (12431122) (15122122)
            (15131212) (13322122) (24231211) (13331212) (11522122) (22431211) (25113121)
            (14213122) (25122211) (14222212) (12413122) (23322211) (12422212) (21522211)
            (15113212) (24213211) (13313212) (22413211) (11513212) (15231121) (13431121)
            (16122121) (16131211) (14322121) (14331211) (12522121) (15213121) (15222211)
            (13413121) (13422211) (11613121) (16113211) (14313211) (12513211) (21141124)
            (41141122) (11132125) (31132123) (51132121) (11141215) (31141213) (51141211)
            (21123124) (41123122) (21132214) (41132212) (11114125) (31114123) (51114121)
            (11123215) (31123213) (51123211) (21114214) (41114212) (22141123) (42141121)
            (11241124) (31241122) (12132124) (32132122) (12141214) (32141212) (21241213)
            (41241211) (22123123) (42123121) (11223124) (22132213) (42132211) (11232214)
            (31232212) (12114124) (32114122) (12123214) (32123212) (21223213) (41223211)
            (22114213) (42114211) (11214214) (31214212) (23141122) (12241123) (32241121)
            (21341122) (13132123) (33132121) (13141213) (33141211) (11332123) (22241212)
            (11341213) (31341211) (23123122) (12223123) (23132212) (12232213) (32232211)
            (21332212) (13114123) (33114121) (13123213) (33123211) (11314123) (22223212)
            (11323213) (31323211) (23114212) (12214213) (32214211) (21314212) (24141121)
            (13241122) (22341121) (14132122) (14141212) (12332122) (23241211) (12341212)
            (24123121) (13223122) (24132211) (13232212) (11423122) (22332211) (11432212)
            (14114122) (14123212) (12314122) (23223211) (12323212) (21423211) (24114211)
            (13214212) (22314211) (11414212) (14241121) (15132121) (15141211) (13332121)
            (13341211) (14223121) (14232211) (12423121) (12432211) (15114121) (15123211)
            (13314121) (13323211) (11514121) (11523211) (14214211) (12414211) (21151123)
            (41151121) (11142124) (31142122) (11151214) (31151212) (21133123) (41133121)
            (21142213) (41142211) (11124124) (31124122) (11133214) (31133212) (21115123)
            (41115121) (21124213) (41124211) (11115214) (31115212) (22151122) (11251123)
            (31251121) (12142123) (32142121) (12151213) (32151211) (21251212) (22133122)
            (11233123) (22142212) (11242213) (31242211) (12124123) (32124121) (12133213)
            (32133211) (21233212) (22115122) (11215123) (22124212) (11224213) (31224211)
            (12115213) (32115211) (21215212) (23151121) (12251122) (13142122) (13151212)
            (11342122) (22251211) (23133121) (12233122) (23142211) (12242212) (21342211)
            (13124122) (13133212) (11324122) (22233211) (11333212) (23115121) (12215122)
            (23124211) (12224212) (21324211) (13115212) (22215211) (11315212) (13251121)
            (14142121) (14151211) (12342121) (13233121) (13242211) (11433121) (14124121)
            (14133211) (12324121) (12333211) (13215121) (13224211) (11415121) (11424211)
            (14115211) (12315211) (21161122) (11152123) (31152121) (11161213) (31161211)
            (21143122) (21152212) (11134123) (31134121) (11143213) (31143211) (21125122)
            (21134212) (11116123) (31116121) (11125213) (31125211) (22161121) (12152122)
            (12161212) (22143121) (11243122) (22152211) (11252212) (12134122) (12143212)
            (21243211) (22125121) (11225122) (22134211) (11234212) (12116122) (12125212)
            (21225211) (13152121) (13161211) (12243121) (12252211) (13134121) (13143211)
            (11334121) (11343211) (12225121) (12234211) (13116121) (13125211) (11316121)
            (11325211) (21111226) (41111224) (61111222) (31111315) (51111313) (21211135)
            (41211133) (61211131) (22111225) (42111223) (11211226) (31211224) (51211222)
            (12111316) (32111314) (52111312) (21211315) (41211313) (61211311) (22211134)
            (42211132) (11311135) (31311133) (51311131) (23111224) (43111222) (12211225)
            (32211223) (52211221) (21311224) (41311222) (13111315) (33111313) (22211314)
            (42211312) (11311315) (31311313) (51311311) (23211133) (43211131) (12311134)
            (32311132) (21411133) (41411131) (24111223) (13211224) (33211222) (22311223)
            (42311221) (11411224) (31411222) (14111314) (34111312) (23211313) (43211311)
            (12311314) (32311312) (21411313) (41411311) (24211132) (13311133) (33311131)
            (22411132) (11511133) (31511131) (25111222) (14211223) (34211221) (23311222)
            (12411223) (32411221) (21511222) (15111313) (24211312) (13311313) (33311311)
            (22411312) (11511313) (31511311) (25211131) (14311132) (23411131) (12511132)
            (21611131) (15211222) (24311221) (13411222) (22511221) (11611222) (16111312)
            (25211311) (14311312) (23411311) (12511312) (21611311) (31121134) (51121132)
            (21112135) (41112133) (61112131) (21121225) (41121223) (61121221) (11112226)
            (31112224) (51112222) (11121316) (31121314) (51121312) (21112315) (41112313)
            (61112311) (12121135) (32121133) (52121131) (21221134) (41221132) (22112134)
            (42112132) (11212135) (22121224) (42121222) (11221225) (31221223) (51221221)
            (12112225) (32112223) (52112221) (12121315) (32121313) (52121311) (21221314)
            (41221312) (22112314) (42112312) (11212315) (31212313) (51212311) (13121134)
            (33121132) (22221133) (42221131) (11321134) (31321132) (23112133) (43112131)
            (12212134) (23121223) (43121221) (12221224) (32221222) (21321223) (41321221)
            (13112224) (33112222) (13121314) (33121312) (11312224) (22221313) (42221311)
            (11321314) (31321312) (23112313) (43112311) (12212314) (32212312) (21312313)
            (41312311) (14121133) (34121131) (23221132) (12321133) (32321131) (21421132)
            (24112132) (13212133) (24121222) (13221223) (33221221) (11412133) (22321222)
            (11421223) (31421221) (14112223) (34112221) (14121313) (34121311) (12312223)
            (23221312) (12321313) (32321311) (21421312) (24112312) (13212313) (33212311)
            (22312312) (11412313) (31412311) (15121132) (24221131) (13321132) (22421131)
        ] [  % Odd parity
            (22121116) (42121114) (31221115) (51221113) (32112115) (52112113) (21212116)
            (41212114) (61212112) (23121115) (43121113) (12221116) (32221114) (52221112)
            (21321115) (41321113) (61321111) (13112116) (33112114) (22212115) (42212113)
            (11312116) (31312114) (51312112) (24121114) (13221115) (33221113) (22321114)
            (42321112) (11421115) (31421113) (51421111) (14112115) (34112113) (23212114)
            (43212112) (12312115) (32312113) (52312111) (21412114) (41412112) (25121113)
            (14221114) (34221112) (23321113) (43321111) (12421114) (32421112) (21521113)
            (41521111) (15112114) (24212113) (13312114) (33312112) (22412113) (42412111)
            (11512114) (31512112) (15221113) (24321112) (13421113) (33421111) (22521112)
            (16112113) (25212112) (14312113) (34312111) (23412112) (12512113) (32512111)
            (21612112) (21131116) (41131114) (61131112) (31122115) (51122113) (21113116)
            (41113114) (61113112) (22131115) (42131113) (11231116) (31231114) (51231112)
            (12122116) (32122114) (52122112) (21222115) (41222113) (61222111) (22113115)
            (42113113) (11213116) (31213114) (51213112) (23131114) (43131112) (12231115)
            (32231113) (52231111) (21331114) (41331112) (13122115) (33122113) (22222114)
            (42222112) (11322115) (31322113) (51322111) (23113114) (43113112) (12213115)
            (32213113) (52213111) (21313114) (41313112) (24131113) (13231114) (33231112)
            (22331113) (42331111) (11431114) (31431112) (14122114) (34122112) (23222113)
            (43222111) (12322114) (32322112) (21422113) (41422111) (24113113) (13213114)
            (33213112) (22313113) (42313111) (11413114) (31413112) (25131112) (14231113)
            (34231111) (23331112) (12431113) (32431111) (15122113) (24222112) (13322113)
            (33322111) (22422112) (11522113) (31522111) (25113112) (14213113) (34213111)
            (23313112) (12413113) (32413111) (21513112) (15231112) (24331111) (13431112)
            (16122112) (25222111) (14322112) (23422111) (12522112) (15213112) (24313111)
            (13413112) (22513111) (11613112) (21141115) (41141113) (61141111) (11132116)
            (31132114) (51132112) (21123115) (41123113) (61123111) (11114116) (31114114)
            (51114112) (22141114) (42141112) (11241115) (31241113) (51241111) (12132115)
            (32132113) (52132111) (21232114) (41232112) (22123114) (42123112) (11223115)
            (31223113) (51223111) (12114115) (32114113) (52114111) (21214114) (41214112)
            (23141113) (43141111) (12241114) (32241112) (21341113) (41341111) (13132114)
            (33132112) (22232113) (42232111) (11332114) (31332112) (23123113) (43123111)
            (12223114) (32223112) (21323113) (41323111) (13114114) (33114112) (22214113)
            (42214111) (11314114) (31314112) (24141112) (13241113) (33241111) (22341112)
            (14132113) (34132111) (23232112) (12332113) (32332111) (21432112) (24123112)
            (13223113) (33223111) (22323112) (11423113) (31423111) (14114113) (34114111)
            (23214112) (12314113) (32314111) (21414112) (25141111) (14241112) (23341111)
            (15132112) (24232111) (13332112) (22432111) (25123111) (14223112) (23323111)
            (12423112) (21523111) (15114112) (24214111) (13314112) (22414111) (11514112)
            (15241111) (16132111) (14332111) (15223111) (13423111) (16114111) (14314111)
            (12514111) (21151114) (41151112) (11142115) (31142113) (51142111) (21133114)
            (41133112) (11124115) (31124113) (51124111) (21115114) (41115112) (22151113)
            (42151111) (11251114) (31251112) (12142114) (32142112) (21242113) (41242111)
            (22133113) (42133111) (11233114) (31233112) (12124114) (32124112) (21224113)
            (41224111) (22115113) (42115111) (11215114) (31215112) (23151112) (12251113)
            (32251111) (13142113) (33142111) (22242112) (11342113) (31342111) (23133112)
            (12233113) (32233111) (21333112) (13124113) (33124111) (22224112) (11324113)
            (31324111) (23115112) (12215113) (32215111) (21315112) (24151111) (13251112)
            (14142112) (23242111) (12342112) (24133111) (13233112) (22333111) (11433112)
            (14124112) (23224111) (12324112) (21424111) (24115111) (13215112) (22315111)
            (11415112) (14251111) (15142111) (13342111) (14233111) (12433111) (15124111)
            (13324111) (11524111) (14215111) (12415111) (21161113) (41161111) (11152114)
            (31152112) (21143113) (41143111) (11134114) (31134112) (21125113) (41125111)
            (11116114) (31116112) (22161112) (12152113) (32152111) (21252112) (22143112)
            (11243113) (31243111) (12134113) (32134111) (21234112) (22125112) (11225113)
            (31225111) (12116113) (32116111) (21216112) (23161111) (13152112) (22252111)
            (23143111) (12243112) (21343111) (13134112) (22234111) (11334112) (23125111)
            (12225112) (21325111) (13116112) (22216111) (11316112) (14152111) (13243111)
            (14134111) (12334111) (13225111) (11425111) (14116111) (12316111) (41111215)
            (61111213) (21211126) (41211124) (61211122) (22111216) (42111214) (31211215)
            (51211213) (22211125) (42211123) (11311126) (31311124) (51311122) (23111215)
            (43111213) (12211216) (32211214) (52211212) (21311215) (41311213) (61311211)
            (23211124) (43211122) (12311125) (32311123) (52311121) (21411124) (41411122)
            (24111214) (13211215) (33211213) (22311214) (42311212) (11411215) (31411213)
            (51411211) (24211123) (13311124) (33311122) (22411123) (42411121) (11511124)
            (31511122) (25111213) (14211214) (34211212) (23311213) (43311211) (12411214)
            (32411212) (21511213) (41511211) (25211122) (14311123) (34311121) (23411122)
            (12511123) (32511121) (21611122) (15211213) (24311212) (13411213) (33411211)
            (22511212) (11611213) (31611211) (31121125) (51121123) (21112126) (41112124)
            (61112122) (21121216) (41121214) (61121212) (31112215) (51112213) (12121126)
            (32121124) (52121122) (21221125) (41221123) (61221121) (22112125) (42112123)
            (11212126) (22121215) (42121213) (11221216) (31221214) (51221212) (12112216)
            (32112214) (52112212) (21212215) (41212213) (61212211) (13121125) (33121123)
            (22221124) (42221122) (11321125) (31321123) (51321121) (23112124) (43112122)
            (12212125) (23121214) (43121212) (12221215) (32221213) (52221211) (21321214)
            (41321212) (13112215) (33112213) (22212214) (42212212) (11312215) (31312213)
            (51312211) (14121124) (34121122) (23221123) (43221121) (12321124) (32321122)
            (21421123) (41421121) (24112123) (13212124) (24121213) (13221214) (33221212)
            (11412124) (22321213) (42321211) (11421214) (31421212) (14112214) (34112212)
            (23212213) (43212211) (12312214) (32312212) (21412213) (41412211) (15121123)
            (24221122) (13321123) (33321121) (22421122) (11521123) (31521121) (25112122)
            (14212123) (25121212) (14221213) (34221211) (12412123) (23321212) (12421213)
            (32421211) (21521212) (15112213) (24212212) (13312213) (33312211) (22412212)
            (11512213) (31512211) (16121122) (25221121) (14321122) (23421121) (12521122)
            (15212122) (15221212) (13412122) (24321211) (13421212) (11612122) (22521211)
            (16112212) (25212211) (14312212) (23412211) (12512212) (21612211) (11131126)
            (31131124) (51131122) (21122125) (41122123) (61122121) (21131215) (41131213)
            (61131211) (11113126) (31113124) (51113122) (11122216) (31122214) (51122212)
            (21113215) (41113213) (61113211) (12131125) (32131123) (52131121) (21231124)
            (41231122) (22122124) (42122122) (11222125) (22131214) (42131212) (11231215)
            (31231213) (51231211) (12113125) (32113123) (52113121) (12122215) (32122213)
            (52122211) (21222214) (41222212) (22113214) (42113212) (11213215) (31213213)
            (51213211) (13131124) (33131122) (22231123) (42231121) (11331124) (31331122)
            (23122123) (43122121) (12222124) (23131213) (43131211) (12231214) (32231212)
            (21331213) (41331211) (13113124) (33113122) (13122214) (33122212) (11313124)
            (22222213) (42222211) (11322214) (31322212) (23113213) (43113211) (12213214)
            (32213212) (21313213) (41313211) (14131123) (34131121) (23231122) (12331123)
            (32331121) (21431122) (24122122) (13222123) (24131212) (13231213) (33231211)
            (11422123) (22331212) (11431213) (31431211) (14113123) (34113121) (14122213)
            (34122211) (12313123) (23222212) (12322213) (32322211) (21422212) (24113212)
            (13213213) (33213211) (22313212) (11413213) (31413211) (15131122) (24231121)
            (13331122) (22431121) (25122121) (14222122) (25131211) (14231212) (12422122)
            (23331211) (12431212) (15113122) (15122212) (13313122) (24222211) (13322212)
            (11513122) (22422211) (11522212) (25113211) (14213212) (23313211) (12413212)
            (21513211) (16131121) (14331121) (15222121) (15231211) (13422121) (13431211)
            (16113121) (16122211) (14313121) (14322211) (12513121) (12522211) (15213211)
            (13413211) (11613211) (11141125) (31141123) (51141121) (21132124) (41132122)
            (21141214) (41141212) (11123125) (31123123) (51123121) (11132215) (31132213)
            (51132211) (21114124) (41114122) (21123214) (41123212) (11114215) (31114213)
            (51114211) (12141124) (32141122) (21241123) (41241121) (22132123) (42132121)
            (11232124) (22141213) (42141211) (11241214) (31241212) (12123124) (32123122)
            (12132214) (32132212) (21232213) (41232211) (22114123) (42114121) (11214124)
            (22123213) (42123211) (11223214) (31223212) (12114214) (32114212) (21214213)
            (41214211) (13141123) (33141121) (22241122) (11341123) (31341121) (23132122)
            (12232123) (23141212) (12241213) (32241211) (21341212) (13123123) (33123121)
            (13132213) (33132211) (11323123) (22232212) (11332213) (31332211) (23114122)
            (12214123) (23123212) (12223213) (32223211) (21323212) (13114213) (33114211)
            (22214212) (11314213) (31314211) (14141122) (23241121) (12341122) (24132121)
            (13232122) (24141211) (13241212) (11432122) (22341211) (14123122) (14132212)
            (12323122) (23232211) (12332212) (21432211) (24114121) (13214122) (24123211)
            (13223212) (11414122) (22323211) (11423212) (14114212) (23214211) (12314212)
            (21414211) (15141121) (13341121) (14232121) (14241211) (12432121) (15123121)
            (15132211) (13323121) (13332211) (11523121) (14214121) (14223211) (12414121)
            (12423211) (15114211) (13314211) (11514211) (11151124) (31151122) (21142123)
            (41142121) (21151213) (41151211) (11133124) (31133122) (11142214) (31142212)
            (21124123) (41124121) (21133213) (41133211) (11115124) (31115122) (11124214)
            (31124212) (21115213) (41115211) (12151123) (32151121) (21251122) (22142122)
            (11242123) (22151212) (11251213) (31251211) (12133123) (32133121) (12142213)
            (32142211) (21242212) (22124122) (11224123) (22133212) (11233213) (31233211)
            (12115123) (32115121) (12124213) (32124211) (21224212) (22115212) (11215213)
            (31215211) (13151122) (22251121) (23142121) (12242122) (23151211) (12251212)
            (13133122) (13142212) (11333122) (22242211) (11342212) (23124121) (12224122)
            (23133211) (12233212) (21333211) (13115122) (13124212) (11315122) (22224211)
            (11324212) (23115211) (12215212) (21315211) (14151121) (13242121) (13251211)
            (14133121) (14142211) (12333121) (12342211) (13224121) (13233211) (11424121)
            (11433211) (14115121) (14124211) (12315121) (12324211) (13215211) (11415211)
            (11161123) (31161121) (21152122) (21161212) (11143123) (31143121) (11152213)
            (31152211) (21134122) (21143212) (11125123) (31125121) (11134213) (31134211)
            (21116122) (21125212) (12161122) (22152121) (11252122) (22161211) (12143122)
            (12152212) (21252211) (22134121) (11234122) (22143211) (11243212) (12125122)
            (12134212) (21234211) (22116121) (11216122) (22125211) (11225212) (13161121)
            (12252121) (13143121) (13152211) (11343121) (12234121) (12243211) (13125121)
            (13134211) (11325121) (11334211) (12216121) (12225211) (31111225) (51111223)
            (21111316) (41111314) (61111312) (31211134) (51211132) (12111226) (32111224)
            (52111222) (21211225) (41211223) (61211221) (22111315) (42111313) (11211316)
            (31211314) (51211312) (12211135) (32211133) (52211131) (21311134) (41311132)
            (13111225) (33111223) (22211224) (42211222) (11311225) (31311223) (51311221)
            (23111314) (43111312) (12211315) (32211313) (52211311) (21311314) (41311312)
            (13211134) (33211132) (22311133) (42311131) (11411134) (31411132) (14111224)
            (34111222) (23211223) (43211221) (12311224) (32311222) (21411223) (41411221)
            (24111313) (13211314) (33211312) (22311313) (42311311) (11411314) (31411312)
            (14211133) (34211131) (23311132) (12411133) (32411131) (21511132) (15111223)
            (24211222) (13311223) (33311221) (22411222) (11511223) (31511221) (25111312)
            (14211313) (34211311) (23311312) (12411313) (32411311) (21511312) (15211132)
            (24311131) (13411132) (22511131) (11611132) (16111222) (25211221) (14311222)
            (23411221) (12511222) (21611221) (15211312) (24311311) (13411312) (22511311)
            (11611312) (21121135) (41121133) (61121131) (11112136) (31112134) (51112132)
            (11121226) (31121224) (51121222) (21112225) (41112223) (61112221) (21121315)
            (41121313) (61121311) (11112316) (31112314) (51112312) (22121134) (42121132)
            (11221135) (31221133) (51221131) (12112135) (32112133) (52112131) (12121225)
            (32121223) (52121221) (21221224) (41221222) (22112224) (42112222) (11212225)
            (22121314) (42121312) (11221315) (31221313) (51221311) (12112315) (32112313)
            (52112311) (21212314) (41212312) (23121133) (43121131) (12221134) (32221132)
            (21321133) (41321131) (13112134) (33112132) (13121224) (33121222) (11312134)
            (22221223) (42221221) (11321224) (31321222) (23112223) (43112221) (12212224)
            (23121313) (43121311) (12221314) (32221312) (21321313) (41321311) (13112314)
            (33112312) (22212313) (42212311) (11312314) (31312312) (24121132) (13221133)
            (33221131) (22321132) (11421133) (31421131) (14112133) (34112131) (14121223)
            (34121221) (12312133) (23221222) (12321223) (32321221) (21421222) (24112222)
            (13212223) (24121312) (13221313) (33221311) (11412223) (22321312) (11421313)
            (31421311) (14112313) (34112311) (23212312) (12312313) (32312311) (21412312)
            (25121131) (14221132) (23321131) (12421132) (21521131) (15112132) (15121222)
            (13312132) (24221221) (13321222) (11512132) (22421221) (11521222) (25112221)
            (14212222) (25121311) (14221312) (12412222) (23321311) (12421312) (21521311)
            (15112312) (24212311) (13312312) (22412311) (11512312) (15221131) (13421131)
            (16112131) (16121221) (14312131) (14321221) (12512131) (12521221) (15212221)
            (15221311) (13412221) (13421311) (11612221) (16112311) (14312311) (12512311)
            (21131134) (41131132) (11122135) (31122133) (51122131) (11131225) (31131223)
            (51131221) (21113134) (41113132) (21122224) (41122222) (21131314) (41131312)
            (11113225) (31113223) (51113221) (11122315) (31122313) (51122311) (21113314)
            (41113312) (22131133) (42131131) (11231134) (31231132) (12122134) (32122132)
            (12131224) (32131222) (21231223) (41231221) (22113133) (42113131) (11213134)
            (22122223) (42122221) (11222224) (22131313) (42131311) (11231314) (31231312)
            (12113224) (32113222) (12122314) (32122312) (21222313) (41222311) (22113313)
            (42113311) (11213314) (31213312) (23131132) (12231133) (32231131) (21331132)
            (13122133) (33122131) (13131223) (33131221) (11322133) (22231222) (11331223)
            (31331221) (23113132) (12213133) (23122222) (12222223) (23131312) (12231313)
            (32231311) (21331312) (13113223) (33113221) (13122313) (33122311) (11313223)
            (22222312) (11322313) (31322311) (23113312) (12213313) (32213311) (21313312)
            (24131131) (13231132) (22331131) (11431132) (14122132) (14131222) (12322132)
            (23231221) (12331222) (21431221) (24113131) (13213132) (24122221) (13222222)
            (24131311) (11413132) (13231312) (11422222) (22331311) (11431312) (14113222)
            (14122312) (12313222) (23222311) (12322312) (21422311) (24113311) (13213312)
            (22313311) (11413312) (14231131) (12431131) (15122131) (15131221) (13322131)
            (13331221) (11522131) (14213131) (14222221) (12413131) (14231311) (12422221)
            (12431311) (15113221) (15122311) (13313221) (13322311) (11513221) (11522311)
            (14213311) (12413311) (21141133) (41141131) (11132134) (31132132) (11141224)
            (31141222) (21123133) (41123131) (21132223) (41132221) (21141313) (41141311)
            (11114134) (31114132) (11123224) (31123222) (11132314) (31132312) (21114223)
            (41114221) (21123313) (41123311) (11114314) (31114312) (22141132) (11241133)
            (31241131) (12132133) (32132131) (12141223) (32141221) (21241222) (22123132)
            (11223133) (22132222) (11232223) (22141312) (11241313) (31241311) (12114133)
            (32114131) (12123223) (32123221) (12132313) (32132311) (21232312) (22114222)
            (11214223) (22123312) (11223313) (31223311) (12114313) (32114311) (21214312)
            (23141131) (12241132) (21341131) (13132132) (13141222) (11332132) (22241221)
            (11341222) (23123131) (12223132) (23132221) (12232222) (23141311) (12241312)
            (21341311) (13114132) (13123222) (11314132) (13132312) (11323222) (22232311)
            (11332312) (23114221) (12214222) (23123311) (12223312) (21323311) (13114312)
            (22214311) (11314312) (13241131) (14132131) (14141221) (12332131) (12341221)
            (13223131) (13232221) (11423131) (13241311) (11432221) (14114131) (14123221)
            (12314131) (14132311) (12323221) (12332311) (13214221) (13223311) (11414221)
            (11423311) (14114311) (12314311) (21151132) (11142133) (31142131) (11151223)
            (31151221) (21133132) (21142222) (21151312) (11124133) (31124131) (11133223)
            (31133221) (11142313) (31142311) (21115132) (21124222) (21133312) (11115223)
            (31115221) (11124313) (31124311) (22151131) (11251132) (12142132) (12151222)
            (21251221) (22133131) (11233132) (22142221) (11242222) (22151311) (11251312)
            (12124132) (12133222) (12142312) (21242311) (22115131) (11215132) (22124221)
            (11224222) (22133311) (11233312) (12115222) (12124312) (21224311) (12251131)
            (13142131) (13151221) (11342131) (12233131) (12242221) (12251311) (13124131)
            (13133221) (11324131) (13142311) (11333221) (11342311) (12215131) (12224221)
            (12233311) (13115221) (13124311) (11315221) (11324311) (21161131) (11152132)
            (11161222) (21143131) (21152221) (21161311) (11134132) (11143222) (11152312)
            (21125131) (21134221) (21143311) (11116132) (11125222) (11134312) (12152131)
            (12161221) (11243131) (11252221) (12134131) (12143221) (12152311) (11225131)
            (11234221) (11243311) (12116131) (12125221) (12134311) (21111235) (41111233)
            (61111231) (11111326) (31111324) (51111322) (21111415) (41111413) (61111411)
            (21211144) (41211142) (22111234) (42111232) (11211235) (31211233) (51211231)
            (12111325) (32111323) (52111321) (21211324) (41211322) (22111414) (42111412)
            (11211415) (31211413) (51211411) (22211143) (42211141) (11311144) (31311142)
            (23111233) (43111231) (12211234) (32211232) (21311233) (41311231) (13111324)
            (33111322) (22211323) (42211321) (11311324) (31311322) (23111413) (43111411)
            (12211414) (32211412) (21311413) (41311411) (23211142) (12311143) (32311141)
            (21411142) (24111232) (13211233) (33211231) (22311232) (11411233) (31411231)
            (14111323) (34111321) (23211322) (12311323) (32311321) (21411322) (24111412)
            (13211413) (33211411) (22311412) (11411413) (31411411) (24211141) (13311142)
            (22411141) (11511142) (25111231) (14211232) (23311231) (12411232) (21511231)
            (15111322) (24211321) (13311322) (22411321) (11511322) (25111411) (14211412)
            (23311411) (12411412) (21511411) (14311141) (12511141) (15211231) (13411231)
            (11611231) (16111321) (14311321) (12511321) (15211411) (13411411) (11611411)
            (31121143) (51121141) (21112144) (41112142) (21121234) (41121232) (11112235)
            (31112233) (51112231) (11121325) (31121323) (51121321) (21112324) (41112322)
            (21121414) (41121412) (11112415) (31112413) (51112411) (12121144) (32121142)
            (21221143) (41221141) (22112143) (42112141) (11212144) (22121233) (42121231)
            (11221234) (31221232) (12112234) (32112232) (12121324) (32121322) (21221323)
            (41221321) (22112323) (42112321) (11212324) (22121413) (42121411) (11221414)
            (31221412) (12112414) (32112412) (21212413) (41212411) (13121143) (33121141)
            (22221142) (11321143) (31321141) (23112142) (12212143) (23121232) (12221233)
            (32221231) (21321232) (13112233) (33112231) (13121323) (33121321) (11312233)
            (22221322) (11321323) (31321321) (23112322) (12212323) (23121412) (12221413)
            (32221411) (21321412) (13112413) (33112411) (22212412) (11312413) (31312411)
            (14121142) (23221141) (12321142) (21421141) (24112141) (13212142) (24121231)
            (13221232) (11412142) (22321231) (11421232) (14112232) (14121322) (12312232)
            (23221321) (12321322) (21421321) (24112321) (13212322) (24121411) (13221412)
            (11412322) (22321411) (11421412) (14112412) (23212411) (12312412) (21412411)
            (15121141) (13321141) (11521141) (14212141) (14221231) (12412141) (12421231)
            (15112231) (15121321) (13312231) (13321321) (11512231) (11521321) (14212321)
            (14221411) (12412321) (12421411) (15112411) (13312411) (11512411) (11131144)
            (31131142) (21122143) (41122141) (21131233) (41131231) (11113144) (31113142)
            (11122234) (31122232) (11131324) (31131322) (21113233) (41113231) (21122323)
            (41122321) (21131413) (41131411) (11113324) (31113322) (11122414) (31122412)
            (21113413) (41113411) (12131143) (32131141) (21231142) (22122142) (11222143)
            (22131232) (11231233) (31231231) (12113143) (32113141) (12122233) (32122231)
            (12131323) (32131321) (21231322) (22113232) (11213233) (22122322) (11222323)
            (22131412) (11231413) (31231411) (12113323) (32113321) (12122413) (32122411)
            (21222412) (22113412) (11213413) (31213411) (13131142) (22231141) (11331142)
            (23122141) (12222142) (23131231) (12231232) (21331231) (13113142) (13122232)
            (11313142) (13131322) (11322232) (22231321) (11331322) (23113231) (12213232)
            (23122321) (12222322) (23131411) (12231412) (21331411) (13113322) (13122412)
            (11313322) (22222411) (11322412) (23113411) (12213412) (21313411) (14131141)
            (12331141) (13222141) (13231231) (11422141) (11431231) (14113141) (14122231)
            (12313141) (14131321) (12322231) (12331321) (13213231) (13222321) (11413231)
            (13231411) (11422321) (11431411) (14113321) (14122411) (12313321) (12322411)
            (13213411) (11413411) (11141143) (31141141) (21132142) (21141232) (11123143)
            (31123141) (11132233) (31132231) (11141323) (31141321) (21114142) (21123232)
            (21132322) (21141412) (11114233) (31114231) (11123323) (31123321) (11132413)
            (31132411) (21114322) (21123412) (12141142) (21241141) (22132141) (11232142)
            (22141231) (11241232) (12123142) (12132232) (12141322) (21241321) (22114141)
            (11214142) (22123231) (11223232) (22132321) (11232322) (22141411) (11241412)
            (12114232) (12123322) (12132412) (21232411) (22114321) (11214322) (22123411)
            (11223412) (13141141) (11341141) (12232141) (12241231) (13123141) (13132231)
            (11323141) (13141321) (11332231) (11341321) (12214141) (12223231) (12232321)
            (12241411) (13114231) (13123321) (11314231) (13132411) (11323321) (11332411)
            (12214321) (12223411) (11151142) (21142141) (21151231) (11133142) (11142232)
            (11151322) (21124141) (21133231) (21142321) (21151411) (11115142) (11124232)
            (11133322) (11142412) (21115231) (21124321) (21133411) (12151141) (11242141)
            (11251231) (12133141) (12142231) (12151321) (11224141) (11233231) (11242321)
            (11251411) (12115141) (12124231) (12133321) (12142411) (11215231) (11224321)
            (11233411) (11161141) (11143141) (11152231) (11161321) (11125141) (11134231)
            (11143321) (11152411) (11111245) (31111243) (51111241) (21111334) (41111332)
            (11111425) (31111423) (51111421) (21111514) (41111512) (31211152) (12111244)
            (32111242) (21211243) (41211241) (22111333) (42111331) (11211334) (31211332)
            (12111424) (32111422) (21211423) (41211421) (22111513) (42111511) (11211514)
            (31211512) (12211153) (32211151) (21311152) (13111243) (33111241) (22211242)
            (11311243) (31311241) (23111332) (12211333) (32211331) (21311332) (13111423)
            (33111421) (22211422) (11311423) (31311421) (23111512) (12211513) (32211511)
            (21311512) (13211152) (22311151) (11411152) (14111242) (23211241) (12311242)
            (21411241) (24111331) (13211332) (22311331) (11411332) (14111422) (23211421)
            (12311422) (21411421) (24111511) (13211512) (22311511) (11411512) (14211151)
            (12411151) (15111241) (13311241) (11511241) (14211331) (12411331) (15111421)
            (13311421) (11511421) (14211511) (12411511) (21121153) (41121151) (11112154)
            (31112152) (11121244) (31121242) (21112243) (41112241) (21121333) (41121331)
            (11112334) (31112332) (11121424) (31121422) (21112423) (41112421) (21121513)
            (41121511) (11112514) (31112512) (22121152) (11221153) (31221151) (12112153)
            (32112151) (12121243) (32121241) (21221242) (22112242) (11212243) (22121332)
            (11221333) (31221331) (12112333) (32112331) (12121423) (32121421) (21221422)
            (22112422) (11212423) (22121512) (11221513) (31221511) (12112513) (32112511)
            (21212512) (23121151) (12221152) (21321151) (13112152) (13121242) (11312152)
            (22221241) (11321242) (23112241) (12212242) (23121331) (12221332) (21321331)
            (13112332) (13121422) (11312332) (22221421) (11321422) (23112421) (12212422)
            (23121511) (12221512) (21321511) (13112512) (22212511) (11312512) (13221151)
            (11421151) (14112151) (14121241) (12312151) (12321241) (13212241) (13221331)
            (11412241) (11421331) (14112331) (14121421) (12312331) (12321421) (13212421)
            (13221511) (11412421) (11421511) (14112511) (12312511) (21131152) (11122153)
            (31122151) (11131243) (31131241) (21113152) (21122242) (21131332) (11113243)
            (31113241) (11122333) (31122331) (11131423) (31131421) (21113332) (21122422)
            (21131512) (11113423) (31113421) (11122513) (31122511) (22131151) (11231152)
            (12122152) (12131242) (21231241) (22113151) (11213152) (22122241) (11222242)
            (22131331) (11231332) (12113242) (12122332) (12131422) (21231421) (22113331)
            (11213332) (22122421) (11222422) (22131511) (11231512) (12113422) (12122512)
            (21222511) (12231151) (13122151) (13131241) (11322151) (11331241) (12213151)
            (12222241) (12231331) (13113241) (13122331) (11313241) (13131421) (11322331)
            (11331421) (12213331) (12222421) (12231511) (13113421) (13122511) (11313421)
            (11322511) (21141151) (11132152) (11141242) (21123151) (21132241) (21141331)
            (11114152) (11123242) (11132332) (11141422) (21114241) (21123331) (21132421)
            (21141511) (11114332) (11123422) (11132512) (11241151) (12132151) (12141241)
            (11223151) (11232241) (11241331) (12114151) (12123241) (12132331) (12141421)
            (11214241) (11223331) (11232421) (11241511) (12114331) (12123421) (12132511)
            (11142151) (11151241) (11124151) (11133241) (11142331) (11151421) (11115241)
            (11124331) (11133421) (11142511) (21111253) (41111251) (11111344) (31111342)
            (21111433) (41111431) (11111524) (31111522) (21111613) (41111611) (21211162)
            (22111252) (11211253) (31211251) (12111343) (32111341) (21211342) (22111432)
            (11211433) (31211431) (12111523) (32111521) (21211522) (22111612) (11211613)
            (31211611) (22211161) (11311162) (23111251) (12211252) (21311251) (13111342)
            (22211341) (11311342) (23111431) (12211432) (21311431) (13111522) (22211521)
            (11311522) (23111611) (12211612) (21311611) (12311161) (13211251) (11411251)
            (14111341) (12311341) (13211431) (11411431) (14111521) (12311521) (13211611)
            (11411611) (31121161) (21112162) (21121252) (11112253) (31112251) (11121343)
            (31121341) (21112342) (21121432) (11112433) (31112431) (11121523) (31121521)
            (21112522) (21121612) (12121162) (21221161) (22112161) (11212162) (22121251)
            (11221252) (12112252) (12121342) (21221341) (22112341) (11212342) (22121431)
            (11221432) (12112432) (12121522) (21221521) (22112521) (11212522) (22121611)
            (11221612) (13121161) (11321161) (12212161) (12221251) (13112251) (13121341)
            (11312251) (11321341) (12212341) (12221431) (13112431) (13121521) (11312431)
            (11321521) (12212521) (12221611) (11131162) (21122161) (21131251) (11113162)
        ]
    ] def

    /parity [
        (1001) (0101) (1100) (0011) (1010) (0110) (1111) (0000)
    ] def

    % Derive the bits for each row
    /rowbits r array def
    0 1 r 1 sub {
        /i exch def
        /p i r 1 sub ne {parity i get} {(0000)} ifelse def
        /ccrow ccs i 8 mul 8 getinterval def
        /scrow [
            0 2 7 {ccrow exch 2 getinterval aload pop exch 49 mul add} for
        ] def
        /sbs [
            10 1 1
            0 1 3 {
                /j exch def
                patterns p j get 48 sub get scrow j get get {48 sub} forall
            } for
            4 1
        ] def
        mark
        1 sbs {1 index 0 eq {{1}} {{0}} ifelse repeat} forall
        counttomark 1 sub array astore exch pop exch pop
        rowbits i 3 -1 roll put
    } for

    % Populate the bitmap
    /pixs [
        81 sepheight mul {1} repeat
        0 1 r 2 sub {
            /i exch def
            rowheight {rowbits i get aload pop} repeat
            sepheight {10 {0} repeat 70 {1} repeat 0} repeat
        } for
        rowheight {rowbits r 1 sub get aload pop} repeat
        81 sepheight mul {1} repeat
    ] def

    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx 81
    /pixy pixs length 81 idiv
    /height pixs length 81 idiv 72 div
    /width 81 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/code49 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER code49--

% --BEGIN ENCODER channelcode--
% --REQUIRES preamble raiseerror renlinear--
% --DESC: Channel Code
% --EXAM: 3493
% --EXOP: height=0.5 includetext 
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp channelcode 0.0 2015050900 68302 68105
%%BeginData:        149 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/channelcode {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /shortfinder false def
    /includetext false def
    /includecheck false def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /height height cvr def

    % Validate the input
    barcode length 2 lt barcode length 7 gt or {
        /bwipp.channelcodeBadLength (Channel Code must be 2 to 7 digits) //raiseerror exec
    } if
    barcode {
        dup 48 lt exch 57 gt or {
            /bwipp.channelcodeBadCharacter (Channel Code must contain only digits) //raiseerror exec
        } if
    } forall
    barcode cvi [ 26 292 3493 44072 576688 7742862 ] barcode length 2 sub get gt {
        /bwipp.channelcodeTooBig (The Channel Code value is too big for the number of channels) //raiseerror exec
    } if

    /nextb {
        dup
        dup s exch get exch
        dup b exch 1 sub get exch
        dup s exch 1 sub get exch
        b exch 2 sub get exch
        add add add 4 gt {1} {2} ifelse
        1 index chan 2 add lt {
            dup 1 4 index {
                b 3 index 2 index put
                3 index exch sub 1 add 4 index 3 index 1 add nexts
            } for
        } {
            dup 3 index le {
                b 2 index 4 index put
                value target eq {
                    /out [ 
                        3 1 10 {dup s exch get exch b exch get} for
                    ] 0 chan 2 mul getinterval def 
                } if
                /value value 1 add def
            } if
        } ifelse 
        pop pop pop pop
    } bind def

    /nexts {
        dup chan 2 add lt {1} {1 index} ifelse 1 3 index {
            s 2 index 2 index put
            2 index exch sub 1 add 3 index 2 index nextb
        } for
        pop pop pop
    } bind def

    /encode {
        /chan exch def
        /target exch def
        /value 0 def
        /out -1 def
        /b [ 1 1 1 0 0 0 0 0 0 0 0 ] def
        /s [ 0 1 1 0 0 0 0 0 0 0 0 ] def
        chan dup 3 nexts
        out
    } bind def

    /barlen barcode length def

    % Determine finder
    /finder shortfinder { [ 1 1 1 1 1 ] } { [ 1 1 1 1 1 1 1 1 1 ] } ifelse def

    % Encode the main data
    /data barcode cvi barlen 1 add encode def

    % Determine check data
    /check [] def
    includecheck {
        /mod23 [
            [] []
            [ 13 12  4  9  3  1 ]
            [ 13  2 12  3 18 16  4  1 ]
            [ 11 16 17  8 20  4 10  2  5  1 ]
            [  1  4 16 18  3 12  2  8  9 13  6  1 ]
            [ 20 16 22 13 15 12  5  4  8  9 21  3  7  1 ]
            [  2  6 18  8  1  3  9  4 12 13 16  2  6 18  8  1 ]
        ] barlen get def
        0
        0 1 data length 1 sub {
            dup data exch get 1 sub exch mod23 exch get mul add
        } for
        23 mod 3 encode /check exch def
    } if

    % Construct the symbol
    /sbs [
        finder aload pop
        data aload pop
        check aload pop
    ] def

    % Create the human readable text
    /txt barlen array def
    0 1 barlen 1 sub {
        /i exch def
        txt i [barcode i 1 getinterval 0 0 () 0] put
    } for

    % Return the arguments
    <<
    /ren //renlinear
    /sbs sbs
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    /txt txt
    /textxalign (center)
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/channelcode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER channelcode--

% --BEGIN ENCODER flattermarken--
% --REQUIRES preamble raiseerror renlinear--
% --DESC: Flattermarken
% --EXAM: 11099
% --EXOP: inkspread=-0.25 showborder borderleft=0 borderright=0
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp flattermarken 0.0 2015050900 59248 59148
%%BeginData:         93 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/flattermarken {

    20 dict begin                 % Confine variable to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /includetext false def   % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 0.3 def

    % Validate the input
    barcode {
        dup 48 lt exch 57 gt or {
            /bwipp.flattermarkenBadCharacter (Flattermarken must contain only digits) //raiseerror exec
        } if
    } forall

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def

    % Validate the input
    barcode {
        dup 48 lt exch 57 gt or {
            /bwipp.flattermarkenBadCharacter (Flattermarken must contain only digits) //raiseerror exec
        } if
    } forall

    % Create an array containing the character mappings
    /encs
    [ (0018) (0117) (0216) (0315) (0414) (0513) (0612) (0711) (0810)
      (0900)
    ] def

    % Create a string of the available characters
    /barchars (1234567890) def

    /barlen barcode length def            % Length of the code

    /sbs barlen 4 mul string def
    /txt barlen array def

    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                 % Discard true leaving pre
        length /indx exch def               % indx is the length of pre
        pop pop                             % Discard seek and post
        /enc encs indx get def              % Get the indxth encoding
        sbs i 4 mul enc putinterval         % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 9 mul textyoffset textfont textsize] put
    } for

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    /txt txt
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/flattermarken dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER flattermarken--

% --BEGIN ENCODER raw--
% --REQUIRES preamble raiseerror renlinear--
% --DESC: Custom 1D symbology
% --EXAM: 331132131313411122131311333213114131131221323
% --EXOP: height=0.5
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp raw 0.0 2015050900 55514 55371
%%BeginData:         52 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/raw {

    20 dict begin                  % Confine variables to local scope

    /options exch def        % We are given an option string
    /barcode exch def        % We are given a barcode string

    /dontdraw false def
    /height 1 def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /height height cvr def

    % Validate input
    barcode {
        dup 49 lt exch 57 gt or {
            /bwipp.rawBadCharacter (Raw must contain only digits 1 to 9) //raiseerror exec
        } if
    } forall

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [barcode {48 sub} forall]
    /bhs [barcode length 1 add 2 idiv {height} repeat]
    /bbs [barcode length 1 add 2 idiv {0} repeat]
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/raw dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER raw--

% --BEGIN ENCODER daft--
% --REQUIRES preamble raiseerror renlinear--
% --DESC: Custom 4 state symbology
% --EXAM: FATDAFTDAD
% --EXOP:
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp daft 0.0 2015050900 58288 58222
%%BeginData:         76 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/daft {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /height 0.175 def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /height height cvr def

    barcode {
        dup 68 ne exch dup 65 ne exch dup 70 ne exch 84 ne and and and {
            /bwipp.daftBadCharacter (DAFT must contain only characters D, A, F and T) //raiseerror exec
        } if
    } forall

    /barlen barcode length def

    /bbs barlen array def
    /bhs barlen array def
    0 1 barlen 1 sub {
        /i exch def
        /enc barcode i 1 getinterval def
        enc (D) eq {
            bbs i 0 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (A) eq {
            bbs i 3 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (F) eq {
            bbs i 0 height mul 8 div put
            bhs i 8 height mul 8 div put
        } if
        enc (T) eq {
            bbs i 3 height mul 8 div put
            bhs i 2 height mul 8 div put
        } if
    } for

    % Return the arguments
    <<
    /ren //renlinear
    /bbs bbs
    /bhs bhs
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/daft dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER daft--

% --BEGIN ENCODER symbol--
% --REQUIRES preamble raiseerror renlinear--
% --DESC: Miscellaneous symbols
% --EXAM: fima
% --EXOP: backgroundcolor=DD000011
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp symbol 0.0 2015050900 58044 57965
%%BeginData:         72 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/symbol {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /symbols <<
        /fima {
            /sbs [2.25 2.25 2.25 11.25 2.25 11.25 2.25 2.25 2.25] def
            /bhs [.625 .625 .625 .625 .625] def
            /bbs [0 0 0 0 0] def
        } bind
        /fimb {
            /sbs [2.25 6.75 2.25 2.25 2.25 6.25 2.25 2.25 2.25 6.75 2.25] def
            /bhs [.625 .625 .625 .625 .625 .625] def
            /bbs [0 0 0 0 0 0] def
        } bind
        /fimc {
            /sbs [2.25 2.25 2.25 6.75 2.25 6.75 2.25 6.75 2.25 2.25 2.25] def
            /bhs [.625 .625 .625 .625 .625 .625] def
            /bbs [0 0 0 0 0 0] def
        } bind
        /fimd {
            /sbs [2.25 2.25 2.25 2.25 2.25 6.75 2.25 6.75 2.25 2.25 2.25 2.25 2.25] def
            /bhs [.625 .625 .625 .625 .625 .625 .625] def
            /bbs [0 0 0 0 0 0 0] def
        } bind
    >> def

    % Valiate input   
    symbols barcode known not {
        /bwipp.symbolUnknownSymbol (Unknown symbol name provided) //raiseerror exec 
    } if

    symbols barcode get exec
 
    % Return the arguments
    <<
    /ren //renlinear
    /sbs sbs
    /bhs bhs
    /bbs bbs
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/symbol dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER symbol--

% --BEGIN ENCODER pdf417--
% --REQUIRES preamble raiseerror renmatrix--
% --DESC: PDF417
% --EXAM: This is PDF417
% --EXOP: columns=2
% --RNDR: renmatrix
%%BeginResource: uk.co.terryburton.bwipp pdf417 0.0 2015050900 188276 197810
%%BeginData:        873 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/pdf417 {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /compact false def
    /eclevel -1 def
    /columns 0 def
    /rows 0 def
    /rowmult 3 def
    /encoding (auto) def
    /ccc false def
    /raw false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /eclevel eclevel cvi def
    /columns columns cvi def
    /rows rows cvi def
    /rowmult rowmult cvr def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    raw {/encoding (raw) def} if

    % Convert input into array of codewords
    encoding (raw) eq {
        /datcws barcode length array def
        /i 0 def /j 0 def
        { % loop
            i barcode length eq {exit} if
            /cw barcode i 1 add 3 getinterval cvi def
            datcws j cw put
            /i i 4 add def
            /j j 1 add def
        } loop
        /datcws datcws 0 j getinterval def
    } if

    /barcode [ barcode {} forall ] def
    /barlen barcode length def

    ccc {/encoding (ccc) def} if

    /encb {
        /in exch def
        /inlen in length def
        /out inlen 6 idiv 5 mul inlen 6 mod add array def
        0 1 inlen 6 idiv 1 sub {
            /k exch def
            /msbs [ in k 6 mul 3 getinterval aload pop ] def
            /mscs [
                msbs aload pop exch 256 mul add exch 65536 mul add
                3 {dup 900 mod exch 900 idiv} repeat
            ] def
            /lsbs [ in k 6 mul 3 add 3 getinterval aload pop ] def
            /lscs [
                lsbs aload pop exch 256 mul add exch 65536 mul add
                3 {dup 900 mod exch 900 idiv} repeat
            ] def
            lscs 0 get mscs 0 get 316 mul add
            out k 5 mul 4 add 2 index 900 mod put
            900 idiv lscs 1 get add mscs 0 get 641 mul add mscs 1 get 316 mul add
            out k 5 mul 3 add 2 index 900 mod put
            900 idiv lscs 2 get add mscs 0 get 20 mul add mscs 1 get 641 mul add mscs 2 get 316 mul add
            out k 5 mul 2 add 2 index 900 mod put
            900 idiv lscs 3 get add mscs 1 get 20 mul add mscs 2 get 641 mul add
            out k 5 mul 1 add 2 index 900 mod put
            900 idiv mscs 2 get 20 mul add
            out k 5 mul 3 -1 roll 900 mod put
        } for
        /rem inlen 6 mod def
        rem 0 ne {
            out out length rem sub
            [ in inlen rem sub rem getinterval aload pop ]
            putinterval
        } if
        out
    } bind def
    
    encoding (byte) eq encoding (ccc) eq or {
        /datcws barlen 6 idiv 5 mul barlen 6 mod add 1 add array def
        datcws 0 barlen 6 mod 0 eq {924} {901} ifelse put
        datcws 1 barcode encb putinterval
        encoding (ccc) eq {/datcws [920 datcws aload pop] def} if
    } if

    encoding (auto) eq {

        % Modes and text submodes
        /T 0 def  /N 1 def  /B 2 def
        /A 0 def  /L 1 def  /M 2 def  /P 3 def
        
        % Special function characters for mode switching
        /tl -1 def  /nl -2 def  /bl -3 def  /bl6 -4 def  /bs -5 def
        
        % Special function characters for text mode
        /al -6 def  /ll -7 def  /ml -8 def  /pl -9 def  /as -10 def  /ps -11 def
        
        % Character maps for each state
        /charmaps [
          %  A    L    M    P
          [ (A)  (a)  (0)  (;) ]  % 0
          [ (B)  (b)  (1)  (<) ]  % 1
          [ (C)  (c)  (2)  (>) ]  % 2
          [ (D)  (d)  (3)  (@) ]  % 3
          [ (E)  (e)  (4)  ([) ]  % 4
          [ (F)  (f)  (5)   92 ]  % 5
          [ (G)  (g)  (6)  (]) ]  % 6
          [ (H)  (h)  (7)  (_) ]  % 7
          [ (I)  (i)  (8)  (`) ]  % 8
          [ (J)  (j)  (9)  (~) ]  % 9
          [ (K)  (k)  (&)  (!) ]  % 10
          [ (L)  (l)   13   13 ]  % 11
          [ (M)  (m)    9    9 ]  % 12
          [ (N)  (n)  (,)  (,) ]  % 13
          [ (O)  (o)  (:)  (:) ]  % 14
          [ (P)  (p)  (#)   10 ]  % 15
          [ (Q)  (q)  (-)  (-) ]  % 16
          [ (R)  (r)  (.)  (.) ]  % 17
          [ (S)  (s)  ($)  ($) ]  % 18
          [ (T)  (t)  (/)  (/) ]  % 19
          [ (U)  (u)  (+)  (") ]  % 20
          [ (V)  (v)  (%)  (|) ]  % 21
          [ (W)  (w)  (*)  (*) ]  % 22
          [ (X)  (x)  (=)   40 ]  % 23
          [ (Y)  (y)  (^)   41 ]  % 24
          [ (Z)  (z)   pl  (?) ]  % 25
          [ ( )  ( )  ( )  ({) ]  % 26
          [  ll   as   ll  (}) ]  % 27
          [  ml   ml   al  (') ]  % 28
          [  ps   ps   ps   al ]  % 29
        ] def
        
        % Invert charmaps to give character to value maps for each state
        /charvals [ 30 dict 30 dict 30 dict 30 dict ] def
        /alltext 104 dict def
        0 1 charmaps length 1 sub {
          /i exch def
          /encs charmaps i get def
          0 1 3 {
            /j exch def
            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required
            dup charvals j get exch i put
            alltext exch -1 put
          } for
        } for
        
        /e 10000 def  % "Empty"
        
        /latlen [  % Bit length of latch between submodes
        % To:  A  L  M  P      From
            [  0  1  1  2 ]  % A
            [  2  0  1  2 ]  % L
            [  1  1  0  1 ]  % M
            [  1  2  2  0 ]  % P
        ] def
        
        /latseq [  % Latch sequences between submodes
        % To: A       L       M       P               From
            [ []      [ll]    [ml]    [ml pl]    ]  % A
            [ [ml al] []      [ml]    [ml pl]    ]  % L
            [ [al]    [ll]    []      [pl]       ]  % M
            [ [al]    [al ll] [al ml] []         ]  % P
        ] def
        
        /shftlen [  % Bit length of shift to submode
        % To:  A  L  M  P      From
            [  e  e  e  1 ]  % A
            [  1  e  e  1 ]  % L
            [  e  e  e  1 ]  % M
            [  e  e  e  e ]  % P
        ] def
        
        % Determine runlengths of digits
        /numdigits [ barlen {0} repeat 0 ] def
        /numtext   [ barlen {0} repeat 0 ] def
        /numbytes  [ barlen {0} repeat 0 ] def
        barlen 1 sub -1 0 {
            /i exch def
            barcode i get dup 48 ge exch 57 le and {
                numdigits i numdigits i 1 add get 1 add put
            } if
            alltext barcode i get known numdigits i get 13 lt and {
                numtext i numtext i 1 add get 1 add put
            } if
            numtext i get 5 lt numdigits i get 13 lt and {
                numbytes i numbytes i 1 add get 1 add put
            } if
        } for
        /numdigits numdigits 0 barlen getinterval def
        /numtext   numtext   0 barlen getinterval def
        /numbytes  numbytes  0 barlen getinterval def
        
        /seq [] def /seqlen 0 def /state T def /p 0 def {  % loop
            p barlen eq {exit} if
            /n numdigits p get def
            n 13 ge {
                /seq [
                    seq aload pop
                    nl
                    [ barcode p n getinterval aload pop ]
                ] def
                /state N def
                /p p n add def
                /seqlen seqlen 1 add n add def
            } {  % next
            /t numtext p get def
            t 5 ge {
                /seq [
                    seq aload pop
                    state T ne {tl} if
                    [ barcode p t getinterval aload pop ]
                ] def
                /state T def
                /p p t add def
                /seqlen seqlen 1 add t add def  % ish
            } {  % next
            /b numbytes p get def
            b 1 eq state T eq and {
                /seq [
                    seq aload pop
                    bs
                    [ barcode p get ]
                ] def
                /p p b add def
                /seqlen seqlen 2 add def
            } {  % next
                /seq [
                    seq aload pop
                    b 6 mod 0 ne {bl} {bl6} ifelse
                    [ barcode p b getinterval aload pop ]
                ] def
                /state B def
                /p p b add def
                /seqlen seqlen 1 add b add def
            } ifelse } ifelse } ifelse
        } loop
        
        /latchcws <<
            tl 900  bl 901  bl6 924  nl 902  bs 913
        >> def
        
        % Submode encoding functions
        /enca {charvals A get exch get} bind def
        /encl {charvals L get exch get} bind def
        /encm {charvals M get exch get} bind def
        /encp {charvals P get exch get} bind def
        /textencfuncs [ /enca /encl /encm /encp ] def
        
        /addtotext {
            text exch l exch put
            /l l 1 add def
        } bind def
        
        /enct {
        
            /in exch def
        
            /curlen [  e  e  e  e ] def
            curlen submode 0 put
            /curseq [ [] [] [] [] ] def
        
            % Derive the optimal sequences ending in each submode
            in {
        
                /char exch def
        
                % Check for optimisations in the current sequences by latching from x to y
                {  % loop
                    /imp false def
                    [ A L M P ] {
                        /x exch def
                        [ A L M P ] {
                            /y exch def
                            /cost curlen x get latlen x get y get add def
                            cost curlen y get lt {
                                curlen y cost put
                                curseq y [
                                    curseq x get aload pop
                                    latseq x get y get aload pop
                                ] put
                                /imp true def
                            } if
                        } forall
                    } forall
                    imp not {exit} if  % Repeat unless no improvement
                } loop
        
                % Determine optimal next sequences for each valid encoding
                /nxtlen [ e e e e ] def
                /nxtseq 4 array def
        
                [ A L M P ] {
                    /x exch def
        
                    { % loop for common exit
        
                        charvals x get char known not {exit} if
        
                        % Extend directly
                        /cost curlen x get 1 add def
                        cost nxtlen x get lt {
                            nxtlen x cost put
                            nxtseq x [ curseq x get aload pop char ] put
                        } if
        
                        % Optimise for direct shifts from y to x
                        [ A L M P ] {
                            /y exch def
                            x y ne {
                                /cost curlen y get shftlen y get x get add 1 add def
                                cost nxtlen y get lt {
                                    nxtlen y cost put
                                    nxtseq y [
                                        curseq y get aload pop
                                        x A eq {as} {ps} ifelse
                                        char
                                    ] put
                                } if
                            } if
                        } forall
        
                        exit
                    } loop
        
                } forall
        
                /curlen nxtlen def
                /curseq nxtseq def
        
            } forall
        
            % Select the optimal sequence
            /minseq e def
            [ A L M P ] {
                /k exch def
                curlen k get minseq lt {
                    /minseq curlen k get def
                    /txtseq curseq k get def
                } if
            } forall
        
            % Encode the sequence
            /text minseq array def
            /k 0 def /l 0 def {
                k txtseq length ge {exit} if
        
                /char txtseq k get def
        
                % Encode character
                char textencfuncs submode get load exec addtotext
                /k k 1 add def
        
                % Encode shifted next character
                char as eq char ps eq or {
                    txtseq k get char as eq {enca} {encp} ifelse addtotext
                    /k k 1 add def
                } if
        
                % Latches to new submode
                char al eq {/submode A def} if
                char ll eq {/submode L def} if
                char ml eq {/submode M def} if
                char pl eq {/submode P def} if
            } loop
        
            text length 2 mod 1 eq {
                submode P eq {
                    /pad al encp def
                    /submode A def
                } {
                    /pad ps textencfuncs submode get load exec def
                } ifelse
                /text [ text aload pop pad ] def
            } if
        
            /out text length 2 idiv array def
            0 1 out length 1 sub {
                /k exch def
                out k text k 2 mul get 30 mul text k 2 mul 1 add get add put
            } for
        
            out
        
        } bind def
        
        /encn {
            /in exch def
            /out [] def
            0 44 in length 1 sub {
                /k exch def
                /gmod [
                    1 in k in length k sub dup 44 gt {pop 44} if getinterval
                    {48 sub} forall
                ] def
                /cwn [] def {
                    /dv 900 def
                    /gmul [] def /val 0 def {
                        gmod length 0 eq {exit} if
                        /val val 10 mul gmod 0 get add def
                        /gmod gmod 1 gmod length 1 sub getinterval def
                        val dv lt {
                            gmul length 0 ne {
                                /gmul [ gmul aload pop 0 ] def
                            } if
                        } {
                            /gmul [ gmul aload pop val dv idiv ] def
                        } ifelse
                        /val val dv mod def
                    } loop
                    /dv val def
                    /cwn [ dv cwn aload pop ] def
                    /gmod gmul def
                    gmul length 0 eq {exit} if
                } loop
                /out [ out aload pop cwn aload pop ] def
            } for
            out
        } bind def
       
        /encfuncs [ /enct /encn /encb ] def
        
        /addtocws {
            dup datcws j 3 -1 roll putinterval
            length j add /j exch def
        } bind def
        
        % Encode the sequence
        /state T def /submode A def
        /datcws seqlen array def
        /i 0 def /j 0 def {
            i seq length ge {exit} if
            /chars seq i get def
            chars type /arraytype eq {  % Encode data according to mode
                chars encfuncs state get load exec addtocws
            } {  % Encode the latch to new state or byte shift
                [ latchcws chars get ] addtocws
                chars tl eq {/state T def /submode A def} if
                chars nl eq {/state N def} if
                chars bl eq chars bl6 eq or {/state B def} if
                chars bs eq {
                    /i i 1 add def
                    seq i get encb addtocws
                } if
            } ifelse
            /i i 1 add def
        } loop
        /datcws datcws 0 j getinterval def
    } if

    % Determine the error correction level if unspecified
    /m datcws length def
    eclevel -1 eq {
        m  40 le              {/eclevel 2 def} if
        m  41 ge m 160 le and {/eclevel 3 def} if
        m 161 ge m 320 le and {/eclevel 4 def} if
        m 321 ge              {/eclevel 5 def} if
    } if

    % Reduce the error level so that it does not cause an excessive number of codewords
    /maxeclevel 928 1 sub m sub ln 2 ln div cvi 1 sub def
    eclevel maxeclevel gt {/eclevel maxeclevel def} if
    /k 2 eclevel 1 add exp cvi def

    % To determine size of matrix, number of columns if given by user...
    columns 0 eq {/columns m k add 3 div sqrt round cvi def} if
    columns 1 ge columns 30 le and {/c columns def} if

    % ... and rows is greater of those required and that given by user within limits
    /r m k add 1 add columns div ceiling cvi def  % Required
    r rows lt rows 90 le and {/r rows def} if
    r 3 lt {/r 3 def} if

    % Opportunistically raise the error level if a better fit to the matrix is possible
    /maxeclevel c r mul 1 sub m sub ln 2 ln div cvi 1 sub 8 2 copy gt {exch} if pop def
    maxeclevel eclevel gt {
      /eclevel maxeclevel def
      /k 2 eclevel 1 add exp cvi def
    } if

    % Create codewords array with one extra working space element and add padding
    /n c r mul k sub def
    /cws c r mul 1 add array def
    cws 0 n put
    cws 1 datcws putinterval
    cws m 1 add [ n m sub 1 sub {900} repeat ] putinterval
    cws n [ k {0} repeat 0 ] putinterval

    % Calculate the log and anti-log tables
    /rsalog [ 1 928 {dup 3 mul 929 mod} repeat ] def
    /rslog 929 array def
    1 1 928 {dup rsalog exch get exch rslog 3 1 roll put} for

    % Function to calculate the product in the field
    /rsprod {
        2 copy 0 ne exch 0 ne and {
            rslog exch get exch rslog exch get add 928 mod rsalog exch get
        } {
            pop pop 0
        } ifelse
    } bind def

    % Generate the coefficients
    /coeffs [ 1 k {0} repeat ] def
    1 1 k {
        /i exch def 
        coeffs i coeffs i 1 sub get put
        i 1 sub -1 1 {
            /j exch def
            coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod add 929 mod put
        } for 
        coeffs 0 coeffs 0 get rsalog i get rsprod put
    } for
    /coeffs coeffs 0 coeffs length 1 sub getinterval def
    coeffs length 1 sub -2 0 {coeffs exch 2 copy get 929 exch sub put} for

    % Derive the error codewords
    0 1 n 1 sub {
        /t exch cws exch get cws n get add 929 mod def
        0 1 k 1 sub {
            /j exch def
            cws n j add cws n j add 1 add get 929 t coeffs k j sub 1 sub get mul 929 mod sub add 929 mod put
        } for
    } for
    n 1 n k add { dup cws exch 929 cws 5 -1 roll get sub 929 mod put } for

    % Trim the working space from the end of the codewords
    /cws cws 0 cws length 1 sub getinterval def

    % Base 10 encoding of the bar space successions for the codewords in each cluster
    /clusters [
        [
            120256 125680 128380 120032 125560 128318 108736 119920 108640  86080 108592  86048
            110016 120560 125820 109792 120440 125758  88256 109680  88160  89536 110320 120700
             89312 110200 120638  89200 110140  89840 110460  89720 110398  89980 128506 119520
            125304 128190 107712 119408 125244 107616 119352  84032 107568 119324  84000 107544
             83984 108256 119672 125374  85184 108144 119612  85088 108088 119582  85040 108060
             85728 108408 119742  85616 108348  85560 108318  85880 108478  85820  85790 107200
            119152 125116 107104 119096 125086  83008 107056 119068  82976 107032  82960  82952
             83648 107376 119228  83552 107320 119198  83504 107292  83480  83468  83824 107452
             83768 107422  83740  83900 106848 118968 125022  82496 106800 118940  82464 106776
            118926  82448 106764  82440 106758  82784 106936 119006  82736 106908  82712 106894
             82700  82694 106974  82830  82240 106672 118876  82208 106648 118862  82192 106636
             82184 106630  82180  82352  82328  82316  82080 118830 106572 106566  82050 117472
            124280 127678 103616 117360 124220 103520 117304 124190  75840 103472  75808 104160
            117624 124350  76992 104048 117564  76896 103992  76848  76824  77536 104312 117694
             77424 104252  77368  77340  77688 104382  77628  77758 121536 126320 128700 121440
            126264 128670 111680 121392 126236 111648 121368 126222 111632 121356 103104 117104
            124092 112320 103008 117048 124062 112224 121656 126366  93248  74784 102936 117006
             93216 112152  93200  75456 103280 117180  93888  75360 103224 117150  93792 112440
            121758  93744  75288  93720  75632 103356  94064  75576 103326  94008 112542  93980
             75708  94140  75678  94110 121184 126136 128606 111168 121136 126108 111136 121112
            126094 111120 121100 111112 111108 102752 116920 123998 111456 102704 116892  91712
             74272 121244 116878  91680  74256 102668  91664 111372 102662  74244  74592 102840
            116958  92000  74544 102812  91952 111516 102798  91928  74508  74502  74680 102878
             92088  74652  92060  74638  92046  92126 110912 121008 126044 110880 120984 126030
            110864 120972 110856 120966 110852 110850  74048 102576 116828  90944  74016 102552
            116814  90912 111000 121038  90896  73992 102534  90888 110982  90884  74160 102620
             91056  74136 102606  91032 111054  91020  74118  91014  91100  91086 110752 120920
            125998 110736 120908 110728 120902 110724 110722  73888 102488 116782  90528  73872
            102476  90512 110796 102470  90504  73860  90500  73858  73944  90584  90572  90566
            120876 120870 110658 102444  73800  90312  90308  90306 101056 116080 123580 100960
            116024  70720 100912 115996  70688 100888  70672  70664  71360 101232 116156  71264
            101176 116126  71216 101148  71192  71180  71536 101308  71480 101278  71452  71612
             71582 118112 124600 127838 105024 118064 124572 104992 118040 124558 104976 118028
            104968 118022 100704 115896 123486 105312 100656 115868  79424  70176 118172 115854
             79392 105240 100620  79376  70152  79368  70496 100792 115934  79712  70448 118238
             79664 105372 100750  79640  70412  79628  70584 100830  79800  70556  79772  70542
             70622  79838 122176 126640 128860 122144 126616 128846 122128 126604 122120 126598
            122116 104768 117936 124508 113472 104736 126684 124494 113440 122264 126670 113424
            104712 117894 113416 122246 104706  69952 100528 115804  78656  69920 100504 115790
             96064  78624 104856 117966  96032 113560 122318 100486  96016  78600 104838  96008
             69890  70064 100572  78768  70040 100558  96176  78744 104910  96152 113614  70022
             78726  70108  78812  70094  96220  78798 122016 126552 128814 122000 126540 121992
            126534 121988 121986 104608 117848 124462 113056 104592 126574 113040 122060 117830
            113032 104580 113028 104578 113026  69792 100440 115758  78240  69776 100428  95136
             78224 104652 100422  95120 113100  69764  95112  78212  69762  78210  69848 100462
             78296  69836  95192  78284  69830  95180  78278  69870  95214 121936 126508 121928
            126502 121924 121922 104528 117804 112848 104520 117798 112840 121958 112836 104514
            112834  69712 100396  78032  69704 100390  94672  78024 104550  94664 112870  69698
             94660  78018  94658  78060  94700  94694 126486 121890 117782 104484 104482  69672
             77928  94440  69666  77922  99680  68160  99632  68128  99608 115342  68112  99596
             68104  99590  68448  99768 115422  68400  99740  68376  99726  68364  68358  68536
             99806  68508  68494  68574 101696 116400 123740 101664 116376 101648 116364 101640
            116358 101636  67904  99504 115292  72512  67872 116444 115278  72480 101784 116430
             72464  67848  99462  72456 101766  67842  68016  99548  72624  67992  99534  72600
            101838  72588  67974  68060  72668  68046  72654 118432 124760 127918 118416 124748
            118408 124742 118404 118402 101536 116312 105888 101520 116300 105872 118476 116294
            105864 101508 105860 101506 105858  67744  99416  72096  67728 116334  80800  72080
            101580  99398  80784 105932  67716  80776  72068  67714  72066  67800  99438  72152
             67788  80856  72140  67782  80844  72134  67822  72174  80878 126800 128940 126792
            128934 126788 126786 118352 124716 122576 126828 124710 122568 126822 122564 118338
            122562 101456 116268 105680 101448 116262 114128 105672 118374 114120 122598 101442
            114116 105666 114114  67664  99372  71888  67656  99366  80336  71880 101478  97232
             80328 105702  67650  97224 114150  71874  97220  67692  71916  67686  80364  71910
             97260  80358  97254 126760 128918 126756 126754 118312 124694 122472 126774 122468
            118306 122466 101416 116246 105576 101412 113896 105572 101410 113892 105570 113890
             67624  99350  71784 101430  80104  71780  67618  96744  80100  71778  96740  80098
             96738  71798  96758 126738 122420 122418 105524 113780 113778  71732  79988  96500
             96498  66880  66848  98968  66832  66824  66820  66992  66968  66956  66950  67036
             67022 100000  99984 115532  99976 115526  99972  99970  66720  98904  69024 100056
             98892  69008 100044  69000 100038  68996  66690  68994  66776  98926  69080 100078
             69068  66758  69062  66798  69102 116560 116552 116548 116546  99920 102096 116588
            115494 102088 116582 102084  99906 102082  66640  68816  66632  98854  73168  68808
             66628  73160  68804  66626  73156  68802  66668  68844  66662  73196  68838  73190
            124840 124836 124834 116520 118632 124854 118628 116514 118626  99880 115478 101992
            116534 106216 101988  99874 106212 101986 106210  66600  98838  68712  99894  72936
             68708  66594  81384  72932  68706  81380  72930  66614  68726  72950  81398 128980
            128978 124820 126900 124818 126898 116500 118580 116498 122740 118578 122738  99860
            101940  99858 106100 101938 114420
        ] [
            128352 129720 125504 128304 129692 125472 128280 129678 125456 128268 125448 128262
            125444 125792 128440 129758 120384 125744 128412 120352 125720 128398 120336 125708
            120328 125702 120324 120672 125880 128478 110144 120624 125852 110112 120600 125838
            110096 120588 110088 120582 110084 110432 120760 125918  89664 110384 120732  89632
            110360 120718  89616 110348  89608 110342  89952 110520 120798  89904 110492  89880
            110478  89868  90040 110558  90012  89998 125248 128176 129628 125216 128152 129614
            125200 128140 125192 128134 125188 125186 119616 125360 128220 119584 125336 128206
            119568 125324 119560 125318 119556 119554 108352 119728 125404 108320 119704 125390
            108304 119692 108296 119686 108292 108290  85824 108464 119772  85792 108440 119758
             85776 108428  85768 108422  85764  85936 108508  85912 108494  85900  85894  85980
             85966 125088 128088 129582 125072 128076 125064 128070 125060 125058 119200 125144
            128110 119184 125132 119176 125126 119172 119170 107424 119256 125166 107408 119244
            107400 119238 107396 107394  83872 107480 119278  83856 107468  83848 107462  83844
             83842  83928 107502  83916  83910  83950 125008 128044 125000 128038 124996 124994
            118992 125036 118984 125030 118980 118978 106960 119020 106952 119014 106948 106946
             82896 106988  82888 106982  82884  82882  82924  82918 124968 128022 124964 124962
            118888 124982 118884 118882 106728 118902 106724 106722  82408 106742  82404  82402
            124948 124946 118836 118834 106612 106610 124224 127664 129372 124192 127640 129358
            124176 127628 124168 127622 124164 124162 117568 124336 127708 117536 124312 127694
            117520 124300 117512 124294 117508 117506 104256 117680 124380 104224 117656 124366
            104208 117644 104200 117638 104196 104194  77632 104368 117724  77600 104344 117710
             77584 104332  77576 104326  77572  77744 104412  77720 104398  77708  77702  77788
             77774 128672 129880  93168 128656 129868  92664 128648 129862  92412 128644 128642
            124064 127576 129326 126368 124048 129902 126352 128716 127558 126344 124036 126340
            124034 126338 117152 124120 127598 121760 117136 124108 121744 126412 124102 121736
            117124 121732 117122 121730 103328 117208 124142 112544 103312 117196 112528 121804
            117190 112520 103300 112516 103298 112514  75680 103384 117230  94112  75664 103372
             94096 112588 103366  94088  75652  94084  75650  75736 103406  94168  75724  94156
             75718  94150  75758 128592 129836  91640 128584 129830  91388 128580  91262 128578
            123984 127532 126160 123976 127526 126152 128614 126148 123970 126146 116944 124012
            121296 116936 124006 121288 126182 121284 116930 121282 102864 116972 111568 102856
            116966 111560 121318 111556 102850 111554  74704 102892  92112  74696 102886  92104
            111590  92100  74690  92098  74732  92140  74726  92134 128552 129814  90876 128548
             90750 128546 123944 127510 126056 128566 126052 123938 126050 116840 123958 121064
            116836 121060 116834 121058 102632 116854 111080 121078 111076 102626 111074  74216
            102646  91112  74212  91108  74210  91106  74230  91126 128532  90494 128530 123924
            126004 123922 126002 116788 120948 116786 120946 102516 110836 102514 110834  73972
             90612  73970  90610 128522 123914 125978 116762 120890 102458 110714 123552 127320
            129198 123536 127308 123528 127302 123524 123522 116128 123608 127342 116112 123596
            116104 123590 116100 116098 101280 116184 123630 101264 116172 101256 116166 101252
            101250  71584 101336 116206  71568 101324  71560 101318  71556  71554  71640 101358
             71628  71622  71662 127824 129452  79352 127816 129446  79100 127812  78974 127810
            123472 127276 124624 123464 127270 124616 127846 124612 123458 124610 115920 123500
            118224 115912 123494 118216 124646 118212 115906 118210 100816 115948 105424 100808
            115942 105416 118246 105412 100802 105410  70608 100844  79824  70600 100838  79816
            105446  79812  70594  79810  70636  79852  70630  79846 129960  95728 113404 129956
             95480 113278 129954  95356  95294 127784 129430  78588 128872 129974  95996  78462
            128868 127778  95870 128866 123432 127254 124520 123428 126696 128886 123426 126692
            124514 126690 115816 123446 117992 115812 122344 117988 115810 122340 117986 122338
            100584 115830 104936 100580 113640 104932 100578 113636 104930 113634  70120 100598
             78824  70116  96232  78820  70114  96228  78818  96226  70134  78838 129940  94968
            113022 129938  94844  94782 127764  78206 128820 127762  95102 128818 123412 124468
            123410 126580 124466 126578 115764 117876 115762 122100 117874 122098 100468 104692
            100466 113140 104690 113138  69876  78324  69874  95220  78322  95218 129930  94588
             94526 127754 128794 123402 124442 126522 115738 117818 121978 100410 104570 112890
             69754  78074  94714  94398 123216 127148 123208 127142 123204 123202 115408 123244
            115400 123238 115396 115394  99792 115436  99784 115430  99780  99778  68560  99820
             68552  99814  68548  68546  68588  68582 127400 129238  72444 127396  72318 127394
            123176 127126 123752 123172 123748 123170 123746 115304 123190 116456 115300 116452
            115298 116450  99560 115318 101864  99556 101860  99554 101858  68072  99574  72680
             68068  72676  68066  72674  68086  72694 129492  80632 105854 129490  80508  80446
            127380  72062 127924 127378  80766 127922 123156 123700 123154 124788 123698 124786
            115252 116340 115250 118516 116338 118514  99444 101620  99442 105972 101618 105970
             67828  72180  67826  80884  72178  80882  97008 114044  96888 113982  96828  96798
            129482  80252 130010  97148  80190  97086 127370 127898 128954 123146 123674 124730
            126842 115226 116282 118394 122618  99386 101498 105722 114170  67706  71930  80378
             96632 113854  96572  96542  80062  96702  96444  96414  96350 123048 123044 123042
            115048 123062 115044 115042  99048 115062  99044  99042  67048  99062  67044  67042
             67062 127188  68990 127186 123028 123316 123026 123314 114996 115572 114994 115570
             98932 100084  98930 100082  66804  69108  66802  69106 129258  73084  73022 127178
            127450 123018 123290 123834 114970 115514 116602  98874  99962 102138  66682  68858
             73210  81272 106174  81212  81182  72894  81342  97648 114364  97592 114334  97564
             97550  81084  97724  81054  97694  97464 114270  97436  97422  80990  97502  97372
             97358  97326 114868 114866  98676  98674  66292  66290 123098 114842 115130  98618
             99194  66170  67322  69310  73404  73374  81592 106334  81564  81550  73310  81630
             97968 114524  97944 114510  97932  97926  81500  98012  81486  97998  97880 114478
             97868  97862  81454  97902  97836  97830  69470  73564  73550  81752 106414  81740
             81734  73518  81774  81708  81702
        ] [
            109536 120312  86976 109040 120060  86496 108792 119934  86256 108668  86136 129744
             89056 110072 129736  88560 109820 129732  88312 109694 129730  88188 128464 129772
             89592 128456 129766  89340 128452  89214 128450 125904 128492 125896 128486 125892
            125890 120784 125932 120776 125926 120772 120770 110544 120812 110536 120806 110532
             84928 108016 119548  84448 107768 119422  84208 107644  84088 107582  84028 129640
             85488 108284 129636  85240 108158 129634  85116  85054 128232 129654  85756 128228
             85630 128226 125416 128246 125412 125410 119784 125430 119780 119778 108520 119798
            108516 108514  83424 107256 119166  83184 107132  83064 107070  83004  82974 129588
             83704 107390 129586  83580  83518 128116  83838 128114 125172 125170 119284 119282
            107508 107506  82672 106876  82552 106814  82492  82462 129562  82812  82750 128058
            125050 119034  82296 106686  82236  82206  82366  82108  82078  76736 103920 117500
             76256 103672 117374  76016 103548  75896 103486  75836 129384  77296 104188 129380
             77048 104062 129378  76924  76862 127720 129398  77564 127716  77438 127714 124392
            127734 124388 124386 117736 124406 117732 117730 104424 117750 104420 104418 112096
            121592 126334  92608 111856 121468  92384 111736 121406  92272 111676  92216 111646
             92188  75232 103160 117118  93664  74992 103036  93424 112252 102974  93304  74812
             93244  74782  93214 129332  75512 103294 129908 129330  93944  75388 129906  93820
             75326  93758 127604  75646 128756 127602  94078 128754 124148 126452 124146 126450
            117236 121844 117234 121842 103412 103410  91584 111344 121212  91360 111224 121150
             91248 111164  91192 111134  91164  91150  74480 102780  91888  74360 102718  91768
            111422  91708  74270  91678 129306  74620 129850  92028  74558  91966 127546 128634
            124026 126202 116986 121338 102906  90848 110968 121022  90736 110908  90680 110878
             90652  90638  74104 102590  91000  74044  90940  74014  90910  74174  91070  90480
            110780  90424 110750  90396  90382  73916  90556  73886  90526  90296 110686  90268
             90254  73822  90334  90204  90190  71136 101112 116094  70896 100988  70776 100926
             70716  70686 129204  71416 101246 129202  71292  71230 127348  71550 127346 123636
            123634 116212 116210 101364 101362  79296 105200 118140  79072 105080 118078  78960
            105020  78904 104990  78876  78862  70384 100732  79600  70264 100670  79480 105278
             79420  70174  79390 129178  70524 129466  79740  70462  79678 127290 127866 123514
            124666 115962 118266 100858 113376 122232 126654  95424 113264 122172  95328 113208
            122142  95280 113180  95256 113166  95244  78560 104824 117950  95968  78448 104764
             95856 113468 104734  95800  78364  95772  78350  95758  70008 100542  78712  69948
             96120  78652  69918  96060  78622  96030  70078  78782  96190  94912 113008 122044
             94816 112952 122014  94768 112924  94744 112910  94732  94726  78192 104636  95088
             78136 104606  95032 113054  95004  78094  94990  69820  78268  69790  95164  78238
             95134  94560 112824 121950  94512 112796  94488 112782  94476  94470  78008 104542
             94648  77980  94620  77966  94606  69726  78046  94686  94384 112732  94360 112718
             94348  94342  77916  94428  77902  94414  94296 112686  94284  94278  77870  94318
             94252  94246  68336  99708  68216  99646  68156  68126  68476  68414 127162 123258
            115450  99834  72416 101752 116414  72304 101692  72248 101662  72220  72206  67960
             99518  72568  67900  72508  67870  72478  68030  72638  80576 105840 118460  80480
            105784 118430  80432 105756  80408 105742  80396  80390  72048 101564  80752  71992
            101534  80696  71964  80668  71950  80654  67772  72124  67742  80828  72094  80798
            114016 122552 126814  96832 113968 122524  96800 113944 122510  96784 113932  96776
            113926  96772  80224 105656 118366  97120  80176 105628  97072 114076 105614  97048
             80140  97036  80134  97030  71864 101470  80312  71836  97208  80284  71822  97180
             80270  97166  67678  71902  80350  97246  96576 113840 122460  96544 113816 122446
             96528 113804  96520 113798  96516  96514  80048 105564  96688  80024 105550  96664
            113870  96652  80006  96646  71772  80092  71758  96732  80078  96718  96416 113752
            122414  96400 113740  96392 113734  96388  96386  79960 105518  96472  79948  96460
             79942  96454  71726  79982  96494  96336 113708  96328 113702  96324  96322  79916
             96364  79910  96358  96296 113686  96292  96290  79894  96310  66936  99006  66876
             66846  67006  68976 100028  68920  99998  68892  68878  66748  69052  66718  69022
             73056 102072 116574  73008 102044  72984 102030  72972  72966  68792  99934  73144
             68764  73116  68750  73102  66654  68830  73182  81216 106160 118620  81184 106136
            118606  81168 106124  81160 106118  81156  81154  72880 101980  81328  72856 101966
             81304 106190  81292  72838  81286  68700  72924  68686  81372  72910  81358 114336
            122712 126894 114320 122700 114312 122694 114308 114306  81056 106072 118574  97696
             81040 106060  97680 114380 106054  97672  81028  97668  81026  97666  72792 101934
             81112  72780  97752  81100  72774  97740  81094  97734  68654  72814  81134  97774
            114256 122668 114248 122662 114244 114242  80976 106028  97488  80968 106022  97480
            114278  97476  80962  97474  72748  81004  72742  97516  80998  97510 114216 122646
            114212 114210  80936 106006  97384  80932  97380  80930  97378  72726  80950  97398
            114196 114194  80916  97332  80914  97330  66236  66206  67256  99166  67228  67214
             66142  67294  69296 100188  69272 100174  69260  69254  67164  69340  67150  69326
             73376 102232 116654  73360 102220  73352 102214  73348  73346  69208 100142  73432
            102254  73420  69190  73414  67118  69230  73454 106320 118700 106312 118694 106308
            106306  73296 102188  81616 106348 102182  81608  73284  81604  73282  81602  69164
             73324  69158  81644  73318  81638 122792 126934 122788 122786 106280 118678 114536
            106276 114532 106274 114530  73256 102166  81512  73252  98024  81508  73250  98020
             81506  98018  69142  73270  81526  98038 122772 122770 106260 114484 106258 114482
             73236  81460  73234  97908  81458  97906 122762 106250 114458  73226  81434  97850
             66396  66382  67416  99246  67404  67398  66350  67438  69456 100268  69448 100262
             69444  69442  67372  69484  67366  69478 102312 116694 102308 102306  69416 100246
             73576 102326  73572  69410  73570  67350  69430  73590 118740 118738 102292 106420
            102290 106418  69396  73524  69394  81780  73522  81778 118730 102282 106394  69386
             73498  81722  66476  66470  67496  99286  67492  67490  66454  67510 100308 100306
             67476  69556  67474  69554 116714
        ]
    ] def

    % Return the 17 bits for a codeword in a given cluster
    /cwtobits {
        clusters exch get exch get /v exch def
        [ 17 {0} repeat v 2 17 string cvrs {48 sub} forall ]
        dup length 17 sub 17 getinterval
    } bind def

    % Populate bitmap for the image
    compact {
        /rwid 17 c mul 17 add 17 add 1 add def
    } {
        /rwid 17 c mul 17 add 17 add 17 add 18 add def
    } ifelse
    /pixs rwid r mul array def

   0 1 r 1 sub {
        /i exch def

        i 3 mod 0 eq {
            /lcw i 3 idiv 30 mul r 1 sub 3 idiv add def
            /rcw i 3 idiv 30 mul c add 1 sub def
        } if
        i 3 mod 1 eq {
            /lcw i 3 idiv 30 mul eclevel 3 mul add r 1 sub 3 mod add def
            /rcw i 3 idiv 30 mul r 1 sub 3 idiv add def
        } if
        i 3 mod 2 eq {
            /lcw i 3 idiv 30 mul c add 1 sub def
            /rcw i 3 idiv 30 mul eclevel 3 mul add r 1 sub 3 mod add def
        } if

        pixs rwid i mul [
            1 1 1 1 1 1 1 1 0 1 0 1 0 1 0 0 0
            lcw i 3 mod cwtobits {} forall
            cws c i mul c getinterval { i 3 mod cwtobits {} forall } forall
            compact {
                1
            } {
                rcw i 3 mod cwtobits {} forall
                1 1 1 1 1 1 1 0 1 0 0 0 1 0 1 0 0 1
            } ifelse
        ] putinterval

    } for

    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx rwid
    /pixy r
    /height r 72 div rowmult mul
    /width rwid 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/pdf417 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER pdf417--

% --BEGIN ENCODER pdf417compact--
% --REQUIRES preamble raiseerror renmatrix pdf417--
% --DESC: Compact PDF417
% --EXAM: This is compact PDF417
% --EXOP: columns=2
% --RNDR: renmatrix
%%BeginResource: uk.co.terryburton.bwipp pdf417compact 0.0 2015050900 60668 60355
%%BeginData:         43 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /pdf417 dup /uk.co.terryburton.bwipp findresource put
begin
/pdf417compact {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Get the result of encoding with pdf417 with compact option
    options (dontdraw) true put
    options (compact) true put

    /args barcode options //pdf417 exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/pdf417compact dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER pdf417compact--

% --BEGIN ENCODER micropdf417--
% --REQUIRES preamble raiseerror renmatrix--
% --DESC: MicroPDF417
% --EXAM: MicroPDF417
% --EXOP:
% --RNDR: renmatrix
%%BeginResource: uk.co.terryburton.bwipp micropdf417 0.0 2015050900 200331 213151
%%BeginData:        952 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/micropdf417 {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /columns 0 def
    /rows 0 def
    /rowmult 2 def
    /encoding (auto) def
    /cca false def
    /ccb false def
    /raw false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /columns columns cvi def
    /rows rows cvi def
    /rowmult rowmult cvr def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    raw {/encoding (raw) def} if
    cca {/encoding (cca) def} if

    % Convert input into array of codewords
    encoding (raw) eq encoding (cca) eq or {
        /datcws barcode length array def
        /i 0 def /j 0 def
        { % loop
            i barcode length eq {exit} if
            /cw barcode i 1 add 3 getinterval cvi def
            datcws j cw put
            /i i 4 add def
            /j j 1 add def
        } loop
        /datcws datcws 0 j getinterval def
    } if

    /barcode [ barcode {} forall ] def
    /barlen barcode length def

    ccb {/encoding (ccb) def} if

    /encb {
        /in exch def
        /inlen in length def
        /out inlen 6 idiv 5 mul inlen 6 mod add array def
        0 1 inlen 6 idiv 1 sub {
            /k exch def
            /msbs [ in k 6 mul 3 getinterval aload pop ] def
            /mscs [
                msbs aload pop exch 256 mul add exch 65536 mul add
                3 {dup 900 mod exch 900 idiv} repeat
            ] def
            /lsbs [ in k 6 mul 3 add 3 getinterval aload pop ] def
            /lscs [
                lsbs aload pop exch 256 mul add exch 65536 mul add
                3 {dup 900 mod exch 900 idiv} repeat
            ] def
            lscs 0 get mscs 0 get 316 mul add
            out k 5 mul 4 add 2 index 900 mod put
            900 idiv lscs 1 get add mscs 0 get 641 mul add mscs 1 get 316 mul add
            out k 5 mul 3 add 2 index 900 mod put
            900 idiv lscs 2 get add mscs 0 get 20 mul add mscs 1 get 641 mul add mscs 2 get 316 mul add
            out k 5 mul 2 add 2 index 900 mod put
            900 idiv lscs 3 get add mscs 1 get 20 mul add mscs 2 get 641 mul add
            out k 5 mul 1 add 2 index 900 mod put
            900 idiv mscs 2 get 20 mul add
            out k 5 mul 3 -1 roll 900 mod put
        } for
        /rem inlen 6 mod def
        rem 0 ne {
            out out length rem sub
            [ in inlen rem sub rem getinterval aload pop ]
            putinterval
        } if
        out
    } bind def

    encoding (byte) eq encoding (ccb) eq or {
        /datcws barlen 6 idiv 5 mul barlen 6 mod add 1 add array def
        datcws 0 barlen 6 mod 0 eq {924} {901} ifelse put
        datcws 1 barcode encb putinterval
        encoding (ccb) eq {/datcws [920 datcws aload pop] def} if
    } if

    encoding (auto) eq {

        % Modes and text submodes
        /T 0 def  /N 1 def  /B 2 def
        /A 0 def  /L 1 def  /M 2 def  /P 3 def
        
        % Special function characters for mode switching
        /tl -1 def  /nl -2 def  /bl -3 def  /bl6 -4 def  /bs -5 def
        
        % Special function characters for text mode
        /al -6 def  /ll -7 def  /ml -8 def  /pl -9 def  /as -10 def  /ps -11 def
        
        % Character maps for each state
        /charmaps [
          %  A    L    M    P
          [ (A)  (a)  (0)  (;) ]  % 0
          [ (B)  (b)  (1)  (<) ]  % 1
          [ (C)  (c)  (2)  (>) ]  % 2
          [ (D)  (d)  (3)  (@) ]  % 3
          [ (E)  (e)  (4)  ([) ]  % 4
          [ (F)  (f)  (5)   92 ]  % 5
          [ (G)  (g)  (6)  (]) ]  % 6
          [ (H)  (h)  (7)  (_) ]  % 7
          [ (I)  (i)  (8)  (`) ]  % 8
          [ (J)  (j)  (9)  (~) ]  % 9
          [ (K)  (k)  (&)  (!) ]  % 10
          [ (L)  (l)   13   13 ]  % 11
          [ (M)  (m)    9    9 ]  % 12
          [ (N)  (n)  (,)  (,) ]  % 13
          [ (O)  (o)  (:)  (:) ]  % 14
          [ (P)  (p)  (#)   10 ]  % 15
          [ (Q)  (q)  (-)  (-) ]  % 16
          [ (R)  (r)  (.)  (.) ]  % 17
          [ (S)  (s)  ($)  ($) ]  % 18
          [ (T)  (t)  (/)  (/) ]  % 19
          [ (U)  (u)  (+)  (") ]  % 20
          [ (V)  (v)  (%)  (|) ]  % 21
          [ (W)  (w)  (*)  (*) ]  % 22
          [ (X)  (x)  (=)   40 ]  % 23
          [ (Y)  (y)  (^)   41 ]  % 24
          [ (Z)  (z)   pl  (?) ]  % 25
          [ ( )  ( )  ( )  ({) ]  % 26
          [  ll   as   ll  (}) ]  % 27
          [  ml   ml   al  (') ]  % 28
          [  ps   ps   ps   al ]  % 29
        ] def
        
        % Invert charmaps to give character to value maps for each state
        /charvals [ 30 dict 30 dict 30 dict 30 dict ] def
        /alltext 104 dict def
        0 1 charmaps length 1 sub {
          /i exch def
          /encs charmaps i get def
          0 1 3 {
            /j exch def
            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required
            dup charvals j get exch i put
            alltext exch -1 put
          } for
        } for
        
        /e 10000 def  % "Empty"
        
        /latlen [  % Bit length of latch between submodes
        % To:  A  L  M  P      From
            [  0  1  1  2 ]  % A
            [  2  0  1  2 ]  % L
            [  1  1  0  1 ]  % M
            [  1  2  2  0 ]  % P
        ] def
        
        /latseq [  % Latch sequences between submodes
        % To: A       L       M       P               From
            [ []      [ll]    [ml]    [ml pl]    ]  % A
            [ [ml al] []      [ml]    [ml pl]    ]  % L
            [ [al]    [ll]    []      [pl]       ]  % M
            [ [al]    [al ll] [al ml] []         ]  % P
        ] def
        
        /shftlen [  % Bit length of shift to submode
        % To:  A  L  M  P      From
            [  e  e  e  1 ]  % A
            [  1  e  e  1 ]  % L
            [  e  e  e  1 ]  % M
            [  e  e  e  e ]  % P
        ] def
        
        % Determine runlengths of digits
        /numdigits [ barlen {0} repeat 0 ] def
        /numtext   [ barlen {0} repeat 0 ] def
        /numbytes  [ barlen {0} repeat 0 ] def
        barlen 1 sub -1 0 {
            /i exch def
            barcode i get dup 48 ge exch 57 le and {
                numdigits i numdigits i 1 add get 1 add put
            } if
            alltext barcode i get known numdigits i get 13 lt and {
                numtext i numtext i 1 add get 1 add put
            } if
            numtext i get 5 lt numdigits i get 13 lt and {
                numbytes i numbytes i 1 add get 1 add put
            } if
        } for
        /numdigits numdigits 0 barlen getinterval def
        /numtext   numtext   0 barlen getinterval def
        /numbytes  numbytes  0 barlen getinterval def
        
        /seq [] def /seqlen 0 def /state B def /p 0 def {  % loop
            p barlen eq {exit} if
            /n numdigits p get def
            n 13 ge {
                /seq [
                    seq aload pop
                    nl
                    [ barcode p n getinterval aload pop ]
                ] def
                /state N def
                /p p n add def
                /seqlen seqlen 1 add n add def
            } {  % next
            /t numtext p get def
            t 5 ge {
                /seq [
                    seq aload pop
                    state T ne {tl} if
                    [ barcode p t getinterval aload pop ]
                ] def
                /state T def
                /p p t add def
                /seqlen seqlen 1 add t add def  % ish
            } {  % next
            /b numbytes p get def
            b 1 eq state T eq and {
                /seq [
                    seq aload pop
                    bs
                    [ barcode p get ]
                ] def
                /p p b add def
                /seqlen seqlen 2 add def
            } {  % next
                /seq [
                    seq aload pop
                    b 6 mod 0 ne {bl} {bl6} ifelse
                    [ barcode p b getinterval aload pop ]
                ] def
                /state B def
                /p p b add def
                /seqlen seqlen 1 add b add def
            } ifelse } ifelse } ifelse
        } loop
        
        /latchcws <<
            tl 900  bl 901  bl6 924  nl 902  bs 913
        >> def
        
        % Submode encoding functions
        /enca {charvals A get exch get} bind def
        /encl {charvals L get exch get} bind def
        /encm {charvals M get exch get} bind def
        /encp {charvals P get exch get} bind def
        /textencfuncs [ /enca /encl /encm /encp ] def
        
        /addtotext {
            text exch l exch put
            /l l 1 add def
        } bind def
        
        /enct {
        
            /in exch def
        
            /curlen [  e  e  e  e ] def
            curlen submode 0 put
            /curseq [ [] [] [] [] ] def
        
            % Derive the optimal sequences ending in each submode
            in {
        
                /char exch def
        
                % Check for optimisations in the current sequences by latching from x to y
                {  % loop
                    /imp false def
                    [ A L M P ] {
                        /x exch def
                        [ A L M P ] {
                            /y exch def
                            /cost curlen x get latlen x get y get add def
                            cost curlen y get lt {
                                curlen y cost put
                                curseq y [
                                    curseq x get aload pop
                                    latseq x get y get aload pop
                                ] put
                                /imp true def
                            } if
                        } forall
                    } forall
                    imp not {exit} if  % Repeat unless no improvement
                } loop
        
                % Determine optimal next sequences for each valid encoding
                /nxtlen [ e e e e ] def
                /nxtseq 4 array def
        
                [ A L M P ] {
                    /x exch def
        
                    { % loop for common exit
        
                        charvals x get char known not {exit} if
        
                        % Extend directly
                        /cost curlen x get 1 add def
                        cost nxtlen x get lt {
                            nxtlen x cost put
                            nxtseq x [ curseq x get aload pop char ] put
                        } if
        
                        % Optimise for direct shifts from y to x
                        [ A L M P ] {
                            /y exch def
                            x y ne {
                                /cost curlen y get shftlen y get x get add 1 add def
                                cost nxtlen y get lt {
                                    nxtlen y cost put
                                    nxtseq y [
                                        curseq y get aload pop
                                        x A eq {as} {ps} ifelse
                                        char
                                    ] put
                                } if
                            } if
                        } forall
        
                        exit
                    } loop
        
                } forall
        
                /curlen nxtlen def
                /curseq nxtseq def
        
            } forall
        
            % Select the optimal sequence
            /minseq e def
            [ A L M P ] {
                /k exch def
                curlen k get minseq lt {
                    /minseq curlen k get def
                    /txtseq curseq k get def
                } if
            } forall
        
            % Encode the sequence
            /text minseq array def
            /k 0 def /l 0 def {
                k txtseq length ge {exit} if
        
                /char txtseq k get def
        
                % Encode character
                char textencfuncs submode get load exec addtotext
                /k k 1 add def
        
                % Encode shifted next character
                char as eq char ps eq or {
                    txtseq k get char as eq {enca} {encp} ifelse addtotext
                    /k k 1 add def
                } if
        
                % Latches to new submode
                char al eq {/submode A def} if
                char ll eq {/submode L def} if
                char ml eq {/submode M def} if
                char pl eq {/submode P def} if
            } loop
        
            text length 2 mod 1 eq {
                submode P eq {
                    /pad al encp def
                    /submode A def
                } {
                    /pad ps textencfuncs submode get load exec def
                } ifelse
                /text [ text aload pop pad ] def
            } if
        
            /out text length 2 idiv array def
            0 1 out length 1 sub {
                /k exch def
                out k text k 2 mul get 30 mul text k 2 mul 1 add get add put
            } for
        
            out
        
        } bind def
        
        /encn {
            /in exch def
            /out [] def
            0 44 in length 1 sub {
                /k exch def
                /gmod [
                    1 in k in length k sub dup 44 gt {pop 44} if getinterval
                    {48 sub} forall
                ] def
                /cwn [] def {
                    /dv 900 def
                    /gmul [] def /val 0 def {
                        gmod length 0 eq {exit} if
                        /val val 10 mul gmod 0 get add def
                        /gmod gmod 1 gmod length 1 sub getinterval def
                        val dv lt {
                            gmul length 0 ne {
                                /gmul [ gmul aload pop 0 ] def
                            } if
                        } {
                            /gmul [ gmul aload pop val dv idiv ] def
                        } ifelse
                        /val val dv mod def
                    } loop
                    /dv val def
                    /cwn [ dv cwn aload pop ] def
                    /gmod gmul def
                    gmul length 0 eq {exit} if
                } loop
                /out [ out aload pop cwn aload pop ] def
            } for
            out
        } bind def
       
        /encfuncs [ /enct /encn /encb ] def
        
        /addtocws {
            dup datcws j 3 -1 roll putinterval
            length j add /j exch def
        } bind def
        
        % Encode the sequence
        /state T def /submode A def
        /datcws seqlen array def
        /i 0 def /j 0 def {
            i seq length ge {exit} if
            /chars seq i get def
            chars type /arraytype eq {  % Encode data according to mode
                chars encfuncs state get load exec addtocws
            } {  % Encode the latch to new state or byte shift
                [ latchcws chars get ] addtocws
                chars tl eq {/state T def /submode A def} if
                chars nl eq {/state N def} if
                chars bl eq chars bl6 eq or {/state B def} if
                chars bs eq {
                    /i i 1 add def
                    seq i get encb addtocws
                } if
            } ifelse
            /i i 1 add def
        } loop
        /datcws datcws 0 j getinterval def
    } if

    % Basic metrics for the each symbol
    %     c  r ecw  rl rc rr
    /metrics [
        [ 1 11   7   1  0  9 ]
        [ 1 14   7   8  0  8 ]
        [ 1 17   7  36  0 36 ]
        [ 1 20   8  19  0 19 ]
        [ 1 24   8   9  0 17 ]
        [ 1 28   8  25  0 33 ]
        [ 2  8   8   1  0  1 ]
        [ 2 11   9   1  0  9 ]
        [ 2 14   9   8  0  8 ]
        [ 2 17  10  36  0 36 ]
        [ 2 20  11  19  0 19 ]
        [ 2 23  13   9  0 17 ]
        [ 2 26  15  27  0 35 ]
        [ 3  6  12   1  1  1 ]
        [ 3  8  14   7  7  7 ]
        [ 3 10  16  15 15 15 ]
        [ 3 12  18  25 25 25 ]
        [ 3 15  21  37 37 37 ]
        [ 3 20  26   1 17 33 ]
        [ 3 26  32   1  9 17 ]
        [ 3 32  38  21 29 37 ]
        [ 3 38  44  15 31 47 ]
        [ 3 44  50   1 25 49 ]
        [ 4  4   8  47 19 43 ]
        [ 4  6  12   1  1  1 ]
        [ 4  8  14   7  7  7 ]
        [ 4 10  16  15 15 15 ]
        [ 4 12  18  25 25 25 ]
        [ 4 15  21  37 37 37 ]
        [ 4 20  26   1 17 33 ]
        [ 4 26  32   1  9 17 ]
        [ 4 32  38  21 29 37 ]
        [ 4 38  44  15 31 47 ]
        [ 4 44  50   1 25 49 ]
    ] def

    % Basic metrics for the each symbol
    %     c  r ecw  rl rc rr
    /ccametrics [
        [ 2  5   4  39  0 19 ]
        [ 2  6   4   1  0 33 ]
        [ 2  7   5  32  0 12 ]
        [ 2  8   5   8  0 40 ]
        [ 2  9   6  14  0 46 ]
        [ 2 10   6  43  0 23 ]
        [ 2 12   7  20  0 52 ]
        [ 3  4   4  11 43 23 ]
        [ 3  5   5   1 33 13 ]
        [ 3  6   6   5 37 17 ]
        [ 3  7   7  15 47 27 ]
        [ 3  8   7  21  1 33 ]
        [ 4  3   4  40 20 52 ]
        [ 4  4   5  43 23  3 ]
        [ 4  5   6  46 26  6 ]
        [ 4  6   7  34 14 46 ]
        [ 4  7   8  29  9 41 ]
    ] def
    cca {/metrics ccametrics def} if

    % Select metrics of an appropriate symbol
    /urows rows def
    /ucols columns def
    /i 0 def
    { % loop
        /m metrics i get def
        /c    m 0 get def        % Columns in symbol
        /r    m 1 get def        % Rows in symbol
        /k    m 2 get def        % Error correction codewords
        /rapl m 3 get def        % Left row address pattern
        /rapc m 4 get def        % Centre row address pattern
        /rapr m 5 get def        % Right row address pattern
        /ncws r c mul k sub def  % Data codewords
        /okay true def
        datcws length ncws gt     {/okay false def} if
        urows 0 ne urows r ne and {/okay false def} if
        ucols 0 ne ucols c ne and {/okay false def} if
        okay {exit} if
        /i i 1 add def
    } loop
    /m datcws length def

    % Create codewords array with one extra working space element and add padding
    /n c r mul k sub def
    /cws c r mul 1 add array def
    cws 0 datcws putinterval
    cws m [ n m sub {900} repeat ] putinterval
    cws n [ k {0} repeat 0 ] putinterval

    % Calculate the log and anti-log tables
    /rsalog [ 1 928 {dup 3 mul 929 mod} repeat ] def
    /rslog 929 array def
    1 1 928 {dup rsalog exch get exch rslog 3 1 roll put} for

    % Function to calculate the product in the field
    /rsprod {
        2 copy 0 ne exch 0 ne and {
            rslog exch get exch rslog exch get add 928 mod rsalog exch get
        } {
            pop pop 0
        } ifelse
    } bind def

    % Generate the coefficients
    /coeffs [ 1 k {0} repeat ] def
    1 1 k {
        /i exch def 
        coeffs i coeffs i 1 sub get put
        i 1 sub -1 1 {
            /j exch def
            coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod add 929 mod put
        } for 
        coeffs 0 coeffs 0 get rsalog i get rsprod put
    } for
    /coeffs coeffs 0 coeffs length 1 sub getinterval def
    coeffs length 1 sub -2 0 {coeffs exch 2 copy get 929 exch sub put} for

    % Derive the error codewords
    0 1 n 1 sub {
        /t exch cws exch get cws n get add 929 mod def
        0 1 k 1 sub {
            /j exch def
            cws n j add cws n j add 1 add get 929 t coeffs k j sub 1 sub get mul 929 mod sub add 929 mod put
        } for
    } for
    n 1 n k add { dup cws exch 929 cws 5 -1 roll get sub 929 mod put } for

    % Trim the working space from the end of the codewords
    /cws cws 0 cws length 1 sub getinterval def

    % Base 10 encoding of the bar space successions for the codewords in each cluster
    /clusters [
        [
            120256 125680 128380 120032 125560 128318 108736 119920 108640  86080 108592  86048
            110016 120560 125820 109792 120440 125758  88256 109680  88160  89536 110320 120700
             89312 110200 120638  89200 110140  89840 110460  89720 110398  89980 128506 119520
            125304 128190 107712 119408 125244 107616 119352  84032 107568 119324  84000 107544
             83984 108256 119672 125374  85184 108144 119612  85088 108088 119582  85040 108060
             85728 108408 119742  85616 108348  85560 108318  85880 108478  85820  85790 107200
            119152 125116 107104 119096 125086  83008 107056 119068  82976 107032  82960  82952
             83648 107376 119228  83552 107320 119198  83504 107292  83480  83468  83824 107452
             83768 107422  83740  83900 106848 118968 125022  82496 106800 118940  82464 106776
            118926  82448 106764  82440 106758  82784 106936 119006  82736 106908  82712 106894
             82700  82694 106974  82830  82240 106672 118876  82208 106648 118862  82192 106636
             82184 106630  82180  82352  82328  82316  82080 118830 106572 106566  82050 117472
            124280 127678 103616 117360 124220 103520 117304 124190  75840 103472  75808 104160
            117624 124350  76992 104048 117564  76896 103992  76848  76824  77536 104312 117694
             77424 104252  77368  77340  77688 104382  77628  77758 121536 126320 128700 121440
            126264 128670 111680 121392 126236 111648 121368 126222 111632 121356 103104 117104
            124092 112320 103008 117048 124062 112224 121656 126366  93248  74784 102936 117006
             93216 112152  93200  75456 103280 117180  93888  75360 103224 117150  93792 112440
            121758  93744  75288  93720  75632 103356  94064  75576 103326  94008 112542  93980
             75708  94140  75678  94110 121184 126136 128606 111168 121136 126108 111136 121112
            126094 111120 121100 111112 111108 102752 116920 123998 111456 102704 116892  91712
             74272 121244 116878  91680  74256 102668  91664 111372 102662  74244  74592 102840
            116958  92000  74544 102812  91952 111516 102798  91928  74508  74502  74680 102878
             92088  74652  92060  74638  92046  92126 110912 121008 126044 110880 120984 126030
            110864 120972 110856 120966 110852 110850  74048 102576 116828  90944  74016 102552
            116814  90912 111000 121038  90896  73992 102534  90888 110982  90884  74160 102620
             91056  74136 102606  91032 111054  91020  74118  91014  91100  91086 110752 120920
            125998 110736 120908 110728 120902 110724 110722  73888 102488 116782  90528  73872
            102476  90512 110796 102470  90504  73860  90500  73858  73944  90584  90572  90566
            120876 120870 110658 102444  73800  90312  90308  90306 101056 116080 123580 100960
            116024  70720 100912 115996  70688 100888  70672  70664  71360 101232 116156  71264
            101176 116126  71216 101148  71192  71180  71536 101308  71480 101278  71452  71612
             71582 118112 124600 127838 105024 118064 124572 104992 118040 124558 104976 118028
            104968 118022 100704 115896 123486 105312 100656 115868  79424  70176 118172 115854
             79392 105240 100620  79376  70152  79368  70496 100792 115934  79712  70448 118238
             79664 105372 100750  79640  70412  79628  70584 100830  79800  70556  79772  70542
             70622  79838 122176 126640 128860 122144 126616 128846 122128 126604 122120 126598
            122116 104768 117936 124508 113472 104736 126684 124494 113440 122264 126670 113424
            104712 117894 113416 122246 104706  69952 100528 115804  78656  69920 100504 115790
             96064  78624 104856 117966  96032 113560 122318 100486  96016  78600 104838  96008
             69890  70064 100572  78768  70040 100558  96176  78744 104910  96152 113614  70022
             78726  70108  78812  70094  96220  78798 122016 126552 128814 122000 126540 121992
            126534 121988 121986 104608 117848 124462 113056 104592 126574 113040 122060 117830
            113032 104580 113028 104578 113026  69792 100440 115758  78240  69776 100428  95136
             78224 104652 100422  95120 113100  69764  95112  78212  69762  78210  69848 100462
             78296  69836  95192  78284  69830  95180  78278  69870  95214 121936 126508 121928
            126502 121924 121922 104528 117804 112848 104520 117798 112840 121958 112836 104514
            112834  69712 100396  78032  69704 100390  94672  78024 104550  94664 112870  69698
             94660  78018  94658  78060  94700  94694 126486 121890 117782 104484 104482  69672
             77928  94440  69666  77922  99680  68160  99632  68128  99608 115342  68112  99596
             68104  99590  68448  99768 115422  68400  99740  68376  99726  68364  68358  68536
             99806  68508  68494  68574 101696 116400 123740 101664 116376 101648 116364 101640
            116358 101636  67904  99504 115292  72512  67872 116444 115278  72480 101784 116430
             72464  67848  99462  72456 101766  67842  68016  99548  72624  67992  99534  72600
            101838  72588  67974  68060  72668  68046  72654 118432 124760 127918 118416 124748
            118408 124742 118404 118402 101536 116312 105888 101520 116300 105872 118476 116294
            105864 101508 105860 101506 105858  67744  99416  72096  67728 116334  80800  72080
            101580  99398  80784 105932  67716  80776  72068  67714  72066  67800  99438  72152
             67788  80856  72140  67782  80844  72134  67822  72174  80878 126800 128940 126792
            128934 126788 126786 118352 124716 122576 126828 124710 122568 126822 122564 118338
            122562 101456 116268 105680 101448 116262 114128 105672 118374 114120 122598 101442
            114116 105666 114114  67664  99372  71888  67656  99366  80336  71880 101478  97232
             80328 105702  67650  97224 114150  71874  97220  67692  71916  67686  80364  71910
             97260  80358  97254 126760 128918 126756 126754 118312 124694 122472 126774 122468
            118306 122466 101416 116246 105576 101412 113896 105572 101410 113892 105570 113890
             67624  99350  71784 101430  80104  71780  67618  96744  80100  71778  96740  80098
             96738  71798  96758 126738 122420 122418 105524 113780 113778  71732  79988  96500
             96498  66880  66848  98968  66832  66824  66820  66992  66968  66956  66950  67036
             67022 100000  99984 115532  99976 115526  99972  99970  66720  98904  69024 100056
             98892  69008 100044  69000 100038  68996  66690  68994  66776  98926  69080 100078
             69068  66758  69062  66798  69102 116560 116552 116548 116546  99920 102096 116588
            115494 102088 116582 102084  99906 102082  66640  68816  66632  98854  73168  68808
             66628  73160  68804  66626  73156  68802  66668  68844  66662  73196  68838  73190
            124840 124836 124834 116520 118632 124854 118628 116514 118626  99880 115478 101992
            116534 106216 101988  99874 106212 101986 106210  66600  98838  68712  99894  72936
             68708  66594  81384  72932  68706  81380  72930  66614  68726  72950  81398 128980
            128978 124820 126900 124818 126898 116500 118580 116498 122740 118578 122738  99860
            101940  99858 106100 101938 114420
        ] [
            128352 129720 125504 128304 129692 125472 128280 129678 125456 128268 125448 128262
            125444 125792 128440 129758 120384 125744 128412 120352 125720 128398 120336 125708
            120328 125702 120324 120672 125880 128478 110144 120624 125852 110112 120600 125838
            110096 120588 110088 120582 110084 110432 120760 125918  89664 110384 120732  89632
            110360 120718  89616 110348  89608 110342  89952 110520 120798  89904 110492  89880
            110478  89868  90040 110558  90012  89998 125248 128176 129628 125216 128152 129614
            125200 128140 125192 128134 125188 125186 119616 125360 128220 119584 125336 128206
            119568 125324 119560 125318 119556 119554 108352 119728 125404 108320 119704 125390
            108304 119692 108296 119686 108292 108290  85824 108464 119772  85792 108440 119758
             85776 108428  85768 108422  85764  85936 108508  85912 108494  85900  85894  85980
             85966 125088 128088 129582 125072 128076 125064 128070 125060 125058 119200 125144
            128110 119184 125132 119176 125126 119172 119170 107424 119256 125166 107408 119244
            107400 119238 107396 107394  83872 107480 119278  83856 107468  83848 107462  83844
             83842  83928 107502  83916  83910  83950 125008 128044 125000 128038 124996 124994
            118992 125036 118984 125030 118980 118978 106960 119020 106952 119014 106948 106946
             82896 106988  82888 106982  82884  82882  82924  82918 124968 128022 124964 124962
            118888 124982 118884 118882 106728 118902 106724 106722  82408 106742  82404  82402
            124948 124946 118836 118834 106612 106610 124224 127664 129372 124192 127640 129358
            124176 127628 124168 127622 124164 124162 117568 124336 127708 117536 124312 127694
            117520 124300 117512 124294 117508 117506 104256 117680 124380 104224 117656 124366
            104208 117644 104200 117638 104196 104194  77632 104368 117724  77600 104344 117710
             77584 104332  77576 104326  77572  77744 104412  77720 104398  77708  77702  77788
             77774 128672 129880  93168 128656 129868  92664 128648 129862  92412 128644 128642
            124064 127576 129326 126368 124048 129902 126352 128716 127558 126344 124036 126340
            124034 126338 117152 124120 127598 121760 117136 124108 121744 126412 124102 121736
            117124 121732 117122 121730 103328 117208 124142 112544 103312 117196 112528 121804
            117190 112520 103300 112516 103298 112514  75680 103384 117230  94112  75664 103372
             94096 112588 103366  94088  75652  94084  75650  75736 103406  94168  75724  94156
             75718  94150  75758 128592 129836  91640 128584 129830  91388 128580  91262 128578
            123984 127532 126160 123976 127526 126152 128614 126148 123970 126146 116944 124012
            121296 116936 124006 121288 126182 121284 116930 121282 102864 116972 111568 102856
            116966 111560 121318 111556 102850 111554  74704 102892  92112  74696 102886  92104
            111590  92100  74690  92098  74732  92140  74726  92134 128552 129814  90876 128548
             90750 128546 123944 127510 126056 128566 126052 123938 126050 116840 123958 121064
            116836 121060 116834 121058 102632 116854 111080 121078 111076 102626 111074  74216
            102646  91112  74212  91108  74210  91106  74230  91126 128532  90494 128530 123924
            126004 123922 126002 116788 120948 116786 120946 102516 110836 102514 110834  73972
             90612  73970  90610 128522 123914 125978 116762 120890 102458 110714 123552 127320
            129198 123536 127308 123528 127302 123524 123522 116128 123608 127342 116112 123596
            116104 123590 116100 116098 101280 116184 123630 101264 116172 101256 116166 101252
            101250  71584 101336 116206  71568 101324  71560 101318  71556  71554  71640 101358
             71628  71622  71662 127824 129452  79352 127816 129446  79100 127812  78974 127810
            123472 127276 124624 123464 127270 124616 127846 124612 123458 124610 115920 123500
            118224 115912 123494 118216 124646 118212 115906 118210 100816 115948 105424 100808
            115942 105416 118246 105412 100802 105410  70608 100844  79824  70600 100838  79816
            105446  79812  70594  79810  70636  79852  70630  79846 129960  95728 113404 129956
             95480 113278 129954  95356  95294 127784 129430  78588 128872 129974  95996  78462
            128868 127778  95870 128866 123432 127254 124520 123428 126696 128886 123426 126692
            124514 126690 115816 123446 117992 115812 122344 117988 115810 122340 117986 122338
            100584 115830 104936 100580 113640 104932 100578 113636 104930 113634  70120 100598
             78824  70116  96232  78820  70114  96228  78818  96226  70134  78838 129940  94968
            113022 129938  94844  94782 127764  78206 128820 127762  95102 128818 123412 124468
            123410 126580 124466 126578 115764 117876 115762 122100 117874 122098 100468 104692
            100466 113140 104690 113138  69876  78324  69874  95220  78322  95218 129930  94588
             94526 127754 128794 123402 124442 126522 115738 117818 121978 100410 104570 112890
             69754  78074  94714  94398 123216 127148 123208 127142 123204 123202 115408 123244
            115400 123238 115396 115394  99792 115436  99784 115430  99780  99778  68560  99820
             68552  99814  68548  68546  68588  68582 127400 129238  72444 127396  72318 127394
            123176 127126 123752 123172 123748 123170 123746 115304 123190 116456 115300 116452
            115298 116450  99560 115318 101864  99556 101860  99554 101858  68072  99574  72680
             68068  72676  68066  72674  68086  72694 129492  80632 105854 129490  80508  80446
            127380  72062 127924 127378  80766 127922 123156 123700 123154 124788 123698 124786
            115252 116340 115250 118516 116338 118514  99444 101620  99442 105972 101618 105970
             67828  72180  67826  80884  72178  80882  97008 114044  96888 113982  96828  96798
            129482  80252 130010  97148  80190  97086 127370 127898 128954 123146 123674 124730
            126842 115226 116282 118394 122618  99386 101498 105722 114170  67706  71930  80378
             96632 113854  96572  96542  80062  96702  96444  96414  96350 123048 123044 123042
            115048 123062 115044 115042  99048 115062  99044  99042  67048  99062  67044  67042
             67062 127188  68990 127186 123028 123316 123026 123314 114996 115572 114994 115570
             98932 100084  98930 100082  66804  69108  66802  69106 129258  73084  73022 127178
            127450 123018 123290 123834 114970 115514 116602  98874  99962 102138  66682  68858
             73210  81272 106174  81212  81182  72894  81342  97648 114364  97592 114334  97564
             97550  81084  97724  81054  97694  97464 114270  97436  97422  80990  97502  97372
             97358  97326 114868 114866  98676  98674  66292  66290 123098 114842 115130  98618
             99194  66170  67322  69310  73404  73374  81592 106334  81564  81550  73310  81630
             97968 114524  97944 114510  97932  97926  81500  98012  81486  97998  97880 114478
             97868  97862  81454  97902  97836  97830  69470  73564  73550  81752 106414  81740
             81734  73518  81774  81708  81702
        ] [
            109536 120312  86976 109040 120060  86496 108792 119934  86256 108668  86136 129744
             89056 110072 129736  88560 109820 129732  88312 109694 129730  88188 128464 129772
             89592 128456 129766  89340 128452  89214 128450 125904 128492 125896 128486 125892
            125890 120784 125932 120776 125926 120772 120770 110544 120812 110536 120806 110532
             84928 108016 119548  84448 107768 119422  84208 107644  84088 107582  84028 129640
             85488 108284 129636  85240 108158 129634  85116  85054 128232 129654  85756 128228
             85630 128226 125416 128246 125412 125410 119784 125430 119780 119778 108520 119798
            108516 108514  83424 107256 119166  83184 107132  83064 107070  83004  82974 129588
             83704 107390 129586  83580  83518 128116  83838 128114 125172 125170 119284 119282
            107508 107506  82672 106876  82552 106814  82492  82462 129562  82812  82750 128058
            125050 119034  82296 106686  82236  82206  82366  82108  82078  76736 103920 117500
             76256 103672 117374  76016 103548  75896 103486  75836 129384  77296 104188 129380
             77048 104062 129378  76924  76862 127720 129398  77564 127716  77438 127714 124392
            127734 124388 124386 117736 124406 117732 117730 104424 117750 104420 104418 112096
            121592 126334  92608 111856 121468  92384 111736 121406  92272 111676  92216 111646
             92188  75232 103160 117118  93664  74992 103036  93424 112252 102974  93304  74812
             93244  74782  93214 129332  75512 103294 129908 129330  93944  75388 129906  93820
             75326  93758 127604  75646 128756 127602  94078 128754 124148 126452 124146 126450
            117236 121844 117234 121842 103412 103410  91584 111344 121212  91360 111224 121150
             91248 111164  91192 111134  91164  91150  74480 102780  91888  74360 102718  91768
            111422  91708  74270  91678 129306  74620 129850  92028  74558  91966 127546 128634
            124026 126202 116986 121338 102906  90848 110968 121022  90736 110908  90680 110878
             90652  90638  74104 102590  91000  74044  90940  74014  90910  74174  91070  90480
            110780  90424 110750  90396  90382  73916  90556  73886  90526  90296 110686  90268
             90254  73822  90334  90204  90190  71136 101112 116094  70896 100988  70776 100926
             70716  70686 129204  71416 101246 129202  71292  71230 127348  71550 127346 123636
            123634 116212 116210 101364 101362  79296 105200 118140  79072 105080 118078  78960
            105020  78904 104990  78876  78862  70384 100732  79600  70264 100670  79480 105278
             79420  70174  79390 129178  70524 129466  79740  70462  79678 127290 127866 123514
            124666 115962 118266 100858 113376 122232 126654  95424 113264 122172  95328 113208
            122142  95280 113180  95256 113166  95244  78560 104824 117950  95968  78448 104764
             95856 113468 104734  95800  78364  95772  78350  95758  70008 100542  78712  69948
             96120  78652  69918  96060  78622  96030  70078  78782  96190  94912 113008 122044
             94816 112952 122014  94768 112924  94744 112910  94732  94726  78192 104636  95088
             78136 104606  95032 113054  95004  78094  94990  69820  78268  69790  95164  78238
             95134  94560 112824 121950  94512 112796  94488 112782  94476  94470  78008 104542
             94648  77980  94620  77966  94606  69726  78046  94686  94384 112732  94360 112718
             94348  94342  77916  94428  77902  94414  94296 112686  94284  94278  77870  94318
             94252  94246  68336  99708  68216  99646  68156  68126  68476  68414 127162 123258
            115450  99834  72416 101752 116414  72304 101692  72248 101662  72220  72206  67960
             99518  72568  67900  72508  67870  72478  68030  72638  80576 105840 118460  80480
            105784 118430  80432 105756  80408 105742  80396  80390  72048 101564  80752  71992
            101534  80696  71964  80668  71950  80654  67772  72124  67742  80828  72094  80798
            114016 122552 126814  96832 113968 122524  96800 113944 122510  96784 113932  96776
            113926  96772  80224 105656 118366  97120  80176 105628  97072 114076 105614  97048
             80140  97036  80134  97030  71864 101470  80312  71836  97208  80284  71822  97180
             80270  97166  67678  71902  80350  97246  96576 113840 122460  96544 113816 122446
             96528 113804  96520 113798  96516  96514  80048 105564  96688  80024 105550  96664
            113870  96652  80006  96646  71772  80092  71758  96732  80078  96718  96416 113752
            122414  96400 113740  96392 113734  96388  96386  79960 105518  96472  79948  96460
             79942  96454  71726  79982  96494  96336 113708  96328 113702  96324  96322  79916
             96364  79910  96358  96296 113686  96292  96290  79894  96310  66936  99006  66876
             66846  67006  68976 100028  68920  99998  68892  68878  66748  69052  66718  69022
             73056 102072 116574  73008 102044  72984 102030  72972  72966  68792  99934  73144
             68764  73116  68750  73102  66654  68830  73182  81216 106160 118620  81184 106136
            118606  81168 106124  81160 106118  81156  81154  72880 101980  81328  72856 101966
             81304 106190  81292  72838  81286  68700  72924  68686  81372  72910  81358 114336
            122712 126894 114320 122700 114312 122694 114308 114306  81056 106072 118574  97696
             81040 106060  97680 114380 106054  97672  81028  97668  81026  97666  72792 101934
             81112  72780  97752  81100  72774  97740  81094  97734  68654  72814  81134  97774
            114256 122668 114248 122662 114244 114242  80976 106028  97488  80968 106022  97480
            114278  97476  80962  97474  72748  81004  72742  97516  80998  97510 114216 122646
            114212 114210  80936 106006  97384  80932  97380  80930  97378  72726  80950  97398
            114196 114194  80916  97332  80914  97330  66236  66206  67256  99166  67228  67214
             66142  67294  69296 100188  69272 100174  69260  69254  67164  69340  67150  69326
             73376 102232 116654  73360 102220  73352 102214  73348  73346  69208 100142  73432
            102254  73420  69190  73414  67118  69230  73454 106320 118700 106312 118694 106308
            106306  73296 102188  81616 106348 102182  81608  73284  81604  73282  81602  69164
             73324  69158  81644  73318  81638 122792 126934 122788 122786 106280 118678 114536
            106276 114532 106274 114530  73256 102166  81512  73252  98024  81508  73250  98020
             81506  98018  69142  73270  81526  98038 122772 122770 106260 114484 106258 114482
             73236  81460  73234  97908  81458  97906 122762 106250 114458  73226  81434  97850
             66396  66382  67416  99246  67404  67398  66350  67438  69456 100268  69448 100262
             69444  69442  67372  69484  67366  69478 102312 116694 102308 102306  69416 100246
             73576 102326  73572  69410  73570  67350  69430  73590 118740 118738 102292 106420
            102290 106418  69396  73524  69394  81780  73522  81778 118730 102282 106394  69386
             73498  81722  66476  66470  67496  99286  67492  67490  66454  67510 100308 100306
             67476  69556  67474  69554 116714
        ]
    ] def

    % Row address patterns
    /raps [
        [  % Left and right
            802 930 946 818 882 890 826 954 922 986 970 906 778
            794 786 914 978 982 980 916 948 932 934 942 940 936
            808 812 814 806 822 950 918 790 788 820 884 868 870
            878 876 872 840 856 860 862 846 844 836 838 834 866
        ] [  % Centre
            718 590 622 558 550 566 534 530 538 570 562 546 610
            626 634 762 754 758 630 628 612 614 582 578 706 738
            742 740 748 620 556 552 616 744 712 716 708 710 646
            654 652 668 664 696 688 656 720 592 600 604 732 734
        ]
    ] def

    % Return the 17 bits for a codeword in a given cluster
    /cwtobits {
        clusters exch get exch get /v exch def
        [ 17 {0} repeat v 2 17 string cvrs {48 sub} forall ]
        dup length 17 sub 17 getinterval
    } bind def

    % Return the 10 bits for a row address pattern
    /raptobits {
        raps exch get exch get /v exch def
        [ 10 {0} repeat v 2 10 string cvrs {48 sub} forall ]
        dup length 10 sub 10 getinterval
    } bind def

    % Populate bitmap for the image
    /rwid [38 55 82 99] c 1 sub get def
    c 3 eq cca and {/rwid 72 def} if
    /pixs rwid r mul array def

    0 1 r 1 sub {
        /i exch def
        /clst i rapl add 1 sub 3 mod def
        pixs rwid i mul [
            c 1 eq {
                i rapl add 1 sub 52 mod 0 raptobits aload pop
                cws i get clst cwtobits aload pop
                i rapr add 1 sub 52 mod 0 raptobits aload pop
            } if
            c 2 eq {
                i rapl add 1 sub 52 mod 0 raptobits aload pop
                cws i 2 mul get clst cwtobits aload pop
                cws i 2 mul 1 add get clst cwtobits aload pop
                i rapr add 1 sub 52 mod 0 raptobits aload pop
            } if
            c 3 eq {
                cca not {
                    i rapl add 1 sub 52 mod 0 raptobits aload pop
                } if
                cws i 3 mul get clst cwtobits aload pop
                i rapc add 1 sub 52 mod 1 raptobits aload pop
                cws i 3 mul 1 add get clst cwtobits aload pop
                cws i 3 mul 2 add get clst cwtobits aload pop
                i rapr add 1 sub 52 mod 0 raptobits aload pop
            } if
            c 4 eq {
                i rapl add 1 sub 52 mod 0 raptobits aload pop
                cws i 4 mul get clst cwtobits aload pop
                cws i 4 mul 1 add get clst cwtobits aload pop
                i rapc add 1 sub 52 mod 1 raptobits aload pop
                cws i 4 mul 2 add get clst cwtobits aload pop
                cws i 4 mul 3 add get clst cwtobits aload pop
                i rapr add 1 sub 52 mod 0 raptobits aload pop
            } if
            1
        ] putinterval
    } for

    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx rwid
    /pixy r
    /height r 72 div rowmult mul
    /width rwid 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/micropdf417 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER micropdf417--

% --BEGIN ENCODER datamatrix--
% --REQUIRES preamble raiseerror renmatrix--
% --DESC: Data Matrix
% --EXAM: This is Data Matrix!
% --EXOP:
% --RNDR: renmatrix
%%BeginResource: uk.co.terryburton.bwipp datamatrix 0.0 2015050900 189975 216544
%%BeginData:        844 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/datamatrix {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /columns 0 def
    /rows 0 def
    /parse false def
    /parsefnc false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /columns columns cvi def
    /rows rows cvi def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    % Convert input into bytes accounting for FNC characters
    /fnc1 -1 def  /prog -2 def  /m05 -3 def  /m06 -4 def
    /fncvals <<
        (FNC1) fnc1
        (PROG) prog
        (MAC5) m05
        (MAC6) m06
    >> def
    /msg barlen array def
    /i 0 def /j 0 def {
        i barlen eq {exit} if
        /char barcode i get def
        parsefnc char 94 eq and i barlen 4 sub lt and {
            barcode i 1 add get 94 ne {
                /char fncvals barcode i 1 add 4 getinterval get def
                /i i 4 add def
            } {
                /i i 1 add def
            } ifelse
        } if
        msg j char put
        /i i 1 add def
        /j j 1 add def
    } loop
    /msg msg 0 j getinterval def
    /msglen msg length def

    % Basic metrics for the each symbol
    %    rows  cols  regh  regv  rscw  rsbl
    /metrics [
        % Standard square symbols
        [  10    10     1     1     5     1 ]
        [  12    12     1     1     7     1 ]
        [  14    14     1     1    10     1 ]
        [  16    16     1     1    12     1 ]
        [  18    18     1     1    14     1 ]
        [  20    20     1     1    18     1 ] 
        [  22    22     1     1    20     1 ]
        [  24    24     1     1    24     1 ]
        [  26    26     1     1    28     1 ]
        [  32    32     2     2    36     1 ]
        [  36    36     2     2    42     1 ]
        [  40    40     2     2    48     1 ]
        [  44    44     2     2    56     1 ]
        [  48    48     2     2    68     1 ]
        [  52    52     2     2    84     2 ]
        [  64    64     4     4   112     2 ]
        [  72    72     4     4   144     4 ]
        [  80    80     4     4   192     4 ]
        [  88    88     4     4   224     4 ]
        [  96    96     4     4   272     4 ]
        [ 104   104     4     4   336     6 ]
        [ 120   120     6     6   408     6 ]
        [ 132   132     6     6   496     8 ]
        [ 144   144     6     6   620    10 ]
        % Optional rectangular symbols
        [   8    18     1     1     7     1 ]
        [   8    32     1     2    11     1 ]
        [  12    26     1     1    14     1 ]
        [  12    36     1     2    18     1 ]
        [  16    36     1     2    24     1 ]
        [  16    48     1     2    28     1 ]
    ] def

    % Create array of codewords remaining to make a full symbol
    /urows rows def
    /ucols columns def
    /fullcws [] def
    metrics {
        /m exch def
        /rows m 0 get def                          % Rows in symbol
        /cols m 1 get def                          % Columns in symbol
        /regh m 2 get def                          % Horizontal regions
        /regv m 3 get def                          % Vertical regions
        /rscw m 4 get def                          % Error correction codewords
        /rsbl m 5 get def                          % Error correction blocks
        /mrows rows 2 regh mul sub def             % Rows in the mapping matrix
        /mcols cols 2 regv mul sub def             % Columns in the mapping matrix
        /ncws mrows mcols mul 8 idiv rscw sub def  % Data codewords
        /okay true def
        urows 0 ne urows rows ne and {/okay false def} if
        ucols 0 ne ucols cols ne and {/okay false def} if
        urows 0 eq ucols 0 eq or rows cols ne and {/okay false def} if
        okay {/fullcws [ fullcws aload pop ncws ] def} if
    } forall
    /numremcws [ 1558 {10000} repeat ] def
    fullcws {numremcws exch 1 sub 1 put} forall
    1556 -1 0 {
        /i exch def
        numremcws i get 1 ne {
            numremcws i numremcws i 1 add get 1 add put
        } if
    } for

    % Special characters
    /lC    -5 def  /lB    -6 def  /lX    -7 def  /lT    -8 def  /lE    -9 def  /unl -10 def
    /sapp -11 def  /usft -12 def  /sft1 -13 def  /sft2 -14 def  /sft3 -15 def  /eci -16 def  /pad -17 def
    /unlcw 254 def
  
    /Avals <<
        0 1 128 {dup 1 add} for
        pad 129
        0 1 99 {  % Double digits
            dup 10 2 string cvrs (00) 2 string copy dup 2 3 index length sub 4 -1 roll putinterval
            exch 130 add
        } for
        229 [ lC lB fnc1 sapp prog usft m05 m06 lX lT lE eci ] {exch 1 add dup} forall pop
    >> def
    /Avals <<
        Avals {[exch]} forall
    >> def
    
    /CNvals <<
        sft1 0
        sft2 1
        sft3 2
        32   3
        48 1 57 {dup 44 sub} for  % 0-9
        65 1 90 {dup 51 sub} for  % A-Z
    >> def
    /C1vals << 0 1 31 {dup} for >> def
    /C2vals <<
        33 1 47 {dup 33 sub} for
        58 1 64 {dup 43 sub} for
        91 1 95 {dup 69 sub} for
        fnc1 27
        usft 30
    >> def
    /C3vals << 96 1 127 {dup 96 sub} for >> def
    /Cvals <<
        CNvals {[exch]} forall
        C1vals {[exch CNvals sft1 get exch]} forall
        C2vals {[exch CNvals sft2 get exch]} forall
        C3vals {[exch CNvals sft3 get exch]} forall
    >> def
    
    /TNvals <<
        sft1 0
        sft2 1
        sft3 2
        32   3
        48 1  57 {dup 44 sub} for  % 0-9
        97 1 122 {dup 83 sub} for  % a-z
    >> def
    /T1vals << 0 1 31 {dup} for >> def
    /T2vals <<
        33 1 47 {dup 33 sub} for
        58 1 64 {dup 43 sub} for
        91 1 95 {dup 69 sub} for
        fnc1 27
        usft 30
    >> def
    /T3vals <<
         96 0
         65 1  90 {dup 64 sub} for
        123 1 127 {dup 96 sub} for
    >> def
    /Tvals <<
        TNvals {[exch]} forall
        T1vals {[exch TNvals sft1 get exch]} forall
        T2vals {[exch TNvals sft2 get exch]} forall
        T3vals {[exch TNvals sft3 get exch]} forall
    >> def
    
    % Extended ASCII mappings
    128 1 255 {
        /i exch def
        Avals i [ Avals usft get aload pop Avals i 128 sub get aload pop ] put
        Cvals i [ Cvals usft get aload pop Cvals i 128 sub get aload pop ] put
        Tvals i [ Tvals usft get aload pop Tvals i 128 sub get aload pop ] put
    } for
    
    /Xvals <<
        13 0
        42 1
        62 2
        32 3
        48 1 57 {dup 44 sub} for
        65 1 90 {dup 51 sub} for
    >> def
    /Xvals <<
        Xvals {[exch]} forall
    >> def
    
    /Evals <<
        64 1 94 {dup 64 sub} for
        unl 31
        32 1 63 {dup} for
    >> def
    /Evals <<
        Evals {[exch]} forall
    >> def
    
    /Bvals <<
        0 1 255 {dup} for
    >> def
    /Bvals <<
        Bvals {[exch]} forall
    >> def
    
    /encvals [ Avals Cvals Tvals Xvals Evals Bvals ] def
    
    /numD [ msglen {0} repeat 0 ] def
    /nextXterm [ msglen {0} repeat 9999 ] def
    /nextNonX  [ msglen {0} repeat 9999 ] def
    msglen 1 sub -1 0 {
        /i exch def
        /barchar msg i get def
        barchar 48 ge barchar 57 le and {
            numD i numD i 1 add get 1 add put
        } if
        barchar 13 eq barchar 42 eq or barchar 62 eq or {
            nextXterm i 0 put
        } {
            nextXterm i nextXterm i 1 add get 1 add put
        } ifelse
        Xvals barchar known not {
            nextNonX i 0 put
        } {
            nextNonX i nextNonX i 1 add get 1 add put
        } ifelse
    } for
    /nextXterm [nextXterm {dup 10000 gt {pop 10000} if} forall] def
    /nextNonX  [nextNonX  {dup 10000 gt {pop 10000} if} forall] def
    
    /isD  {char 48 ge char 57 le and} bind def
    /isC  {CNvals char known} bind def
    /isT  {TNvals char known} bind def
    /isX  {Xvals char known} bind def
    /isE  {Evals char known} bind def
    /isEA {char 127 gt} bind def
    /isFN {char 0 lt} bind def
    /XtermFirst {dup nextXterm exch get exch nextNonX exch get lt} bind def
    
    /A 0 def  /C 1 def  /T 2 def  /X 3 def  /E 4 def  /B 5 def

    /lookup {
        /ac 1 def /cc 2 def /tc 2 def /xc 2 def /ec 2 def /bc 2.25 def
        mode A eq {/ac 0 def /cc 1 def /tc 1 def /xc 1 def /ec 1 def /bc 1.25 def} if
        mode C eq {/cc 0 def} if
        mode T eq {/tc 0 def} if
        mode X eq {/xc 0 def} if
        mode E eq {/ec 0 def} if
        mode B eq {/bc 0 def} if
        1 {  % common exit
            /k 0 def {  % loop
                i k add msglen eq {
                    [/ac /cc /tc /xc /ec /bc] {dup load ceiling def} forall
                    true [   cc tc xc ec bc] {ac exch le and} forall {A exit} if
                    true [ac cc tc xc ec   ] {bc exch lt and} forall {B exit} if
                    true [ac cc tc xc    bc] {ec exch lt and} forall {E exit} if
                    true [ac cc    xc ec bc] {tc exch lt and} forall {T exit} if
                    true [ac cc tc    ec bc] {xc exch lt and} forall {X exit} if
                    C exit
                } if
                /char msg i k add get def
                /ac ac isD {1 2 div add} {isEA {ceiling 2 add} {1 add       } ifelse} ifelse def
                /cc cc isC {2 3 div add} {isEA { 8 3 div add } { 4 3 div add} ifelse} ifelse def
                /tc tc isT {2 3 div add} {isEA { 8 3 div add } { 4 3 div add} ifelse} ifelse def
                /xc xc isX {2 3 div add} {isEA {13 3 div add } {10 3 div add} ifelse} ifelse def
                /ec ec isE {3 4 div add} {isEA {17 4 div add } {13 4 div add} ifelse} ifelse def
                /bc bc isFN {4 add} {1 add} ifelse def
                k 4 ge {
                    true [   cc tc xc ec bc] {ac 1 add exch le and} forall {A exit} if
                    bc 1 add ac le {B exit} if
                    true [   cc tc xc ec   ] {bc 1 add exch lt and} forall {B exit} if
                    true [ac cc tc xc    bc] {ec 1 add exch lt and} forall {E exit} if
                    true [ac cc    xc ec bc] {tc 1 add exch lt and} forall {T exit} if
                    true [ac cc tc    ec bc] {xc 1 add exch lt and} forall {X exit} if
                    true [ac    tc    ec bc] {cc 1 add exch lt and} forall {
                        cc xc lt {C exit} if
                        cc xc eq {i k add 1 add XtermFirst {X exit} {C exit} ifelse} if
                    } if
                } if
                /k k 1 add def
            } loop
        } repeat
    } bind def
    
    /addtocws {
        dup cws exch j exch putinterval
        /j exch length j add def
    } bind def
    
    /encA {
        1 {  % Common exit
            numD i get 2 ge {
                2 string dup 0 msg i get put dup 1 msg i 1 add get put Avals exch get addtocws
                /i i 2 add def
                exit
            } if
            /newmode lookup def
            newmode mode ne {
                Avals [-1 lC lT lX lE lB] newmode get get addtocws
                /mode newmode def
                exit
            } if
            Avals msg i get get addtocws
            /i i 1 add def
            exit
        } repeat
    } bind def
    
    /CTXvalstocws {
        /in exch def
        mark
        0 3 in length 1 sub {
            in exch 3 getinterval 0 exch {add 40 mul} forall 40 idiv 1 add
            dup 256 idiv exch 256 mod
        } for
        counttomark array astore exch pop
    } bind def
    
    /encCTX {
        /p 0 def
        /ctxvals 2500 array def
    
        % Lookup the values for each character
        {
            i msglen eq {exit} if
            encvals mode get msg i get known not {exit} if
            p 3 mod 0 eq {
                lookup mode ne {
                    ctxvals 0 p getinterval CTXvalstocws addtocws
                    [unlcw] addtocws
                    /mode A def
                    exit
                } if
                msglen i sub 3 le {  % Check end of data conditions
                    /remcws numremcws j p 3 idiv 2 mul add get def
                    /remvals [
                        msg i msglen i sub getinterval {
                            dup encvals mode get exch known {
                                encvals mode get exch get aload pop
                            } {  % Unencodable X12 characters
                                pop -1 -1 -1 -1
                            } ifelse
                        } forall
                    ] def
                    remcws 2 eq remvals length 3 eq and {
                        % Encode and omit unlatch
                        [
                            ctxvals 0 p getinterval aload pop
                            remvals aload pop
                        ] CTXvalstocws addtocws
                        /mode A def
                        /i msglen def
                        exit
                    } if
                    remcws 2 eq remvals length 2 eq and mode X ne and {
                        % Encode with sft1 as third value, omit unlatch
                        [
                            ctxvals 0 p getinterval aload pop
                            remvals aload pop
                            encvals mode get sft1 get aload pop
                        ] CTXvalstocws addtocws
                        /mode A def
                        /i msglen def
                        exit
                    } if
                    remcws 2 eq remvals length 1 eq and {
                        % Unlatch to ASCII
                        ctxvals 0 p getinterval CTXvalstocws addtocws
                        [unlcw] addtocws
                        Avals msg i get get addtocws
                        /mode A def
                        /i msglen def
                        exit
                    } if
                    remcws 1 eq remvals length 1 eq and {
                        % Implied unlatch to ASCII
                        ctxvals 0 p getinterval CTXvalstocws addtocws
                        Avals msg i get get addtocws
                        /mode A def
                        /i msglen def
                        exit
                    } if
                } if
            } if
            encvals mode get msg i get get
            dup ctxvals exch p exch putinterval
            /p exch length p add def
            /i i 1 add def
        } loop

        % Backtrack to a boundary and return to ASCII
        mode A ne {
            {
                p 3 mod 0 eq {exit} if
                /i i 1 sub def
                /p p encvals mode get msg i get get length sub def
            } loop
            [
                ctxvals 0 p getinterval aload pop
            ] CTXvalstocws addtocws
            [unlcw] addtocws
            /mode A def
            % Encode something to avoid latching immediately back
            i msglen ne {
                numD i get 2 ge {
                    2 string dup 0 msg i get put dup 1 msg i 1 add get put Avals exch get addtocws
                    /i i 2 add def
                } {
                    Avals msg i get get addtocws
                    /i i 1 add def
                } ifelse
            } if
        } if
    
    } bind def
    
    /Evalstocws {
        /in exch def
        /inlen in length def
        /outlen in length 4 div 3 mul ceiling cvi def
        /in [ in aload pop 0 0 0 ] def
        mark
        0 4 inlen 1 sub {
            in exch 4 getinterval 0 exch {or 6 bitshift} forall -6 bitshift
            dup -16 bitshift 255 and exch
            dup -8 bitshift 255 and exch
            255 and
        } for
        counttomark array astore exch pop
        0 outlen getinterval
    } bind def
    
    /encE {
        /p 0 def
        /edifactvals 2100 array def
    
        % Lookup the values for each character
        {
            i msglen eq {exit} if
            Evals msg i get known not {exit} if
            p 4 mod 0 eq {
                lookup mode ne {exit} if
                msglen i sub 2 le {  % Check end of data conditions
                    /remcws numremcws j p 4 idiv 3 mul add get def
                    /remvals [
                        msg i msglen i sub getinterval {
                            dup Evals exch known {
                                Evals exch get aload pop
                            } {  % Unencodable EDIFACT characters
                                pop -1 -1 -1 -1 -1
                            } ifelse
                        } forall
                    ] def
                    remcws 2 eq remvals length 2 eq and {
                        % Implied unlatch to ASCII
                        edifactvals 0 p getinterval Evalstocws addtocws
                        Avals msg i get get addtocws
                        Avals msg i 1 add get get addtocws
                        /mode A def
                        /i msglen def
                        exit
                    } if
                    remcws 2 eq remcws 1 eq or remvals length 1 eq and {
                        % Implied unlatch to ASCII
                        edifactvals 0 p getinterval Evalstocws addtocws
                        Avals msg i get get addtocws
                        /mode A def
                        /i msglen def
                        exit
                    } if
                } if
            } if
            Evals msg i get get
            dup edifactvals exch p exch putinterval
            /p exch length p add def
            /i i 1 add def
        } loop
    
        % Unlatch and pad with zeros until boundary
        mode A ne {
            /remcws numremcws j p 4 idiv 3 mul add 1 sub get 1 sub def
            remcws 0 ne {  % Unlatch if we haven't filled symbol
                Evals unl get
                dup edifactvals exch p exch putinterval
                /p exch length p add def
            } if
            edifactvals 0 p getinterval Evalstocws addtocws
            /mode A def
            % Encode something to avoid latching immediately back
            i msglen ne {
                numD i get 2 ge {
                    2 string dup 0 msg i get put dup 1 msg i 1 add get put Avals exch get addtocws
                    /i i 2 add def
                } {
                    Avals msg i get get addtocws
                    /i i 1 add def
                } ifelse
            } if
        } if

    } bind def
    
    /encB {
        /p 0 def /bvals 1558 array def {
            i msglen eq {exit} if
            lookup mode ne {exit} if
            bvals p msg i get put
            /p p 1 add def
            /i i 1 add def
        } loop
        /remcws numremcws j p add get 1 sub def
        /bvals [
            remcws 0 eq i msglen eq and {  % Terminates symbol
                0
            } {
                p 250 lt {p} {p 250 idiv 249 add p 250 mod} ifelse
            } ifelse
            bvals 0 p getinterval aload pop
        ] def
        0 1 bvals length 1 sub {  % Pseudo-randomise based on codeword position
            /p exch def
            j p add 1 add 149 mul 255 mod 1 add bvals p get add
            dup 256 ge {256 sub} if
            bvals exch p exch put
        } for
        bvals addtocws
        /mode A def
    } bind def
    
    % Derive the codewords
    /cws 1558 array def
    /mode A def /i 0 def /j 0 def {
        i msglen ge {exit} if
        [ /encA /encCTX /encCTX /encCTX /encE /encB ] mode get load exec
    } loop
    /cws cws 0 j getinterval def

    % Extend codewords to fill symbol with pseudo-randomised pad characters
    /datlen cws length def
    /remcws numremcws j 1 sub get 1 sub def
    remcws 0 gt {
        /cws [ cws aload pop remcws {129} repeat ] def
        datlen 1 add 1 datlen remcws add 1 sub {
            /i exch def
            i 1 add 149 mul 253 mod 1 add 129 add
            dup 254 gt {254 sub} if
            cws exch i exch put
        } for
    } if

    % Lookup symbol metrics based on number of codewords and user specification
    /i 0 def { % loop
        /m metrics i get def
        /rows m 0 get def                          % Rows in symbol
        /cols m 1 get def                          % Columns in symbol
        /regh m 2 get def                          % Horizontal regions
        /regv m 3 get def                          % Vertical regions
        /rscw m 4 get def                          % Error correction codewords
        /rsbl m 5 get def                          % Error correction blocks
        /mrows rows 2 regh mul sub def             % Rows in the mapping matrix
        /mcols cols 2 regv mul sub def             % Columns in the mapping matrix
        /rrows mrows regh idiv def                 % Rows per region
        /rcols mcols regv idiv def                 % Columns per region
        /ncws mrows mcols mul 8 idiv rscw sub def  % Data codewords
        /okay true def
        cws length ncws ne           {/okay false def} if
        urows 0 ne urows rows ne and {/okay false def} if
        ucols 0 ne ucols cols ne and {/okay false def} if
        okay {exit} if
        /i i 1 add def
    } loop

    % De-interleave the codewords into blocks
    /cwbs rsbl array def  % Array of data codeword blocks
    /ecbs rsbl array def  % Array of error correction blocks
    0 1 rsbl 1 sub {
        /i exch def
        cws length 1558 ne {
            /cwbsize cws length rsbl idiv def
        } {
            i 7 le {/cwbsize 156 def} {/cwbsize 155 def} ifelse
        } ifelse
        /cwb cwbsize array def 
        0 1 cwbsize 1 sub {
            /j exch def
            cwb j cws j rsbl mul i add get put
        } for 
        cwbs i cwb put
        ecbs i [ rscw rsbl idiv {0} repeat ] put
    } for

    % Calculate the log and anti-log tables
    /rsalog [ 1 255 { dup 2 mul dup 256 ge {301 xor} if } repeat ] def
    /rslog 256 array def
    1 1 255 {dup rsalog exch get exch rslog 3 1 roll put} for

    % Function to calculate the product in the field
    /rsprod {
        2 copy 0 ne exch 0 ne and { 
            rslog exch get exch rslog exch get add 255 mod rsalog exch get
        } {
            pop pop 0
        } ifelse
    } bind def

    % Generate the coefficients
    /coeffs [ 1 rscw rsbl idiv {0} repeat ] def
    1 1 rscw rsbl idiv {
        /i exch def 
        coeffs i coeffs i 1 sub get put
        i 1 sub -1 1 {
            /j exch def
            coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod xor put
        } for 
        coeffs 0 coeffs 0 get rsalog i get rsprod put
    } for
    /coeffs coeffs 0 coeffs length 1 sub getinterval def

    % Calculate the error correction codewords for each block
    0 1 cwbs length 1 sub {
        /i exch def
        /cwb cwbs i get def
        /ecb ecbs i get def
        0 1 cwb length 1 sub {
            /t exch cwb exch get ecb 0 get xor def 
            ecb length 1 sub -1 0 {
                /j exch def
                /p ecb length j sub 1 sub def
                ecb p t coeffs j get rsprod put
                j 0 gt { ecb p ecb p 1 add get ecb p get xor put } if
            } for 
        } for
    } for

    % Strange fixup for 144x144 symbols
    ncws 1558 eq {
        /ecbs [ ecbs 8 2 getinterval {} forall ecbs 0 8 getinterval {} forall ] def
    } if

    % Extend codewords with the interleaved error correction codes
    /cws [ cws {} forall rscw {0} repeat ] def
    0 1 rscw 1 sub {
        /i exch def
        cws ncws i add ecbs i rsbl mod get i rsbl idiv get put
    } for

    % Place the codewords into the matrix
    /module {
        % cw row col shape
        4 -1 roll 
        (00000000) 8 string copy dup 3 -1 roll 2 8 string cvrs 
        dup length 8 exch sub exch putinterval 
        7 -1 0 {1 index exch get 48 sub exch} for pop
        11 -3 roll
        % 1 2 4 8 16 32 64 128 row col shape
        {  % Place each bit of the codeword in the shape, MSB first
            exec
            1 index 0 lt {
                exch mrows add exch
                4 mrows 4 add 8 mod sub add
            } if
            dup 0 lt {
                mcols add exch
                4 mcols 4 add 8 mod sub add exch
            } if
            exch mcols mul add
            mmat exch 5 -1 roll put
        } forall
    } bind def

    % Placement patterns
    /dmn [
        { 2 copy 2 sub exch 2 sub exch } bind  { 2 copy 1 sub exch 2 sub exch } bind
        { 2 copy 2 sub exch 1 sub exch } bind  { 2 copy 1 sub exch 1 sub exch } bind
        { 2 copy exch 1 sub exch } bind        { 2 copy 2 sub } bind
        { 2 copy 1 sub } bind                  { 2 copy } bind
    ] def
    
    /dmc1 [
        { mrows 1 sub 0 } bind  { mrows 1 sub 1 } bind
        { mrows 1 sub 2 } bind  { 0 mcols 2 sub } bind
        { 0 mcols 1 sub } bind  { 1 mcols 1 sub } bind
        { 2 mcols 1 sub } bind  { 3 mcols 1 sub } bind
    ] def
    
    /dmc2 [
        { mrows 3 sub 0 } bind  { mrows 2 sub 0 } bind
        { mrows 1 sub 0 } bind  { 0 mcols 4 sub } bind
        { 0 mcols 3 sub } bind  { 0 mcols 2 sub } bind
        { 0 mcols 1 sub } bind  { 1 mcols 1 sub } bind
    ] def
    
    /dmc3 [
        { mrows 3 sub 0 } bind  { mrows 2 sub 0 } bind
        { mrows 1 sub 0 } bind  { 0 mcols 2 sub } bind
        { 0 mcols 1 sub } bind  { 1 mcols 1 sub } bind
        { 2 mcols 1 sub } bind  { 3 mcols 1 sub } bind
    ] def
    
    /dmc4 [
        { mrows 1 sub 0 } bind  { mrows 1 sub mcols 1 sub } bind
        { 0 mcols 3 sub } bind  { 0 mcols 2 sub } bind
        { 0 mcols 1 sub } bind  { 1 mcols 3 sub } bind
        { 1 mcols 2 sub } bind  { 1 mcols 1 sub } bind
    ] def

    /mmat [ mrows mcols mul {-1} repeat ] def
    cws length 1 sub -1 0 {cws exch get} for  % Reverse cws onto stack
    4 0  % Starting row and column
    { % loop
        2 copy 0 eq exch mrows eq and {
            dmc1 module
        } if
        2 copy 0 eq exch mrows 2 sub eq and mcols 4 mod 0 ne and {
            dmc2 module
        } if
        2 copy 0 eq exch mrows 2 sub eq and mcols 8 mod 4 eq and {
            dmc3 module
        } if
        2 copy 2 eq exch mrows 4 add eq and mcols 8 mod 0 eq and {
            dmc4 module
        } if

        { % loop for sweeping upwards
            2 copy 0 ge exch mrows lt and {
                2 copy exch mcols mul add mmat exch get -1 eq {
                    dmn module
                } if
            } if
            2 add exch 2 sub exch
            2 copy mcols lt exch 0 ge and not {exit} if
        } loop
        3 add exch 1 add exch

        { % loop for sweeping downwards
            2 copy mcols lt exch 0 ge and {
                2 copy exch mcols mul add mmat exch get -1 eq {
                    dmn module
                } if
            } if
            2 sub exch 2 add exch
            2 copy 0 ge exch mrows lt and not {exit} if
        } loop
        1 add exch 3 add exch

        2 copy mcols lt exch mrows lt or not {pop pop exit} if

    } loop

    % Set checker pattern if required
    mmat mrows mcols mul 1 sub get -1 eq {
        mmat mrows mcols 1 sub mul 2 sub [1 0] putinterval
        mmat mrows mcols mul 2 sub [0 1] putinterval
    } if

    % Place the modules onto a pixel map between alignment patterns
    /pixs rows cols mul array def
    /cwpos 0 def
    0 1 rows 1 sub {
        /i exch def
        i rrows 2 add mod 0 eq { pixs i cols mul [ cols 2 idiv {1 0} repeat ] putinterval } if  
        i rrows 2 add mod rrows 1 add eq { pixs i cols mul [ cols {1} repeat ] putinterval } if 
        i rrows 2 add mod 0 ne i rrows 2 add mod rrows 1 add ne and {
            0 1 cols 1 sub {
                /j exch def
                j rcols 2 add mod 0 eq { pixs i cols mul j add 1 put } if
                j rcols 2 add mod rcols 1 add eq { pixs i cols mul j add i 2 mod put } if
                j rcols 2 add mod 0 ne j rcols 2 add mod rcols 1 add ne and {
                    pixs i cols mul j add mmat cwpos get put
                    /cwpos cwpos 1 add def
                } if
            } for
        } if 
    } for

    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx cols
    /pixy rows
    /height rows 2 mul 72 div
    /width cols 2 mul 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/datamatrix dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER datamatrix--

% --BEGIN ENCODER qrcode--
% --REQUIRES preamble raiseerror renmatrix--
% --DESC: QR Code
% --EXAM: http://goo.gl/0bis
% --EXOP: eclevel=M
% --RNDR: renmatrix
%%BeginResource: uk.co.terryburton.bwipp qrcode 0.0 2015050900 265291 275512
%%BeginData:       1004 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/qrcode {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /format (full) def     % full or micro or any
    /version (unset) def   % 1-40 or M1-M4
    /eclevel (unset) def   % L, M, Q or H
    /parse false def
    /parsefnc false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    % Convert input into bytes accounting for FNC characters
    /fn1 -1 def
    /fncvals <<
        (FNC1) fn1
    >> def
    /msg barlen array def
    /i 0 def /j 0 def {
        i barlen eq {exit} if
        /char barcode i get def
        parsefnc char 94 eq and i barlen 4 sub lt and {
            barcode i 1 add get 94 ne {
                /char fncvals barcode i 1 add 4 getinterval get def
                /i i 4 add def
            } {
                /i i 1 add def
            } ifelse
        } if
        msg j char put
        /i i 1 add def
        /j j 1 add def
    } loop
    /msg msg 0 j getinterval def
    /msglen msg length def

    % If FNC1 in first position then escape % as %%
    /fnc1first false def
    msglen 0 gt {
        msg 0 get fn1 eq {
            /fnc1first true def
            /msg [ msg 1 msglen 1 sub getinterval { dup 37 eq {dup} if } forall ] def
            /msglen msg length def
        } if
    } if

    % Default error correction level
    eclevel (unset) eq {/eclevel format (full) eq {(M)} {(L)} ifelse def} if

    % Convert from input into message bitstream
    /N 0 def  /A 1 def  /B 2 def  /K 3 def
   
    /Nexcl <<
       [
           16#30 1 16#39 {} for
       ] {-1} forall
    >> def
    
    /Aexcl <<
        [
            16#20 16#24 16#25 16#2A 16#2B 16#2D 16#2E 16#2F 16#3A
            16#41 1 16#5A {} for
        ] {-1} forall
    >> def
    
    /Bexcl <<
        [
            16#00 1 16#1F {} for
            16#21 16#22 16#23 16#26 16#27 16#28 16#29 16#2C
            16#3B 1 16#40 {} for
            16#5B 1 16#7F {} for
            16#A0 1 16#DF {} for
        ] {-1} forall
    >> def
    
    /Kexcl <<
        [
            16#81 1 16#9F {} for
            16#E0 1 16#EB {} for
        ] {-1} forall
    >> def
    
    /mids [  % N  A  B  K
      [ (0001) (0010) (0100) (1000) ]  %  1-9
      [ (0001) (0010) (0100) (1000) ]  % 10-26
      [ (0001) (0010) (0100) (1000) ]  % 27-40
      [     ()   -1     -1     -1   ]  % M1
      [    (0)    (1)   -1     -1   ]  % M2
      [   (00)   (01)   (10)   (11) ]  % M3
      [  (000)  (001)  (010)  (011) ]  % M4
    ] def
    
    /cclens [  % N  A  B  K
      [ 10  9  8  8 ]  %  1-9
      [ 12 11 16 10 ]  % 10-26
      [ 14 13 16 12 ]  % 27-40
      [  3 -1 -1 -1 ]  % M1
      [  4  3 -1 -1 ]  % M2
      [  5  4  4  3 ]  % M3
      [  6  5  5  4 ]  % M4
    ] def
    
    /termlens [ 4 4 4 3 5 7 9 ] def
    
    % Encoding functions
    /tobin {
        string dup length 1 sub 0 exch 1 exch {1 index exch 48 put} for
        dup 3 -1 roll 2 2 index length string cvrs dup length 2 index length exch sub exch putinterval
    } bind def

    % Alphanumeric character to value map
    /charmap (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:) def
    /charvals 44 dict def
    0 1 44 {dup charmap exch get exch charvals 3 1 roll put} for

    /encA {
        /in exch def
        fnc1first {  % FNC1 as %
            /in [ in { dup -1 eq {pop 37} if } forall ] def
        } if
        /out in length 11 mul 2 idiv 1 add string def
        /k 0 def /m 0 def {
            k in length eq {exit} if
            k in length 1 sub lt {
                charvals in k get get 45 mul charvals in k 1 add get get add 11 tobin
                /k k 2 add def
            } {  % Final character
                charvals in k get get 6 tobin
                /k k 1 add def
            } ifelse
            dup out exch m exch putinterval
            length m add /m exch def
        } loop
        out 0 m getinterval
    } bind def
    
    /encN {
        /in exch def
        /out in length 10 mul 3 idiv 1 add string def
        /k 0 def /m 0 def {
            k in length eq {exit} if
            k in length 2 sub lt {
                in k 3 getinterval 0 exch {exch 10 mul 48 sub add} forall 10 tobin
                /k k 3 add def
            } {
                k in length 2 sub eq {  % Two final digits
                    in k 2 getinterval 0 exch {exch 10 mul 48 sub add} forall 7 tobin
                    /k k 2 add def
                } {  % One final digit
                    in k 1 getinterval 0 exch {exch 10 mul 48 sub add} forall 4 tobin
                    /k k 1 add def
                } ifelse
            } ifelse
            dup out exch m exch putinterval
            length m add /m exch def
        } loop
        out 0 m getinterval
    } bind def
    
    /encB {
        /in exch def
        fnc1first {  % FNC1 as GS
            /in [ in { dup -1 eq {pop 29} if } forall ] def
        } if
        /out in length 8 mul string def
        0 1 in length 1 sub {
            /k exch def
            in k get cvi 8 tobin
            out k 8 mul 3 -1 roll putinterval
        } for
        out
    } bind def
    
    /encK {
        /in exch def
        /out in length 2 idiv 13 mul string def
        /k 0 def /m 0 def {
            k in length eq {exit} if
            in k get 256 mul in k 1 add get add
            dup 16#E040 lt {16#8140} {16#C140} ifelse sub
            dup -8 bitshift 16#C0 mul exch 16#00FF and add
            13 tobin dup out exch m exch putinterval
            length m add /m exch def
            /k k 2 add def
        } loop
        out
    } bind def
    
    /encfuncs [ /encN /encA /encB /encK ] def
    
    /addtobits {
        dup bits j 3 -1 roll putinterval
        length j add /j exch def
    } bind def
    
    /numNs [ msglen {0} repeat 0 ] def
    /numAs [ msglen {0} repeat 0 ] def
    /numBs [ msglen {0} repeat 0 ] def
    /numKs [ msglen {0} repeat -1 ] def
    /nextNs [ msglen {0} repeat 9999 ] def
    /nextBs [ msglen {0} repeat 9999 ] def
    /nextAs [ msglen {0} repeat 9999 ] def
    /nextKs [ msglen {0} repeat 9999 ] def
    msglen 1 sub -1 0 {
        /i exch def
        /barchar msg i get def
        Kexcl barchar known {
            nextKs i 0 put
            numKs i numKs i 1 add get 1 add put
        } {
            nextKs i nextKs i 1 add get 1 add put
        } ifelse
        Nexcl barchar known {
            nextNs i 0 put
            numNs i numNs i 1 add get 1 add put
        } {
            nextNs i nextNs i 1 add get 1 add put
        } ifelse
        Bexcl barchar known {
            nextBs i 0 put
            numBs i numBs i 1 add get 1 add put
        } {
            nextBs i nextBs i 1 add get 1 add put
        } ifelse
        Aexcl barchar known {
            nextAs i 0 put
            numAs i numAs i 1 add get 1 add put
        } {
            nextAs i nextAs i 1 add get 1 add put
        } ifelse
    } for
    /numKs [ numKs {1 add 2 idiv} forall ] def
    
    /KbeforeB {numK exch ver get ge nextBs numK 2 mul i add get 0 eq and} bind def
    /KbeforeA {numK exch ver get ge nextAs numK 2 mul i add get 0 eq and} bind def
    /KbeforeN {numK exch ver get ge nextNs numK 2 mul i add get 0 eq and} bind def
    /KbeforeE {numK exch ver get ge numK 2 mul i add msglen eq and} bind def
    /AbeforeK {numA exch ver get ge nextKs numA i add get 0 eq and} bind def
    /AbeforeB {numA exch ver get ge nextBs numA i add get 0 eq and} bind def
    /AbeforeN {numA exch ver get ge nextNs numA i add get 0 eq and} bind def
    /AbeforeE {numA exch ver get ge numA i add msglen eq and} bind def
    /NbeforeK {numN exch ver get ge nextKs numN i add get 0 eq and} bind def
    /NbeforeB {numN exch ver get ge nextBs numN i add get 0 eq and} bind def
    /NbeforeA {numN exch ver get ge nextAs numN i add get 0 eq and} bind def
    /NbeforeE {numN exch ver get ge numN i add msglen eq and} bind def

    % Encode unterminated bitsream for each version group separately
    /msgbits [-1 -1 -1 -1 -1 -1 -1] def
    /v1to9 0 def  /v10to26 1 def  /v27to40 2 def  /vM1 3 def  /vM2 4 def  /vM3 5 def  /vM4 6 def
    /e 10000 def
    [v1to9 v10to26 v27to40 vM1 vM2 vM3 vM4] {
        /ver exch def
    
        % Derive optimal sequence
        /mode -1 def /seq [] def /i 0 def {
            i msglen ge {exit} if
            /numK numKs i get def
            /numB numBs i get def
            /numA numAs i get def
            /numN numNs i get def
            ver vM1 eq numA 1 ge and {/seq -1 def exit} if
            ver vM1 eq numB 1 ge and {/seq -1 def exit} if
            ver vM1 eq numK 1 ge and {/seq -1 def exit} if
            ver vM2 eq numB 1 ge and {/seq -1 def exit} if
            ver vM2 eq numK 1 ge and {/seq -1 def exit} if
            {  % common exit
                mode -1 eq {  % Set initial mode
                    [ 1  1  1  e  e  1  1] KbeforeA {K exit} if
                    [ 1  1  1  e  e  1  1] KbeforeN {K exit} if
                    [ 5  5  6  e  e  2  3] KbeforeB {K exit} if
                    [ 1  1  1  e  e  1  1] KbeforeE {K exit} if
                    numK 1 ge {B exit} if
                    [ 6  7  8  e  e  3  4] AbeforeB {A exit} if
                    [ 1  1  1  e  1  1  1] AbeforeE {A exit} if
                    numA 1 ge {
                        ver vM1 ne ver vM2 ne and {B} {A} ifelse exit
                    } if
                    [ 4  4  5  e  e  2  3] NbeforeB {N exit} if
                    [ 1  1  1  e  e  1  1] NbeforeB {B exit} if
                    [ 7  8  9  e  3  4  5] NbeforeA {N exit} if
                    [ 1  1  1  e  1  1  1] NbeforeA {A exit} if
                    numN 1 ge {N exit} if
                    B exit
                } if
                mode B eq {
                    [ 9 12 13  e  e  4  5] KbeforeB {K exit} if
                    [ 9 10 12  e  e  4  5] KbeforeA {K exit} if
                    [ 9 10 11  e  e  5  6] KbeforeN {K exit} if
                    [ 4  5  6  e  e  2  3] KbeforeE {K exit} if
                    [11 12 14  e  e  5  7] AbeforeK {A exit} if
                    [11 15 16  e  e  6  7] AbeforeB {A exit} if
                    [12 13 15  e  e  6  8] AbeforeN {A exit} if
                    [ 6  7  8  e  e  3  4] AbeforeE {A exit} if
                    [ 6  7  8  e  e  3  4] NbeforeK {N exit} if
                    [ 6  8  9  e  e  3  4] NbeforeB {N exit} if
                    [ 6  7  8  e  e  3  4] NbeforeA {N exit} if
                    [ 3  4  5  e  e  2  3] NbeforeE {N exit} if
                    B exit
                } if
                mode A eq {
                    numK 1 ge {K exit} if
                    numB 1 ge {B exit} if
                    [13 15 17  e  5  7  9] NbeforeA {N exit} if
                    [13 17 18  e  e  7  9] NbeforeB {N exit} if
                    [ 7  8  9  e  3  4  5] NbeforeE {N exit} if
                    A exit
                } if
                mode N eq {
                    numK 1 ge {K exit} if
                    numB 1 ge {B exit} if
                    numA 1 ge {A exit} if
                    N exit
                } if
                mode K eq {
                    numB 1 ge {B exit} if
                    numA 1 ge {A exit} if
                    numN 1 ge {N exit} if
                    K exit
                } if
            } loop
            dup K eq fnc1first and {pop B} if  % No kanji with fnc1first
            dup mode eq {  % Same mode encode directly
                pop
                /dat msg i mode K eq {2} {1} ifelse getinterval def
                /seq [
                    seq aload pop
                    [ exch aload pop dat aload pop ]
                ] def
            } {  % Change mode
                /mode exch def
                mode K eq {K msg i numK 2 mul getinterval} if
                mode B eq {B msg i numB getinterval} if
                mode A eq {A msg i numA getinterval} if
                mode N eq {N msg i numN getinterval} if
                /dat exch def /sw exch def
                /seq [ seq aload pop sw dat ] def
            } ifelse
            /i i dat length add def
        } loop

        % Encode the sequence
        {  % common exit
            seq -1 eq {exit} if  % Sequence not available
            /bits 23648 string def
            /j 0 def
            fnc1first {(0101) addtobits} if
            /abort false def
            0 2 seq length 1 sub {
                /i exch def
                /mode seq i get def
                mids ver get mode get addtobits
                /cclen cclens ver get mode get def
                /chars seq i 1 add get def
                chars length 2 cclen exp cvi ge {  % Too many characters for cc indicator
                    /abort true def exit
                } if
                chars length mode K eq {2 idiv} if cclen tobin addtobits
                chars encfuncs mode get load exec addtobits
            } for
            abort {exit} if
            /bits bits 0 j getinterval def
            msgbits ver bits put
            exit
        } loop
    } forall

    % Lookup the most appropriate symbol specification
    /metrics [
        % format   vers  vergrp  size align modules    error codewords        error correction blocks 
        %                                              L    M    Q    H       L1 L2 M1 M2 Q1 Q2 H1 H2
        [ (micro)  (M1)  vM1       11  98 99     36  [   2   99   99   99 ]  [  1  0 -1 -1 -1 -1 -1 -1 ] ]
        [ (micro)  (M2)  vM2       13  98 99     80  [   5    6   99   99 ]  [  1  0  1  0 -1 -1 -1 -1 ] ]
        [ (micro)  (M3)  vM3       15  98 99    132  [   6    8   99   99 ]  [  1  0  1  0 -1 -1 -1 -1 ] ]
        [ (micro)  (M4)  vM4       17  98 99    192  [   8   10   14   99 ]  [  1  0  1  0  1  0 -1 -1 ] ]
        [ (full)   (1)   v1to9     21  98 99    208  [   7   10   13   17 ]  [  1  0  1  0  1  0  1  0 ] ]
        [ (full)   (2)   v1to9     25  18 99    359  [  10   16   22   28 ]  [  1  0  1  0  1  0  1  0 ] ]
        [ (full)   (3)   v1to9     29  22 99    567  [  15   26   36   44 ]  [  1  0  1  0  2  0  2  0 ] ]
        [ (full)   (4)   v1to9     33  26 99    807  [  20   36   52   64 ]  [  1  0  2  0  2  0  4  0 ] ]
        [ (full)   (5)   v1to9     37  30 99   1079  [  26   48   72   88 ]  [  1  0  2  0  2  2  2  2 ] ]
        [ (full)   (6)   v1to9     41  34 99   1383  [  36   64   96  112 ]  [  2  0  4  0  4  0  4  0 ] ]
        [ (full)   (7)   v1to9     45  22 38   1568  [  40   72  108  130 ]  [  2  0  4  0  2  4  4  1 ] ]
        [ (full)   (8)   v1to9     49  24 42   1936  [  48   88  132  156 ]  [  2  0  2  2  4  2  4  2 ] ]
        [ (full)   (9)   v1to9     53  26 46   2336  [  60  110  160  192 ]  [  2  0  3  2  4  4  4  4 ] ]
        [ (full)   (10)  v10to26   57  28 50   2768  [  72  130  192  224 ]  [  2  2  4  1  6  2  6  2 ] ]
        [ (full)   (11)  v10to26   61  30 54   3232  [  80  150  224  264 ]  [  4  0  1  4  4  4  3  8 ] ]
        [ (full)   (12)  v10to26   65  32 58   3728  [  96  176  260  308 ]  [  2  2  6  2  4  6  7  4 ] ]
        [ (full)   (13)  v10to26   69  34 62   4256  [ 104  198  288  352 ]  [  4  0  8  1  8  4 12  4 ] ]
        [ (full)   (14)  v10to26   73  26 46   4651  [ 120  216  320  384 ]  [  3  1  4  5 11  5 11  5 ] ]
        [ (full)   (15)  v10to26   77  26 48   5243  [ 132  240  360  432 ]  [  5  1  5  5  5  7 11  7 ] ]
        [ (full)   (16)  v10to26   81  26 50   5867  [ 144  280  408  480 ]  [  5  1  7  3 15  2  3 13 ] ]
        [ (full)   (17)  v10to26   85  30 54   6523  [ 168  308  448  532 ]  [  1  5 10  1  1 15  2 17 ] ]
        [ (full)   (18)  v10to26   89  30 56   7211  [ 180  338  504  588 ]  [  5  1  9  4 17  1  2 19 ] ]
        [ (full)   (19)  v10to26   93  30 58   7931  [ 196  364  546  650 ]  [  3  4  3 11 17  4  9 16 ] ]
        [ (full)   (20)  v10to26   97  34 62   8683  [ 224  416  600  700 ]  [  3  5  3 13 15  5 15 10 ] ]
        [ (full)   (21)  v10to26  101  28 50   9252  [ 224  442  644  750 ]  [  4  4 17  0 17  6 19  6 ] ]
        [ (full)   (22)  v10to26  105  26 50  10068  [ 252  476  690  816 ]  [  2  7 17  0  7 16 34  0 ] ]
        [ (full)   (23)  v10to26  109  30 54  10916  [ 270  504  750  900 ]  [  4  5  4 14 11 14 16 14 ] ]
        [ (full)   (24)  v10to26  113  28 54  11796  [ 300  560  810  960 ]  [  6  4  6 14 11 16 30  2 ] ]
        [ (full)   (25)  v10to26  117  32 58  12708  [ 312  588  870 1050 ]  [  8  4  8 13  7 22 22 13 ] ]
        [ (full)   (26)  v10to26  121  30 58  13652  [ 336  644  952 1110 ]  [ 10  2 19  4 28  6 33  4 ] ]
        [ (full)   (27)  v27to40  125  34 62  14628  [ 360  700 1020 1200 ]  [  8  4 22  3  8 26 12 28 ] ]
        [ (full)   (28)  v27to40  129  26 50  15371  [ 390  728 1050 1260 ]  [  3 10  3 23  4 31 11 31 ] ]
        [ (full)   (29)  v27to40  133  30 54  16411  [ 420  784 1140 1350 ]  [  7  7 21  7  1 37 19 26 ] ]
        [ (full)   (30)  v27to40  137  26 52  17483  [ 450  812 1200 1440 ]  [  5 10 19 10 15 25 23 25 ] ]
        [ (full)   (31)  v27to40  141  30 56  18587  [ 480  868 1290 1530 ]  [ 13  3  2 29 42  1 23 28 ] ]
        [ (full)   (32)  v27to40  145  34 60  19723  [ 510  924 1350 1620 ]  [ 17  0 10 23 10 35 19 35 ] ]
        [ (full)   (33)  v27to40  149  30 58  20891  [ 540  980 1440 1710 ]  [ 17  1 14 21 29 19 11 46 ] ]
        [ (full)   (34)  v27to40  153  34 62  22091  [ 570 1036 1530 1800 ]  [ 13  6 14 23 44  7 59  1 ] ]
        [ (full)   (35)  v27to40  157  30 54  23008  [ 570 1064 1590 1890 ]  [ 12  7 12 26 39 14 22 41 ] ]
        [ (full)   (36)  v27to40  161  24 50  24272  [ 600 1120 1680 1980 ]  [  6 14  6 34 46 10  2 64 ] ]
        [ (full)   (37)  v27to40  165  28 54  25568  [ 630 1204 1770 2100 ]  [ 17  4 29 14 49 10 24 46 ] ]
        [ (full)   (38)  v27to40  169  32 58  26896  [ 660 1260 1860 2220 ]  [  4 18 13 32 48 14 42 32 ] ]
        [ (full)   (39)  v27to40  173  26 54  28256  [ 720 1316 1950 2310 ]  [ 20  4 40  7 43 22 10 67 ] ]
        [ (full)   (40)  v27to40  177  30 58  29648  [ 750 1372 2040 2430 ]  [ 19  6 18 31 34 34 20 61 ] ]
    ] def
    /eclval (LMQH) eclevel search pop length exch pop exch pop def
    0 1 43 {
        /i exch def
        /m metrics i get def
        /frmt m 0 get def                             % Format of the symbol
        /vers m 1 get def                             % Version of symbol
        /vergrp m 2 get def                           % Version group
        /size m 3 get def                             % Length of side
        /asp2 m 4 get def                             % Position of second alignment symbol
        /asp3 m 5 get def                             % Position of third alignment symbol
        /nmod m 6 get def                             % Number of modules
        /ncws nmod 8 idiv def                         % Total number of codewords
        /rbit nmod 8 mod def                          % Number of remainder bits
        /lc4b false def                               % Last data codeword is 4 bits long
        size 11 eq size 15 eq or {                    % Adjustments for M1 and M3 symbols
            /ncws ncws 1 add def
            /rbit 0 def
            /lc4b true def
        } if
        /ecws m 7 get eclval get def                  % Number of error correction codewords
        /dcws ncws ecws sub def                       % Number of data codewords
        /dmod dcws 8 mul lc4b {4} {0} ifelse sub def  % Number of data modules
        /ecb1 m 8 get eclval 2 mul get def            % First error correction blocks
        /ecb2 m 8 get eclval 2 mul 1 add get def      % Second error correction blocks
        /okay true def
        format (any) ne format frmt ne and {/okay false def} if  % The format must match that supplied
        frmt (micro) eq fnc1first and {/okay false def} if
        version (unset) ne version vers ne and {/okay false def} if  % The version must match that supplied
        ecb1 -1 eq ecb2 -1 eq or {/okay false def} if % Error correction level must be valid
        /verbits msgbits vergrp get def
        verbits -1 eq {                               % Bitstream must be available
            /okay false def
        } {
            verbits length dmod gt {/okay false def} if  % and fit into data modules
        } ifelse
        /term (000000000) 0 termlens vergrp get getinterval def
        okay {exit} if
    } for

    okay not {
        /bwipp.qrcodeNoValidSymbol (No valid symbol available) //raiseerror exec
    } if

    /format frmt def
    /version vers def
    /msgbits verbits def
    /dcpb dcws ecb1 ecb2 add idiv def                 % Base data codewords per block
    /ecpb ncws ecb1 ecb2 add idiv dcpb sub def        % Error correction codewords per block

    % Complete the message bits by adding the terminator, truncated if neccessary
    /term term 0 dmod msgbits length sub term length 2 copy gt {exch} if pop getinterval def
    msgbits length term length add string
    dup 0 msgbits putinterval
    dup msgbits length term putinterval
    /msgbits exch def

    % Expand the message bits by adding padding as necessary
    /pad dmod string def
    0 1 pad length 1 sub {pad exch 48 put} for
    pad 0 msgbits putinterval
    /padstrs [ (11101100) (00010001) ] def
    /padnum 0 def
    msgbits length 8 div ceiling 8 mul cvi 8 dmod lc4b {5} {1} ifelse sub {
        pad exch padstrs padnum get putinterval 
        /padnum padnum 1 add 2 mod def
    } for

    % Evaluate the padded message into codewords
    /cws dcws array def 
    0 1 cws length 1 sub {
        /c exch def
        /bpcw 8 def
        lc4b c cws length 1 sub eq and {/bpcw 4 def} if
        /cwb pad c 8 mul bpcw getinterval def
        /cw 0 def
        0 1 bpcw 1 sub {
            /i exch def
            /cw cw 2 bpcw i sub 1 sub exp cvi cwb i get 48 sub mul add def
        } for 
        cws c cw put
    } for 

    % Calculate the log and anti-log tables
    /rsalog [ 1 255 { dup 2 mul dup 256 ge {285 xor} if } repeat ] def
    /rslog 256 array def
    1 1 255 {dup rsalog exch get exch rslog 3 1 roll put} for

    % Function to calculate the product in the field
    /rsprod {
        2 copy 0 ne exch 0 ne and { 
            rslog exch get exch rslog exch get add 255 mod rsalog exch get
        } {
            pop pop 0
        } ifelse
    } bind def

    % Generate the coefficients for the Reed-Solomon algorithm
    /coeffs [ 1 ecpb {0} repeat ] def
    0 1 ecpb 1 sub {
        /i exch def 
        coeffs i 1 add coeffs i get put
        i -1 1 {
            /j exch def
            coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod xor put
        } for 
        coeffs 0 coeffs 0 get rsalog i get rsprod put
    } for
    /coeffs coeffs 0 coeffs length 1 sub getinterval def

    % Reed-Solomon algorithm to derive the error correction codewords
    /rscodes {
        /rscws exch def
        /rsnd rscws length def
        /rscws [ rscws {} forall ecpb {0} repeat ] def
        0 1 rsnd 1 sub {
            /m exch def
            /k rscws m get def
            0 1 ecpb 1 sub {
                /j exch def
                rscws m j add 1 add coeffs ecpb j sub 1 sub get k rsprod rscws m j add 1 add get xor put
            } for
        } for
        rscws rsnd ecpb getinterval
    } bind def

    % Divide codewords into two groups of blocks and calculate the error correction codewords
    /dcwsb ecb1 ecb2 add array def
    /ecwsb ecb1 ecb2 add array def
    0 1 ecb1 1 sub {  % First group of blocks has smaller number of data codewords
        /i exch def
        dcwsb i cws i dcpb mul dcpb getinterval put
        ecwsb i dcwsb i get rscodes put
    } for
    0 1 ecb2 1 sub {  % Second group of blocks has larger number of data codewords
        /i exch def
        dcwsb ecb1 i add cws ecb1 dcpb mul i dcpb 1 add mul add dcpb 1 add getinterval put
        ecwsb ecb1 i add dcwsb ecb1 i add get rscodes put
    } for
    
    % Reassemble the codewords
    /cws ncws array def
    /cw 0 def
    0 1 dcpb {  % Interleave the data codeword blocks
        /i exch def
        0 1 ecb1 ecb2 add 1 sub {
            /j exch def
            i dcwsb j get length lt {  % Ignore the end of short blocks
                cws cw dcwsb j get i get put
                /cw cw 1 add def
            } if
        } for
    } for
    0 1 ecpb 1 sub {  % Interleave the error codeword blocks
        /i exch def
        0 1 ecb1 ecb2 add 1 sub {
            /j exch def
            cws cw ecwsb j get i get put
            /cw cw 1 add def
        } for
    } for
    
    % Extend codewords by one if there are remainder bits
    rbit 0 gt {
        /pad cws length 1 add array def
        pad 0 cws putinterval
        pad pad length 1 sub 0 put
        /cws pad def
    } if
 
    % Fixups for the short final data byte in M1 and M3 symbols
    lc4b {
        dcws 1 sub 1 ncws 2 sub {
            /i exch def
            cws i cws i get 15 and 4 bitshift put
            cws i cws i 1 add get -4 bitshift 15 and cws i get or put
        } for
        cws ncws 1 sub cws ncws 1 sub get 15 and 4 bitshift put
    } if

    % Create the bitmap
    /pixs [ size size mul {-1} repeat ] def
    /qmv {size mul add} bind def
    
    % Finder patterns
    /fpat [
        [ 1 1 1 1 1 1 1 0 ]
        [ 1 0 0 0 0 0 1 0 ]
        [ 1 0 1 1 1 0 1 0 ]
        [ 1 0 1 1 1 0 1 0 ]
        [ 1 0 1 1 1 0 1 0 ]
        [ 1 0 0 0 0 0 1 0 ]
        [ 1 1 1 1 1 1 1 0 ]
        [ 0 0 0 0 0 0 0 0 ]
    ] def
    0 1 fpat length 1 sub {
      /y exch def
      0 1 fpat 0 get length 1 sub {
        /x exch def
        /fpb fpat y get x get def
        pixs x y qmv fpb put
        format (full) eq {
            pixs size x sub 1 sub y qmv fpb put
            pixs x size y sub 1 sub qmv fpb put
        } if
      } for
    } for
    
    % Alignment patterns
    /algnpat [
        [ 1 1 1 1 1 ]
        [ 1 0 0 0 1 ]
        [ 1 0 1 0 1 ]
        [ 1 0 0 0 1 ]
        [ 1 1 1 1 1 ]
    ] def
    /putalgnpat {
        /py exch def
        /px exch def
        0 1 4 {
            /pb exch def
            0 1 4 {
                /pa exch def
                pixs px pa add py pb add qmv algnpat pb get pa get put
            } for
        } for
    } bind def
    asp2 2 sub asp3 asp2 sub size 13 sub {
        /i exch def
        i 4 putalgnpat
        4 i putalgnpat
    } for
    asp2 2 sub asp3 asp2 sub size 9 sub { 
        /x exch def
        asp2 2 sub asp3 asp2 sub size 9 sub {
            /y exch def
            x y putalgnpat
        } for
    } for
    
    % Timing patterns
    format (full) eq {
        8 1 size 9 sub {
            /i exch def
            pixs i 6 qmv i 1 add 2 mod put
            pixs 6 i qmv i 1 add 2 mod put
        } for
    } {
        8 1 size 1 sub {
            /i exch def
            pixs i 0 qmv i 1 add 2 mod put
            pixs 0 i qmv i 1 add 2 mod put
        } for
    } ifelse
    
    % Format information modules
    format (full) eq {
        /formatmap [
            [ [ 0 8 ] [ 8 size 1 sub ] ]  [ [ 1 8 ] [ 8 size 2 sub ] ]  [ [ 2 8 ] [ 8 size 3 sub ] ]
            [ [ 3 8 ] [ 8 size 4 sub ] ]  [ [ 4 8 ] [ 8 size 5 sub ] ]  [ [ 5 8 ] [ 8 size 6 sub ] ]
            [ [ 7 8 ] [ 8 size 7 sub ] ]  [ [ 8 8 ] [ size 8 sub 8 ] ]  [ [ 8 7 ] [ size 7 sub 8 ] ]
            [ [ 8 5 ] [ size 6 sub 8 ] ]  [ [ 8 4 ] [ size 5 sub 8 ] ]  [ [ 8 3 ] [ size 4 sub 8 ] ]
            [ [ 8 2 ] [ size 3 sub 8 ] ]  [ [ 8 1 ] [ size 2 sub 8 ] ]  [ [ 8 0 ] [ size 1 sub 8 ] ]
        ] def
    } {
        /formatmap [
            [ [ 1 8 ] ]  [ [ 2 8 ] ]  [ [ 3 8 ] ]  [ [ 4 8 ] ]  [ [ 5 8 ] ]
            [ [ 6 8 ] ]  [ [ 7 8 ] ]  [ [ 8 8 ] ]  [ [ 8 7 ] ]  [ [ 8 6 ] ]
            [ [ 8 5 ] ]  [ [ 8 4 ] ]  [ [ 8 3 ] ]  [ [ 8 2 ] ]  [ [ 8 1 ] ]
        ] def
    } ifelse
    formatmap {
        { {} forall qmv pixs exch 0 put } forall
    } forall
    
    % Version information modules
    size 45 ge {
        /versionmap [
            [ [ size  9 sub 5 ] [ 5 size  9 sub ] ]  [ [ size 10 sub 5 ] [ 5 size 10 sub ] ]
            [ [ size 11 sub 5 ] [ 5 size 11 sub ] ]  [ [ size  9 sub 4 ] [ 4 size  9 sub ] ]
            [ [ size 10 sub 4 ] [ 4 size 10 sub ] ]  [ [ size 11 sub 4 ] [ 4 size 11 sub ] ]
            [ [ size  9 sub 3 ] [ 3 size  9 sub ] ]  [ [ size 10 sub 3 ] [ 3 size 10 sub ] ]
            [ [ size 11 sub 3 ] [ 3 size 11 sub ] ]  [ [ size  9 sub 2 ] [ 2 size  9 sub ] ]
            [ [ size 10 sub 2 ] [ 2 size 10 sub ] ]  [ [ size 11 sub 2 ] [ 2 size 11 sub ] ]
            [ [ size  9 sub 1 ] [ 1 size  9 sub ] ]  [ [ size 10 sub 1 ] [ 1 size 10 sub ] ]
            [ [ size 11 sub 1 ] [ 1 size 11 sub ] ]  [ [ size  9 sub 0 ] [ 0 size  9 sub ] ]
            [ [ size 10 sub 0 ] [ 0 size 10 sub ] ]  [ [ size 11 sub 0 ] [ 0 size 11 sub ] ]
        ] def
    } {
        /versionmap [] def
    } ifelse
    versionmap {
        { {} forall qmv pixs exch 0 put } forall
    } forall
    
    % Solitary dark module in full symbols
    format (full) eq {
        pixs 8 size 8 sub qmv 1 put
    } if
    
    % Calculate the mask patterns
    format (full) eq {
        /maskfuncs [ 
            {add 2 mod} bind
            {exch pop 2 mod} bind
            {pop 3 mod} bind
            {add 3 mod} bind
            {2 idiv exch 3 idiv add 2 mod} bind
            {mul dup 2 mod exch 3 mod add} bind
            {mul dup 2 mod exch 3 mod add 2 mod} bind
            {2 copy mul 3 mod 3 1 roll add 2 mod add 2 mod} bind
        ] def
    } {
        /maskfuncs [ 
            {exch pop 2 mod} bind
            {2 idiv exch 3 idiv add 2 mod} bind
            {mul dup 2 mod exch 3 mod add 2 mod} bind
            {2 copy mul 3 mod 3 1 roll add 2 mod add 2 mod} bind
        ] def
    } ifelse
    /masks maskfuncs length array def
    0 1 masks length 1 sub {
        /m exch def
        /mask size size mul array def
        0 1 size 1 sub {
            /j exch def
            0 1 size 1 sub {
                /i exch def
                i j maskfuncs m get exec 0 eq 
                pixs i j qmv get -1 eq and {1} {0} ifelse
                mask i j qmv 3 -1 roll put
            } for
        } for
        masks m mask put
    } for
    
    % Walk the symbol placing the bitstream
    /posx size 1 sub def
    /posy size 1 sub def
    /dir -1 def  % -1 is upwards, 1 is downwards
    /col 1 def   % 0 is left bit, 1 is right bit
    /num 0 def
    { % loop
        posx 0 lt {exit} if
        pixs posx posy qmv get -1 eq {
            cws num 8 idiv get 7 num 8 mod sub neg bitshift 1 and
            pixs posx posy qmv 3 -1 roll put
            /num num 1 add def
        } if
        col 1 eq {
            /col 0 def
            /posx posx 1 sub def
        } {
            /col 1 def
            /posx posx 1 add def 
            /posy posy dir add def
            posy 0 lt posy size ge or {  % Turn around at top and bottom
                /dir dir -1 mul def
                /posy posy dir add def
                /posx posx 2 sub def
                % Hop over the timing pattern in full size symbols
                format (full) eq posx 6 eq and {/posx posx 1 sub def} if
            } if
        } ifelse
    } loop

    % Evaluate runlength encoded rows or columns in full symbols
    /evalfulln1n3 {
        /scrle exch def
        % Detect runs of 5 or more like modules
        /scr1 0 scrle { dup 5 ge {add 2 sub dup} if pop } forall def
        % Detect 1:1:3:1:1 ratio next to 4 modules of whitespace
        /scr3 0 def
        3 2 scrle length 3 sub {  % Scan odd (dark) runs within bounds
            /j exch def
            scrle j get 3 mod 0 eq {  % Multiple of 3 black modules
                /fact scrle j get 3 idiv def
                scrle j 2 sub 5 getinterval {fact eq} forall and exch pop and and {
                    j 3 eq j 4 add scrle length ge or {  % At either extent of run
                        /scr3 scr3 40 add def
                    } {  % Bounded by dark modules
                        scrle j 3 sub get 4 ge scrle j 3 add get 4 ge or {
                            /scr3 scr3 40 add def
                        } if
                    } ifelse
                } if
            } if
        } for
        scr1 scr3
    } bind def
    
    % Evaluation algorithm for full symbols
    /evalfull {
        /sym exch def

        /n1 0 def /n2 0 def /n3 0 def
        /rle size 1 add array def
        /lastpairs size array def
        /thispairs size array def
        /sizeadd1 size 1 add def
        0 1 size 1 sub {  
            /i exch def

            % Runlength encode (light, dark, light, ...) and evaluate each column
            mark 0 0
            i size dup dup mul 1 sub {
                sym exch get exch 1 index eq {exch 1 add exch} {1 exch} ifelse
            } for
            pop
            rle 0 counttomark 2 sub getinterval astore
            evalfulln1n3 n3 add /n3 exch def n1 add /n1 exch def
            pop

            % Runlength encode (light, dark, light, ...) and evaluate each row
            /symrow sym i size mul size getinterval def
            mark 0 0 
            symrow { 
                exch 1 index eq {exch 1 add exch} {1 exch} ifelse
            } forall 
            pop
            rle 0 counttomark 2 sub getinterval astore
            evalfulln1n3 n3 add /n3 exch def n1 add /n1 exch def
            pop

            % Count and score same coloured blocks
            /lastpairs thispairs /thispairs lastpairs def def
            symrow 0 get 1 eq {0} {1} ifelse
            symrow {exch 1 index add exch} forall
            pop
            thispairs astore pop
            i 0 gt {
                mark
                lastpairs aload pop thispairs aload pop
                n2 size { exch sizeadd1 index add 3 and 0 eq {3 add} if } repeat
                /n2 exch def
                cleartomark
            } if

        } for
 
        % Score dark/light imbalance 
        /dark 0 sym {add} forall def
        /n4 dark 100 mul size dup mul div 50 sub abs 5 div cvi 10 mul def

        n1 n2 add n3 add n4 add
    } bind def
 
    % Evaluation algorithm for micro symbols
    /evalmicro {
        /sym exch def
        /dkrhs 0 def /dkbot 0 def
        1 1 size 1 sub {
            /i exch def
            /dkrhs dkrhs sym size 1 sub i qmv get add def
            /dkbot dkbot sym i size 1 sub qmv get add def
        } for
        dkrhs dkbot le {
            dkrhs 16 mul dkbot add neg
        } {
            dkbot 16 mul dkrhs add neg
        } ifelse
    } bind def
    
    % Evaluate the masked symbols to find the most suitable
    /bestscore 999999999 def
    0 1 masks length 1 sub {
        /m exch def
        /masksym size size mul array def
        0 1 size size mul 1 sub {
            /i exch def
            masksym i pixs i get masks m get i get xor put
        } for
        format (full) eq {
            masksym evalfull /score exch def
        } {
            masksym evalmicro /score exch def
        } ifelse
        score bestscore lt { 
            /bestsym masksym def
            /bestmaskval m def
            /bestscore score def
        } if    
    } for
    /pixs bestsym def
    
    % Add the format information
    format (full) eq {
        /fmtvals [
            16#5412 16#5125 16#5e7c 16#5b4b 16#45f9 16#40ce 16#4f97 16#4aa0 
            16#77c4 16#72f3 16#7daa 16#789d 16#662f 16#6318 16#6c41 16#6976
            16#1689 16#13be 16#1ce7 16#19d0 16#0762 16#0255 16#0d0c 16#083b 
            16#355f 16#3068 16#3f31 16#3a06 16#24b4 16#2183 16#2eda 16#2bed
        ] def
        /ecid (MLHQ) eclevel search pop length exch pop exch pop def
        /fmtval fmtvals ecid 3 bitshift bestmaskval add get def
    } {
        /fmtvals [
            16#4445 16#4172 16#4e2b 16#4b1c 16#55ae 16#5099 16#5fc0 16#5af7
            16#6793 16#62a4 16#6dfd 16#68ca 16#7678 16#734f 16#7c16 16#7921
            16#06de 16#03e9 16#0cb0 16#0987 16#1735 16#1202 16#1d5b 16#186c
            16#2508 16#203f 16#2f66 16#2a51 16#34e3 16#31d4 16#3e8d 16#3bba
        ] def
        /symid [ [0] [1 2] [3 4] [5 6 7] ] size 11 sub 2 idiv get eclval get def
        /fmtval fmtvals symid 2 bitshift bestmaskval add get def
    } ifelse
    0 1 formatmap length 1 sub {
        /i exch def
        formatmap i get {
            pixs exch {} forall qmv fmtval 14 i sub neg bitshift 1 and put
        } forall
    } for
    
    % Add the version information
    size 45 ge {
        /vervals [
            16#07c94 16#085bc 16#09a99 16#0a4d3 16#0bbf6 16#0c762 16#0d847 
            16#0e60d 16#0f928 16#10b78 16#1145d 16#12a17 16#13532 16#149a6 
            16#15683 16#168c9 16#177ec 16#18ec4 16#191e1 16#1afab 16#1b08e 
            16#1cc1a 16#1d33f 16#1ed75 16#1f250 16#209d5 16#216fd 16#228ba 
            16#2379f 16#24b0b 16#2542e 16#26a64 16#27541 16#28c69
        ] def
        /verval vervals size 17 sub 4 idiv 7 sub get def
        0 1 versionmap length 1 sub {
            /i exch def
            versionmap i get {
                pixs exch {} forall qmv verval 17 i sub neg bitshift 1 and put
            } forall
        } for
    } if

    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx size
    /pixy size
    /height size 2 mul 72 div
    /width size 2 mul 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/qrcode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER qrcode--

% --BEGIN ENCODER microqrcode--
% --REQUIRES preamble raiseerror renmatrix qrcode--
% --DESC: Micro QR Code
% --EXAM: 1234
% --EXOP:
% --RNDR: renmatrix
%%BeginResource: uk.co.terryburton.bwipp microqrcode 0.0 2015050900 60576 60353
%%BeginData:         43 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /qrcode dup /uk.co.terryburton.bwipp findresource put
begin
/microqrcode {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Get the result of encoding with qrcode with format=micro
    options (dontdraw) true put
    options (format) (micro) put

    /args barcode options //qrcode exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/microqrcode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER microqrcode--

% --BEGIN ENCODER maxicode--
% --REQUIRES preamble raiseerror renmaximatrix--
% --DESC: MaxiCode
% --EXAM: [)>^03001^02996152382802^029840^029001^0291Z00004951^029UPSN^02906X610^029159^0291234567^0291/1^029^029Y^029634 ALPHA DR^029PITTSBURGH^029PA^029^004
% --EXOP: mode=2 parse
% --RNDR: renmaximatrix
%%BeginResource: uk.co.terryburton.bwipp maxicode 0.0 2015050900 116961 123452
%%BeginData:        564 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renmaximatrix dup /uk.co.terryburton.bwipp findresource put
begin
/maxicode {

    20 dict begin

    /options exch def        % We are given an option string
    /barcode exch def        % We are given a barcode string

    /dontdraw false def
    /mode -1 def
    /sam -1 def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /mode mode cvi def
    /sam sam cvi def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if
    
    /msg barcode def
    /msglen msg length def

    % Special message handling for modes 2 and 3
    mode 2 eq mode 3 eq or {

        % Normalise messages that begin with a field identifier [)>RS01GSyy
        msg 0 7 getinterval <5b293e1e30311d> eq {
            /fid msg 0 9 getinterval def
            /msg msg 9 msglen 9 sub getinterval def 
        } {
            /fid () def
        } ifelse

        % Read the postcode, country code and service code fields seperated by GS
        msg <1d> search pop /pcode exch def
        pop <1d> search pop /ccode exch def
        pop <1d> search pop /scode exch def
        pop /msg exch def

        % Prepend the field identifier
        msg length fid length add string dup
        0 fid putinterval dup 
        fid length msg putinterval
        /msg exch def
        /msglen msg length def

    } if

    % Special function characters
    /eci -1 def  /pad -2 def  /ns -3 def
    /la  -4 def  /lb  -5 def
    /sa  -6 def  /sb  -7 def  /sc -8 def  /sd -9 def  /se -10 def
    /sa2 -11 def /sa3 -12 def  
    /lkc -13 def /lkd -14 def /lke -15 def
    /pd2 -16 def /pd3 -17 def 
    
    % Character maps for each state
    /charmaps [
        %  A    B    C    D    E
        [  13  (`)  192  224    0 ]  % 0
        [ (A)  (a)  193  225    1 ]  % 1
        [ (B)  (b)  194  226    2 ]  % 2
        [ (C)  (c)  195  227    3 ]  % 3
        [ (D)  (d)  196  228    4 ]  % 4
        [ (E)  (e)  197  229    5 ]  % 5
        [ (F)  (f)  198  230    6 ]  % 6
        [ (G)  (g)  199  231    7 ]  % 7
        [ (H)  (h)  200  232    8 ]  % 8
        [ (I)  (i)  201  233    9 ]  % 9 
        [ (J)  (j)  202  234   10 ]  % 10
        [ (K)  (k)  203  235   11 ]  % 11
        [ (L)  (l)  204  236   12 ]  % 12
        [ (M)  (m)  205  237   13 ]  % 13
        [ (N)  (n)  206  238   14 ]  % 14
        [ (O)  (o)  207  239   15 ]  % 15
        [ (P)  (p)  208  240   16 ]  % 16
        [ (Q)  (q)  209  241   17 ]  % 17
        [ (R)  (r)  210  242   18 ]  % 18
        [ (S)  (s)  211  243   19 ]  % 19
        [ (T)  (t)  212  244   20 ]  % 20
        [ (U)  (u)  213  245   21 ]  % 21
        [ (V)  (v)  214  246   22 ]  % 22
        [ (W)  (w)  215  247   23 ]  % 23
        [ (X)  (x)  216  248   24 ]  % 24
        [ (Y)  (y)  217  249   25 ]  % 25
        [ (Z)  (z)  218  250   26 ]  % 26
        [ eci  eci  eci  eci  eci ]  % 27
        [  28   28   28   28  pad ]  % 28
        [  29   29   29   29  pad ]  % 29
        [  30   30   30   30   27 ]  % 30
        [  ns   ns   ns   ns   ns ]  % 31
        [ ( )  ({)  219  251   28 ]  % 32
        [ pad  pad  220  252   29 ]  % 33
        [ (")  (})  221  253   30 ]  % 34
        [ (#)  (~)  222  254   31 ]  % 35
        [ ($)  127  223  255  159 ]  % 36
        [ (%)  (;)  170  161  160 ]  % 37
        [ (&)  (<)  172  168  162 ]  % 38
        [ (')  (=)  177  171  163 ]  % 39
        [  40  (>)  178  175  164 ]  % 40
        [  41  (?)  179  176  165 ]  % 41
        [ (*)  ([)  181  180  166 ]  % 42
        [ (+)   92  185  183  167 ]  % 43
        [ (,)  (])  186  184  169 ]  % 44
        [ (-)  (^)  188  187  173 ]  % 45
        [ (.)  (_)  189  191  174 ]  % 46
        [ (/)  ( )  190  138  182 ]  % 47
        [ (0)  (,)  128  139  149 ]  % 48
        [ (1)  (.)  129  140  150 ]  % 49
        [ (2)  (/)  130  141  151 ]  % 50
        [ (3)  (:)  131  142  152 ]  % 51
        [ (4)  (@)  132  143  153 ]  % 52
        [ (5)  (!)  133  144  154 ]  % 53
        [ (6)  (|)  134  145  155 ]  % 54
        [ (7)  pd2  135  146  156 ]  % 55
        [ (8)  sa2  136  147  157 ]  % 56
        [ (9)  sa3  137  148  158 ]  % 57
        [ (:)  pd3   la   la   la ]  % 58
        [  sb   sa  ( )  ( )  ( ) ]  % 59
        [  sc   sc  lkc   sc   sc ]  % 60
        [  sd   sd   sd  lkd   sd ]  % 61
        [  se   se   se   se  lke ]  % 62
        [  lb   la   lb   lb   lb ]  % 63
    ] def 
    
    % Invert charmaps to give character to value maps for each state
    /charvals [ 64 dict 64 dict 64 dict 64 dict 64 dict ] def
    0 1 charmaps length 1 sub {
        /i exch def
        /encs charmaps i get def
        0 1 4 {
            /j exch def
            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required
            charvals j get exch i put 
        } for
    } for
    /seta charvals 0 get def
    /setb charvals 1 get def
    /setc charvals 2 get def
    /setd charvals 3 get def
    /sete charvals 4 get def

    % Compute numeric runlengths
    /nseq [ msglen 1 add {0} repeat ] def
    msglen 1 sub -1 0 {
        /i exch def
        msg i get dup 48 ge exch 57 le and {
            nseq i nseq i 1 add get 1 add put
        } {
            nseq i 0 put
        } ifelse
    } for
    /nseq nseq 0 msglen getinterval def

    % Encode the message from ASCII to codewords 
    /prefixinset {
        0 {
            2 copy exch length ge {exit} if 
            2 copy get 3 index exch known {1 add} {exit} ifelse
        } loop
        exch pop exch pop
    } bind def
    
    /enc {
        exch get out exch j exch put
        /j j 1 add def
    } bind def

    /out 144 array def
    /i 0 def /j 0 def /cset (seta) def
    { % loop
        % Exit when no characters remain latching back to A if necessary
        i msglen eq {
            cset (seta) ne cset (setb) ne and {
                la cset load enc
                /cset (seta) def
            } if
            exit
        } if
        { % not a loop but common exit point
    
            % If 9 numerals available then use NS
            nseq i get 9 ge {
                msg i 9 getinterval cvi 4 { dup 63 and exch -6 bitshift } repeat cset load ns get
                0 2 10 {index} for 6 array astore 7 1 roll 6 {pop} repeat
                out exch j exch putinterval
                /i i 9 add def
                /j j 6 add def
                exit
            } if
    
            % Read next three characters
            /char1 msg i get def
            /char2 i 1 add msglen lt {msg i 1 add get} {-99} ifelse def
            /char3 i 2 add msglen lt {msg i 2 add get} {-99} ifelse def
    
            % If current mode is sufficient then directly encode
            cset load char1 known { 
                char1 cset load enc
                /i i 1 add def
                exit
            } if
    
            % For switching from A to B
            cset (seta) eq setb char1 known and {
                setb char2 known {
                    lb seta enc
                    /cset (setb) def
                } {
                    sb seta enc
                    char1 setb enc
                    /i i 1 add def
                } ifelse
                exit
            } if
    
            % For switching from B to A encode according to length of prefix
            cset (setb) eq seta char1 known and {
                /p seta msg i 4 msglen i sub 2 copy gt {exch} if pop getinterval prefixinset def
                p 1 eq {
                    sa setb enc
                    char1 seta enc
                    /i i 1 add def
                } if
                p 2 eq {
                    sa2 setb enc
                    char1 seta enc
                    char2 seta enc
                    /i i 2 add def 
                } if
                p 3 eq {
                    sa3 setb enc
                    char1 seta enc
                    char2 seta enc
                    char3 seta enc
                    /i i 3 add def 
                } if
                p 4 ge {
                    la setb enc
                    /cset (seta) def
                } if
                exit
            } if
    
            % If character is in A or B then directly latch
            seta char1 known {
                la cset load enc
                /cset (seta) def
                exit
            } if      
            setb char1 known {
                lb cset load enc
                /cset (setb) def
                exit
            } if      
     
            % Determine which one of sets C, D or E the character is in
            setc char1 known {/setx (setc) def /sx sc def /lkx lkc def} if
            setd char1 known {/setx (setd) def /sx sd def /lkx lkd def} if
            sete char1 known {/setx (sete) def /sx se def /lkx lke def} if
    
            % Encode according to the length of the prefix
            /p setx load msg i 4 msglen i sub 2 copy gt {exch} if pop getinterval prefixinset def
            p 1 eq {
                sx cset load enc
                char1 setx load enc
                /i i 1 add def
            } if
            p 2 eq {
                sx cset load enc
                char1 setx load enc
                sx cset load enc
                char2 setx load enc
                /i i 2 add def
            } if
            p 3 eq {
                sx cset load enc
                char1 setx load enc
                sx cset load enc
                char2 setx load enc
                sx cset load enc
                char3 setx load enc
                /i i 3 add def
            } if
            p 4 ge {
                sx cset load enc
                lkx setx load enc
                /cset setx def 
            } if
    
            exit
        } loop  % out
    } loop
    /encmsg out 0 j getinterval def
    /padval cset load pad get def 

    % Prefix the encoded message with the structured append insert
    /sami [] def
    sam -1 ne {
        /sami 2 array def
        sami 0 seta pad get put 
        sami 1 sam 10 idiv 1 sub 8 mul sam 10 mod 1 sub add put
    } if
    /encmsg [ sami aload pop encmsg aload pop ] def

    % Derive the primary and secondary codewords for modes 2 and 3
    mode 2 eq mode 3 eq or {

        % Calculate the fixed-width binary values for the mode, postcode, country code and service
        /mdb (0000) 4 string copy dup mode cvi 2 4 string cvrs dup length 4 exch sub exch putinterval def
        /ccb (0000000000) 10 string copy dup ccode cvi 2 10 string cvrs dup length 10 exch sub exch putinterval def
        /scb (0000000000) 10 string copy dup scode cvi 2 10 string cvrs dup length 10 exch sub exch putinterval def
        /pcb (000000000000000000000000000000000000) 36 string copy def
        mode 2 eq {
            % For numeric postcode, first six bits represent length and remaining 30 bits the value
            pcb pcode length 2 6 string cvrs dup length 6 exch sub exch putinterval
            pcb pcode cvi 2 30 string cvrs dup length 36 exch sub exch putinterval
        } {  % mode=3
            % For alphanumeric postcode, trim or pad with spaces to 6 chars and encode to binary
            /pccw [ 
                (      ) 6 string copy dup 0 pcode length 6 gt {pcode 0 6 getinterval} {pcode} ifelse putinterval 
                {seta exch get} forall
            ] def
            0 1 5 {
                /i exch def
                pcb pccw i get 2 6 string cvrs dup length 6 i mul 6 add exch sub exch putinterval
            } for
        } ifelse

        % Convolute the binary values into the structured carrier message
        /scm 60 string def
        scm 2  mdb putinterval
        scm 38 pcb 0  4 getinterval putinterval
        scm 30 pcb 4  6 getinterval putinterval
        scm 24 pcb 10 6 getinterval putinterval
        scm 18 pcb 16 6 getinterval putinterval
        scm 12 pcb 22 6 getinterval putinterval
        scm 6  pcb 28 6 getinterval putinterval
        scm 0  pcb 34 2 getinterval putinterval
        scm 52 ccb 0  2 getinterval putinterval
        scm 42 ccb 2  6 getinterval putinterval
        scm 36 ccb 8  2 getinterval putinterval
        scm 54 scb 0  6 getinterval putinterval
        scm 48 scb 6  4 getinterval putinterval

        % Evaluate the structured carrier message as codewords
        /pri [ 0 0 0 0 0 0 0 0 0 0 ] def
        0 1 59 { 
            /i exch def
            /ps i 6 idiv def
            /ep 2 5 i 6 mod sub exp cvi scm i get 48 sub mul def
            pri ps pri ps get ep add put
        } for

        % Pad the encoded message into the secondary component
        /sec [ 84 {padval} repeat ] def
        sec 0 encmsg putinterval

    } if

    % Derive the primary and secondary codewords for modes 4, 5 and 6
    mode 4 eq mode 5 eq or mode 6 eq or mode -1 eq or {

        % If mode isn't specified then use EEC if message fits, otherwise SEC
        mode -1 eq {
            /mode encmsg length 77 le {5} {4} ifelse def
        } if

        % First symbol is the mode and the remainder are the padded message
        /cws [ mode 5 eq {78} {94} ifelse {padval} repeat ] def
        cws 0 mode put
        cws 1 encmsg putinterval

        % Fit the message into the primary and secondary components
        /pri cws 0 10 getinterval def
        /sec cws 10 cws length 10 sub getinterval def

    } if

    % Calculate the log and anti-log tables
    /rsalog [ 1 63 { dup 2 mul dup 64 ge {67 xor} if } repeat ] def
    /rslog 64 array def
    1 1 63 {dup rsalog exch get exch rslog 3 1 roll put} for

    % Function to calculate the product in the field
    /rsprod {
        2 copy 0 ne exch 0 ne and {
            rslog exch get exch rslog exch get add 63 mod rsalog exch get
        } {
            pop pop 0
        } ifelse
    } bind def

    % Generate error correction codewords
    /rscodes {

        /rsnum exch def
        /cwb exch def

        % Generate the coefficients
        /coeffs [ 1 rsnum {0} repeat ] def
        1 1 rsnum {
            /i exch def
            coeffs i coeffs i 1 sub get put
            i 1 sub -1 1 {
                /j exch def
                coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod xor put
            } for
            coeffs 0 coeffs 0 get rsalog i get rsprod put
        } for
        /coeffs coeffs 0 coeffs length 1 sub getinterval def

        % Calculate the error correction codewords
        /ecb [ rsnum {0} repeat ] def
        0 1 cwb length 1 sub {
            /t exch cwb exch get ecb 0 get xor def
            ecb length 1 sub -1 0 {
                /i exch def
                /p ecb length i sub 1 sub def
                ecb p t coeffs i get rsprod put
                i 0 gt { ecb p ecb p 1 add get ecb p get xor put } if
            } for
        } for

        ecb

    } bind def

    % Split secondary codeword into odd and even elements
    /seco [ 0 2 sec length 1 sub { sec exch get } for ] def
    /sece [ 1 2 sec length 1 sub { sec exch get } for ] def

    % Calculate the parity codewords for secondary codeword parts based on mode
    /scodes sec length 84 eq {20} {28} ifelse def  % SEC/EEC mode
    /secochk seco scodes rscodes def
    /secechk sece scodes rscodes def

    % Recompose the secondary parity codewords
    /secchk [ 0 1 scodes 1 sub { dup secochk exch get exch secechk exch get } for ] def

    % Concatinate the data into final codewords
    /codewords [
        pri aload pop 
        pri 10 rscodes aload pop
        sec aload pop 
        secchk aload pop
    ] def

    % Convert the codewords into module bits
    /mods [ 864 {0} repeat ] def
    0 1 143 {
        /i exch def
        /cw [ codewords i get 2 6 string cvrs {48 sub} forall ] def
        mods 6 i mul 6 cw length sub add cw putinterval
    } for

    % Maps modules to pixels in the grid
    /modmap [
        469 529 286 316 347 346 673 672 703 702 647 676 283 282 313 312 370 610 618 379 
        378 409 408 439 705 704 559 589 588 619 458 518 640 701 675 674 285 284 315 314 
        310 340 531 289 288 319 349 348 456 486 517 516 471 470 369 368 399 398 429 428 
        549 548 579 578 609 608 649 648 679 678 709 708 639 638 669 668 699 698 279 278 
        309 308 339 338 381 380 411 410 441 440 561 560 591 590 621 620 547 546 577 576 
        607 606 367 366 397 396 427 426 291 290 321 320 351 350 651 650 681 680 711 710 
        1   0   31  30  61  60  3   2   33  32  63  62  5   4   35  34  65  64  7   6   
        37  36  67  66  9   8   39  38  69  68  11  10  41  40  71  70  13  12  43  42  
        73  72  15  14  45  44  75  74  17  16  47  46  77  76  19  18  49  48  79  78  
        21  20  51  50  81  80  23  22  53  52  83  82  25  24  55  54  85  84  27  26  
        57  56  87  86  117 116 147 146 177 176 115 114 145 144 175 174 113 112 143 142 
        173 172 111 110 141 140 171 170 109 108 139 138 169 168 107 106 137 136 167 166 
        105 104 135 134 165 164 103 102 133 132 163 162 101 100 131 130 161 160 99  98  
        129 128 159 158 97  96  127 126 157 156 95  94  125 124 155 154 93  92  123 122 
        153 152 91  90  121 120 151 150 181 180 211 210 241 240 183 182 213 212 243 242 
        185 184 215 214 245 244 187 186 217 216 247 246 189 188 219 218 249 248 191 190 
        221 220 251 250 193 192 223 222 253 252 195 194 225 224 255 254 197 196 227 226 
        257 256 199 198 229 228 259 258 201 200 231 230 261 260 203 202 233 232 263 262 
        205 204 235 234 265 264 207 206 237 236 267 266 297 296 327 326 357 356 295 294 
        325 324 355 354 293 292 323 322 353 352 277 276 307 306 337 336 275 274 305 304 
        335 334 273 272 303 302 333 332 271 270 301 300 331 330 361 360 391 390 421 420 
        363 362 393 392 423 422 365 364 395 394 425 424 383 382 413 412 443 442 385 384 
        415 414 445 444 387 386 417 416 447 446 477 476 507 506 537 536 475 474 505 504 
        535 534 473 472 503 502 533 532 455 454 485 484 515 514 453 452 483 482 513 512 
        451 450 481 480 511 510 541 540 571 570 601 600 543 542 573 572 603 602 545 544 
        575 574 605 604 563 562 593 592 623 622 565 564 595 594 625 624 567 566 597 596 
        627 626 657 656 687 686 717 716 655 654 685 684 715 714 653 652 683 682 713 712 
        637 636 667 666 697 696 635 634 665 664 695 694 633 632 663 662 693 692 631 630 
        661 660 691 690 721 720 751 750 781 780 723 722 753 752 783 782 725 724 755 754 
        785 784 727 726 757 756 787 786 729 728 759 758 789 788 731 730 761 760 791 790 
        733 732 763 762 793 792 735 734 765 764 795 794 737 736 767 766 797 796 739 738 
        769 768 799 798 741 740 771 770 801 800 743 742 773 772 803 802 745 744 775 774 
        805 804 747 746 777 776 807 806 837 836 867 866 897 896 835 834 865 864 895 894 
        833 832 863 862 893 892 831 830 861 860 891 890 829 828 859 858 889 888 827 826 
        857 856 887 886 825 824 855 854 885 884 823 822 853 852 883 882 821 820 851 850 
        881 880 819 818 849 848 879 878 817 816 847 846 877 876 815 814 845 844 875 874 
        813 812 843 842 873 872 811 810 841 840 871 870 901 900 931 930 961 960 903 902 
        933 932 963 962 905 904 935 934 965 964 907 906 937 936 967 966 909 908 939 938 
        969 968 911 910 941 940 971 970 913 912 943 942 973 972 915 914 945 944 975 974 
        917 916 947 946 977 976 919 918 949 948 979 978 921 920 951 950 981 980 923 922 
        953 952 983 982 925 924 955 954 985 984 927 926 957 956 987 986 58  89  88  118 
        149 148 178 209 208 238 269 268 298 329 328 358 389 388 418 449 448 478 509 508 
        538 569 568 598 629 628 658 689 688 718 749 748 778 809 808 838 869 868 898 929 
        928 958 989 988
    ] def

    % Lookup pixels for enabled modules from modmap
    /pixs 864 array def
    /j 0 def
    0 1 mods length 1 sub {
        /i exch def
        mods i get 1 eq {
            pixs j modmap i get put
            /j j 1 add def
        } if
    } for
    /pixs [ pixs 0 j getinterval {} forall 28 29 280 281 311 457 488 500 530 670 700 677 707 ] def

    % Return the arguments
    <<
    /ren //renmaximatrix
    /pixs pixs
    /opt options
    >>

    dontdraw not //renmaximatrix if

    end

} bind def
/maxicode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER maxicode--

% --BEGIN ENCODER azteccode--
% --REQUIRES preamble raiseerror renmatrix--
% --DESC: Aztec Code
% --EXAM: This is Aztec Code
% --EXOP: format=full
% --RNDR: renmatrix
%%BeginResource: uk.co.terryburton.bwipp azteccode 0.0 2015050900 163082 186690
%%BeginData:        679 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/azteccode {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /format (unset) def    % full, compact or rune
    /readerinit false def
    /layers -1 def
    /eclevel 23 def
    /ecaddchars 3 def
    /raw false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /layers layers cvi def
    /eclevel eclevel cvr def
    /ecaddchars ecaddchars cvi def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    % Convert from input into message bitstream
    /msgbits () def 
    format (rune) ne raw and {/msgbits barcode def} if 
    format (rune) ne raw not and {

        % State key: "U"pper, "L"ower, "M"ixed, "P"unctuation, "D"igit, "B"inary
        /U 0 def  /L 1 def  /M 2 def  /P 3 def  /D 4 def  /B 5 def
        
        % Special function characters
        /lu -1 def  /ll -2 def  /lm -3 def
        /lp -4 def  /ld -5 def  /su -6 def
        /sp -7 def  /sb -8 def  /fl -9 def
        /p2 -10 def /p3 -11 def /p4 -12 def /p5 -13 def
        
        % Character maps for each state
        /charmaps [
            %  U    L    M    P    D
            [  sp   sp   sp   fl   sp ]  % 0
            [  32   32   32   13   32 ]  % 1
            [ (A)  (a)    1   p2  (0) ]  % 2     p2 = CR LF
            [ (B)  (b)    2   p3  (1) ]  % 3     p3 = ". "
            [ (C)  (c)    3   p4  (2) ]  % 4     p4 = ", "
            [ (D)  (d)    4   p5  (3) ]  % 5     p5 = ": "
            [ (E)  (e)    5  (!)  (4) ]  % 6
            [ (F)  (f)    6  (")  (5) ]  % 7
            [ (G)  (g)    7  (#)  (6) ]  % 8
            [ (H)  (h)    8  ($)  (7) ]  % 9
            [ (I)  (i)    9  (%)  (8) ]  % 10
            [ (J)  (j)   10  (&)  (9) ]  % 11
            [ (K)  (k)   11  (')  (,) ]  % 12
            [ (L)  (l)   12   40  (.) ]  % 13
            [ (M)  (m)   13   41   lu ]  % 14
            [ (N)  (n)   27  (*)   su ]  % 15
            [ (O)  (o)   28  (+)  -99 ]  % 16
            [ (P)  (p)   29  (,)  -99 ]  % 17
            [ (Q)  (q)   30  (-)  -99 ]  % 18
            [ (R)  (r)   31  (.)  -99 ]  % 19
            [ (S)  (s)  (@)  (/)  -99 ]  % 20
            [ (T)  (t)   92  (:)  -99 ]  % 21
            [ (U)  (u)  (^)  (;)  -99 ]  % 22
            [ (V)  (v)  (_)  (<)  -99 ]  % 23
            [ (W)  (w)  (`)  (=)  -99 ]  % 24
            [ (X)  (x)  (|)  (>)  -99 ]  % 25
            [ (Y)  (y)  (~)  (?)  -99 ]  % 26
            [ (Z)  (z)  127  ([)  -99 ]  % 27
            [  ll   su   ll  (])  -99 ]  % 28
            [  lm   lm   lu  ({)  -99 ]  % 29
            [  ld   ld   lp  (})  -99 ]  % 30
            [  sb   sb   sb   lu  -99 ]  % 31
        ] def 
        
        % Invert charmaps to give character to value maps for each state
        /charvals [ 32 dict 32 dict 32 dict 32 dict 16 dict ] def
        0 1 charmaps length 1 sub {
            /i exch def
            /encs charmaps i get def
            0 1 4 {
                /j exch def
                encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required
                charvals j get exch i put 
            } for
        } for
        
        % Punctuation compression
        /pcomp <<
            <0d0a> p2   % CR LF
            (. )   p3
            (, )   p4
            (: )   p5
        >> def
        
        /e 10000 def  % "Empty"
        
        /latlen [  % Bit length of latch between states
        % To:  U  L  M  P  D  B      From
            [  0  5  5 10  5 10 ]  % U
            [  9  0  5 10  5 10 ]  % L
            [  5  5  0  5 10 10 ]  % M
            [  5 10 10  0 10 15 ]  % P
            [  4  9  9 14  0 14 ]  % D
            [  0  0  0  0  0  0 ]  % B
        ] def

        /latseq [  % Latch sequences between states
        % To: U       L       M       P          D       B          From
            [ []      [ll]    [lm]    [lm lp]    [ld]    [sb]    ]  % U
            [ [ld lu] []      [lm]    [lm lp]    [ld]    [sb]    ]  % L
            [ [lu]    [ll]    []      [lp]       [lu ld] [sb]    ]  % M
            [ [lu]    [lu ll] [lu lm] []         [lu ld] [lu sb] ]  % P
            [ [lu]    [lu ll] [lu lm] [lu lm lp] []      [lu sb] ]  % D
            [ [lu]    [ll]    [lm]    []         []      []      ]  % B
        ] def

        /shftlen [  % Bit length of shift to state
        % To:  U  L  M  P  D      From
            [  e  e  e  5  e ]  % U
            [  5  e  e  5  e ]  % L
            [  e  e  e  5  e ]  % M
            [  e  e  e  e  e ]  % P
            [  4  e  e  4  e ]  % D
        ] def
        
        %            U   L   M   P   D   B
        /charsize [  5   5   5   5   4   8 ] def
        
        %          U  L  M  P  D  B
        /curlen [  0  e  e  e  e  e ] def
        /curseq [ [] [] [] [] [] [] ] def
        
        /backto U def  % U
        /lastchar () def
        
        % Derive the optimal sequences ending in each state
        barcode {
        
            /char exch def
          
            % Check for optimisations in the current sequences by latching from x to y
            {  % loop
                /imp false def
                [ U L M P D B ] {
                    /x exch def
                    [ U L M P D B ] {
                        /y exch def
                        x B ne y backto eq or {  % Only B -> backto
                            /cost curlen x get latlen x get y get add def
                            cost curlen y get lt {
                                curlen y cost put
                                curseq y [
                                    curseq x get aload pop
                                    latseq x get y get aload pop
                                ] put
                                y B eq {  % Set backto to previous state
                                    /backto x P eq x D eq or {U} {x} ifelse def
                                } if
                                /imp true def
                            } if
                        } if
                    } forall
                } forall
                imp not {exit} if  % Repeat unless no improvement
            } loop

            % Determine optimal next sequences for each valid encoding 
            /nxtlen [ e e e e e e ] def 
            /nxtseq 6 array def
          
            [ U L M P D B ] {
                /x exch def
            
                { % loop for common exit
            
                    % Skip states that cannot encode character
                    x B ne {charvals x get char known not {exit} if} if
              
                    % Extend directly
                    /cost curlen x get charsize x get add def
                    cost nxtlen x get lt {
                        nxtlen x cost put
                        nxtseq x [ curseq x get aload pop char ] put
                    } if
              
                    % Optimise for direct shifts from y to x 
                    x B eq {exit} if  % B is treated as a latch
                    [ U L M P D ] {
                        /y exch def
                        x y ne {
                            /cost curlen y get shftlen y get x get add charsize x get add def
                            cost nxtlen y get lt {
                                nxtlen y cost put
                                nxtseq y [
                                    curseq y get aload pop
                                    x U eq {su} {sp} ifelse
                                    char
                                ] put
                            } if
                        } if
                    } forall
              
                    exit
                } loop
            
            } forall
          
            % Optimise using P compression
            lastchar () ne {
                /pchars 2 string dup 0 lastchar put dup 1 char put def
                pcomp pchars known {
                    curlen P get nxtlen P get lt {
                        nxtlen P curlen P get put
                        nxtseq P [ curseq P get aload pop pop pcomp pchars get ] put
                    } if
                } if
            } if 
          
            % Account for binary extension for 32 or more bytes
            /numbytes 0 def
            nxtseq B get {
                sb eq {0} {numbytes 1 add} ifelse /numbytes exch def
            } forall
            numbytes 32 eq {nxtlen B nxtlen B get 11 add put} if
          
            /curlen nxtlen def
            /curseq nxtseq def
            /lastchar char def
          
        } forall
        
        % Select the optimal sequence
        /minseq e def
        [ U L M P D B ] {
            /i exch def
            curlen i get minseq lt {
                /minseq curlen i get def
                /seq curseq i get def
            } if
        } forall
        
        % Encoding functions
        /tobin {
            string dup length 1 sub 0 exch 1 exch {1 index exch 48 put} for
            dup 3 -1 roll 2 2 index length string cvrs dup length 2 index length exch sub exch putinterval 
        } bind def
        /encu {charvals U get exch get 5 tobin} bind def
        /encl {charvals L get exch get 5 tobin} bind def
        /encm {charvals M get exch get 5 tobin} bind def
        /encp {charvals P get exch get 5 tobin} bind def
        /encd {charvals D get exch get 4 tobin} bind def
        /encfuncs [ /encu /encl /encm /encp /encd ] def
        /addtomsgbits {
            /v exch def
            msgbits j v putinterval
            /j j v length add def
        } bind def
        
        % Encode the sequence
        /state U def
        /msgbits minseq string def
        /i 0 def /j 0 def {
            i seq length ge {exit} if
          
            state B ne {
          
                /char seq i get def
            
                % Encode character
                char encfuncs state get load exec addtomsgbits
                /i i 1 add def
            
                % Encode shifted next character
                char su eq char sp eq or {
                    seq i get char su eq {encu} {encp} ifelse addtomsgbits
                    /i i 1 add def
                } if
            
                % Latches to new state
                char lu eq {/state U def} if
                char ll eq {/state L def} if
                char lm eq {/state M def} if
                char lp eq {/state P def} if
                char ld eq {/state D def} if
                char sb eq {/state B def} if
            
            } {  % Binary
          
                % Find number of bytes before latch or end
                /numbytes 0 def {
                    i numbytes add seq length ge {exit} if
                    seq i numbytes add get 0 lt {exit} if 
                    /numbytes numbytes 1 add def
                } loop
            
                % Encode length
                numbytes 31 le {
                    numbytes 5 tobin addtomsgbits
                } {
                    0 5 tobin addtomsgbits
                    numbytes 31 sub 11 tobin addtomsgbits
                } ifelse
            
                % Encode bytes
                numbytes {
                    seq i get 8 tobin addtomsgbits 
                    /i i 1 add def
                } repeat
            
                % Return to previous state as indicated
                i seq length lt {
                    /char seq i get def
                    /i i 1 add def
                    char lu eq {/state U def} if
                    char ll eq {/state L def} if
                    char lm eq {/state M def} if
                } if
            
            } ifelse
          
        } loop

    } if

    % Lookup the most appropriate symbol specification 
    /metrics [
        [ (rune)     0 0    0  6 ]  % Special metric for rune symbols
        [ (compact)  1 1   17  6 ] [ (full)     1 1   21  6 ] [ (compact)  2 0   40  6 ]
        [ (full)     2 1   48  6 ] [ (compact)  3 0   51  8 ] [ (full)     3 1   60  8 ]
        [ (compact)  4 0   76  8 ] [ (full)     4 1   88  8 ] [ (full)     5 1  120  8 ]
        [ (full)     6 1  156  8 ] [ (full)     7 1  196  8 ] [ (full)     8 1  240  8 ]
        [ (full)     9 1  230 10 ] [ (full)    10 1  272 10 ] [ (full)    11 1  316 10 ]
        [ (full)    12 1  364 10 ] [ (full)    13 1  416 10 ] [ (full)    14 1  470 10 ]
        [ (full)    15 1  528 10 ] [ (full)    16 1  588 10 ] [ (full)    17 1  652 10 ]
        [ (full)    18 1  720 10 ] [ (full)    19 1  790 10 ] [ (full)    20 1  864 10 ]
        [ (full)    21 1  940 10 ] [ (full)    22 1 1020 10 ] [ (full)    23 0  920 12 ]
        [ (full)    24 0  992 12 ] [ (full)    25 0 1066 12 ] [ (full)    26 0 1144 12 ]
        [ (full)    27 0 1224 12 ] [ (full)    28 0 1306 12 ] [ (full)    29 0 1392 12 ]
        [ (full)    30 0 1480 12 ] [ (full)    31 0 1570 12 ] [ (full)    32 0 1664 12 ]
    ] def

    /i 0 def
    { % loop
        /m metrics i get def
        /frmt m 0 get def                          % Format of the symbol
        /mlyr m 1 get def                          % Data layers
        /icap m 2 get def                          % Reader initialisation capable
        /ncws m 3 get def                          % Total of codewords
        /bpcw m 4 get def                          % Bits per codeword
        /numecw ncws eclevel mul 100 div ecaddchars add ceiling cvi def
        msgbits length 0 eq {/numecw 0 def} if     % Error correction codewords 
        /numdcw ncws numecw sub def                % Data codewords
        /okay true def
        format (unset) ne format frmt ne and {/okay false def} if
        readerinit icap 1 ne and {/okay false def} if
        layers -1 ne layers mlyr ne and {/okay false def} if 
        msgbits length bpcw div ceiling cvi numdcw gt {/okay false def} if
        okay {exit} if
        /i i 1 add def
    } loop
    /layers mlyr def
    /format frmt def

    % Expand message bits into codewords avoiding codewords with all zeros or all ones
    /allzero {dup length (000000000000) 0 3 -1 roll getinterval eq} bind def
    /allones {dup length (111111111111) 0 3 -1 roll getinterval eq} bind def
    /cws ncws array def
    /m 0 def /c 0 def
    {
        msgbits length m le {exit} if
        msgbits length m sub bpcw ge {
            /cwb msgbits m bpcw 1 sub getinterval def        % All but last bit
            /cwf msgbits m bpcw add 1 sub 1 getinterval def  % Last bit
            cwb allzero {/cwf (1) def /m m 1 sub def} if     % Flip last bit to avoid zeros
            cwb allones {/cwf (0) def /m m 1 sub def} if     % Flip last bit to avoid ones
            % Concatinate the bits 
            12 string dup 0 cwb putinterval 
            dup bpcw 1 sub cwf putinterval
            0 bpcw getinterval
            /cwb exch def
        } {  %  Final codeword
            /cwb msgbits m msgbits length m sub getinterval def
            /cwb (111111111111) 12 string copy dup 0 cwb putinterval 0 bpcw getinterval def
            cwb allones {cwb cwb length 1 sub (0) putinterval} if  % Prevent all ones
        } ifelse
        % Conversion of binary data into byte array
        /cw 0 def
        0 1 bpcw 1 sub {
            /i exch def
            /cw cw 2 bpcw i sub 1 sub exp cvi cwb i get 48 sub mul add def
        } for
        cws c cw put
        /m m bpcw add def 
        /c c 1 add def
    } loop    
    /cws cws 0 c getinterval def

    % Reed-Solomon algorithm
    /rscodes {

        /rspm exch def
        /rsgf exch def
        /rsnc exch def
        /rscws exch def

        % Calculate the log and anti-log tables
        /rsalog [ 1 rsgf 1 sub { dup 2 mul dup rsgf ge {rspm xor} if } repeat ] def
        /rslog rsgf array def
        1 1 rsgf 1 sub {dup rsalog exch get exch rslog 3 1 roll put} for

        % Function to calculate the product in the field
        /rsprod {
            2 copy 0 ne exch 0 ne and {
                rslog exch get exch rslog exch get add rsgf 1 sub mod rsalog exch get
            } {
                pop pop 0
            } ifelse
        } bind def

        % Generate the coefficients
        /coeffs [ 1 rsnc {0} repeat ] def
        1 1 rsnc {
            /i exch def 
            coeffs i coeffs i 1 sub get put
            i 1 sub -1 1 {
                /j exch def
                coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod xor put
            } for 
            coeffs 0 coeffs 0 get rsalog i get rsprod put
        } for

        % Extend the input with the error correction values
        /nd rscws length def
        /rscws [ rscws {} forall rsnc {0} repeat 0 ] def
        0 1 nd 1 sub {
            /k exch rscws exch get rscws nd get xor def 
            0 1 rsnc 1 sub {
                /j exch def 
                rscws nd j add rscws nd j add 1 add get k coeffs rsnc j sub 1 sub get rsprod xor put
            } for 
        } for

        % Return all but the last codeword
        rscws 0 rscws length 1 sub getinterval

    } bind def

    % Create the codewords and bit string for the mode
    format (full) eq {
        /mode layers 1 sub 11 bitshift cws length 1 sub add def
        readerinit {/mode mode 2#0000010000000000 or def} if
        /mode [
            mode 2#1111000000000000 and -12 bitshift
            mode 2#0000111100000000 and -8 bitshift
            mode 2#0000000011110000 and -4 bitshift
            mode 2#0000000000001111 and
        ] def
        /mode mode 6 16 19 rscodes def 
    } if
    format (compact) eq {
        /mode layers 1 sub 6 bitshift cws length 1 sub add def
        readerinit {/mode mode 2#00100000 or def} if 
        /mode [
            mode 2#11110000 and -4 bitshift
            mode 2#00001111 and
        ] def
        /mode mode 5 16 19 rscodes def
    } if
    format (rune) eq {
        /mode barcode cvi def
        /mode [
            mode 2#11110000 and -4 bitshift
            mode 2#00001111 and
        ] def
        /mode mode 5 16 19 rscodes def
        /mode [mode {2#1010 xor} forall] def  % Invert alternate bits
    } if
    /modebits mode length 4 mul string def
    0 1 modebits length 1 sub {modebits exch (0) putinterval} for
    0 1 mode length 1 sub {
        /i exch def
        modebits mode i get 2 4 string cvrs dup length 4 exch sub 4 i mul add exch putinterval 
    } for

    % Extend the data codewords with error correction codewords to create the bit string for the data
    /rsparams [
        [] [] [] [] [] [] 
        [ 64 67 ]      % 6-bit codewords 
        []
        [ 256 301 ]    % 8-bit codewords
        [] 
        [ 1024 1033 ]  % 10-bit codewords
        []
        [ 4096 4201 ]  % 12-bit codewords
    ] def
    /cws cws ncws cws length sub rsparams bpcw get {} forall rscodes def
    format (full) eq {
        /databits layers layers mul 16 mul layers 112 mul add string def 
    } {
        /databits layers layers mul 16 mul layers 88 mul add string def 
    } ifelse
    0 1 databits length 1 sub {databits exch (0) putinterval} for
    0 1 ncws 1 sub { 
        /i exch def
        databits cws i get 2 bpcw string cvrs 
        dup length bpcw exch sub bpcw i mul add databits length ncws bpcw mul sub add 
        exch putinterval 
    } for

    % Move to a point in the cartesian plane centered on the bullseye
    /cmv {size mul sub mid add} bind def

    % Move to a bit position within a layer
    /lmv {
        /lbit exch def
        /llyr exch def
        /lwid fw llyr 4 mul add def
        /ldir lbit 2 idiv lwid idiv def
        ldir 0 eq {  % Top
            lwid 1 sub 2 idiv neg 1 add lbit 2 idiv lwid mod add 
            fw 1 sub 2 idiv llyr 2 mul add lbit 2 mod add
            cmv
        } if
        ldir 1 eq {  % Right
            fw 2 idiv llyr 2 mul add lbit 2 mod add
            lwid 1 sub 2 idiv 1 sub lbit 2 idiv lwid mod sub
            cmv
        } if
        ldir 2 eq {  % Bottom
            lwid 2 idiv neg 1 add lbit 2 idiv lwid mod add neg
            fw 2 idiv llyr 2 mul add lbit 2 mod add neg
            cmv
        } if
        ldir 3 eq {  % Left
            fw 1 sub 2 idiv llyr 2 mul add lbit 2 mod add neg
            lwid 2 idiv 1 sub lbit 2 idiv lwid mod sub neg
            cmv
        } if
    } bind def

    % Create the pixel map
    % For full symbols we disregard the reference grid at this stage
    format (full) eq {/fw 12 def} {/fw 9 def} ifelse
    /size fw layers 4 mul add 2 add def 
    /pixs [size size mul {-1} repeat] def
    /mid size 1 sub 2 idiv size mul size 1 sub 2 idiv add def

    % Data layers
    /i 0 def
    1 1 layers {
        /layer exch def
        0 1 fw layer 4 mul add 8 mul 1 sub {
            /pos exch def
            pixs layer pos lmv databits databits length i sub 1 sub get 48 sub put
            /i i 1 add def
        } for
    } for

    % For full symbols expand the pixel map by inserting the reference grid
    format (full) eq {
        /fw 13 def
        /size fw layers 4 mul add 2 add layers 10.5 add 7.5 div 1 sub cvi 2 mul add def
        /mid size size mul 2 idiv def
        /npixs [size size mul {-2} repeat] def
        0 16 size 2 idiv {
            /i exch def
            0 1 size 1 sub {
                /j exch def
                npixs size 2 idiv neg j add i cmv     [size 2 idiv j add i add 1 add 2 mod] putinterval
                npixs size 2 idiv neg j add i neg cmv [size 2 idiv j add i add 1 add 2 mod] putinterval
                npixs i size 2 idiv neg j add cmv     [size 2 idiv j add i add 1 add 2 mod] putinterval
                npixs i neg size 2 idiv neg j add cmv [size 2 idiv j add i add 1 add 2 mod] putinterval
            } for
        } for 
        /j 0 def
        0 1 npixs length 1 sub {
            /i exch def
            npixs i get -2 eq {
                npixs i pixs j get put
                /j j 1 add def
            } if
        } for
        /pixs npixs def
    } if

    % Finder pattern
    /fw fw 2 idiv def
    fw neg 1 fw {
        /i exch def
        fw neg 1 fw {
            /j exch def
            pixs i j cmv
            i abs j abs gt {i abs} {j abs} ifelse 1 add 2 mod
            put
        } for
    } for

    % Orientation bits
    [ [ fw 1 add neg   fw             1 ] [ fw 1 add neg   fw 1 add       1 ]
      [ fw neg         fw 1 add       1 ] [ fw 1 add       fw 1 add       1 ]
      [ fw 1 add       fw             1 ] [ fw 1 add       fw neg         1 ]
      [ fw             fw 1 add       0 ] [ fw 1 add       fw 1 add neg   0 ]
      [ fw             fw 1 add neg   0 ] [ fw neg         fw 1 add neg   0 ]
      [ fw 1 add neg   fw 1 add neg   0 ] [ fw 1 add neg   fw neg         0 ]
    ] {pixs exch {} forall 3 1 roll cmv exch put} forall

    % Mode ring
    format (full) eq {
        /modemap [ 
            [-5  7] [-4  7] [-3  7] [-2  7] [-1  7] [ 1  7] [ 2  7] [ 3  7] [ 4  7] [ 5  7]
            [ 7  5] [ 7  4] [ 7  3] [ 7  2] [ 7  1] [ 7 -1] [ 7 -2] [ 7 -3] [ 7 -4] [ 7 -5]
            [ 5 -7] [ 4 -7] [ 3 -7] [ 2 -7] [ 1 -7] [-1 -7] [-2 -7] [-3 -7] [-4 -7] [-5 -7]
            [-7 -5] [-7 -4] [-7 -3] [-7 -2] [-7 -1] [-7  1] [-7  2] [-7  3] [-7  4] [-7  5]
        ] def
    } {
        /modemap [
            [-3  5] [-2  5] [-1  5] [ 0  5] [ 1  5] [ 2  5] [ 3  5]
            [ 5  3] [ 5  2] [ 5  1] [ 5  0] [ 5 -1] [ 5 -2] [ 5 -3]
            [ 3 -5] [ 2 -5] [ 1 -5] [ 0 -5] [-1 -5] [-2 -5] [-3 -5]
            [-5 -3] [-5 -2] [-5 -1] [-5  0] [-5  1] [-5  2] [-5  3]
        ] def
    } ifelse
    0 1 modemap length 1 sub {
        /i exch def
        pixs modemap i get {} forall cmv modebits i get 48 sub put
    } for

    <<
    /ren //renmatrix
    /pixs pixs
    /pixx size
    /pixy size
    /height size 2 mul 72 div
    /width size 2 mul 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/azteccode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER azteccode--

% --BEGIN ENCODER azteccodecompact--
% --REQUIRES preamble raiseerror renmatrix azteccode--
% --DESC: Compact Aztec Code
% --EXAM: 1234
% --EXOP:
% --RNDR: renmatrix
%%BeginResource: uk.co.terryburton.bwipp azteccodecompact 0.0 2015050900 60604 60376
%%BeginData:         43 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /azteccode dup /uk.co.terryburton.bwipp findresource put
begin
/azteccodecompact {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Get the result of encoding with azteccode with format=compact
    options (dontdraw) true put
    options (format) (compact) put

    /args barcode options //azteccode exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/azteccodecompact dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER azteccodecompact--

% --BEGIN ENCODER aztecrune--
% --REQUIRES preamble raiseerror renmatrix azteccode--
% --DESC: Aztec Runes
% --EXAM: 1
% --EXOP:
% --RNDR: renmatrix
%%BeginResource: uk.co.terryburton.bwipp aztecrune 0.0 2015050900 60573 60352
%%BeginData:         43 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /azteccode dup /uk.co.terryburton.bwipp findresource put
begin
/aztecrune {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Get the result of encoding with azteccode with format=rune
    options (dontdraw) true put
    options (format) (rune) put

    /args barcode options //azteccode exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/aztecrune dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER aztecrune--

% --BEGIN ENCODER codeone--
% --REQUIRES preamble raiseerror renmatrix--
% --DESC: Code One
% --EXAM: Code One
% --EXOP: version=B
% --RNDR: renmatrix
%%BeginResource: uk.co.terryburton.bwipp codeone 0.0 2015050900 119329 129149
%%BeginData:        512 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/codeone {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /version (unset) def
    /encoding (ascii) def
    /raw false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    raw {/encoding (raw) def} if

    /stype version 0 1 getinterval (S) eq def
    stype {/encoding (stype) def} if

    encoding (raw) eq {
        /cws barlen array def
        /i 0 def /j 0 def
        { % loop
            i barlen eq {exit} if
            /cw barcode i 1 add 3 getinterval cvi def
            cws j cw put
            /i i 4 add def
            /j j 1 add def
        } loop
        /cws cws 0 j getinterval def
    } if

    encoding (ascii) eq {
        /cws barlen 2 mul array def
        /i 0 def /j 0 def
        { % loop
            i barlen eq {exit} if
            /char barcode i get def
            char 48 ge char 57 le and i barlen 1 sub lt and {
                barcode i 1 add get dup 48 ge exch 57 le and {  % Digit pair
                    cws j barcode i 2 getinterval cvi 130 add put
                    /i i 2 add def
                    /j j 1 add def
                } {  % Singular digit
                    cws j char 1 add put
                    /i i 1 add def
                    /j j 1 add def
                } ifelse
            } { char 127 le {  % ASCII
                cws j char 1 add put
                /i i 1 add def
                /j j 1 add def
            } {  % Extended ASCII
                cws j 235 put
                cws j 1 add char 127 sub put
                /i i 1 add def
                /j j 2 add def
            } ifelse } ifelse
        } loop
        /cws cws 0 j getinterval def
    } if

    encoding (stype) eq {
        /vals [
            [   (0)   (1)  (10)   (11)  (100)
              (101) (110) (111) (1000) (1001)
            ]
            [      (0)   (1010)   (10100)   (11110)  (101000)
              (110010) (111100) (1000110) (1010000) (1011010)
            ]
            [ (0) (1100100)   (11001000)  (100101100)
                (110010000)  (111110100) (1001011000)
               (1010111100) (1100100000) (1110000100)
            ]
            [ (0) (1111101000)   (11111010000)   (101110111000)
                (111110100000) (1001110001000)  (1011101110000)
               (1101101011000) (1111101000000) (10001100101000)
            ]
            [ (0) (10011100010000)   (100111000100000)   (111010100110000)
                (1001110001000000)  (1100001101010000)  (1110101001100000)
               (10001000101110000) (10011100010000000) (10101111110010000)
            ]
            [ (0) (11000011010100000)   (110000110101000000)  (1001001001111100000)
                (1100001101010000000)  (1111010000100100000) (10010010011111000000)
               (10101010111001100000) (11000011010100000000) (11011011101110100000)
            ]
            [                        (0)     (11110100001001000000)
                 (111101000010010000000)   (1011011100011011000000)
                (1111010000100100000000)  (10011000100101101000000)
               (10110111000110110000000)  (11010101100111111000000)
               (11110100001001000000000) (100010010101010001000000)
            ]
            [                           (0)    (100110001001011010000000)
                (1001100010010110100000000)   (1110010011100001110000000)
               (10011000100101101000000000)  (10111110101111000010000000)
               (11100100111000011100000000) (100001011000001110110000000)
              (100110001001011010000000000) (101010111010100101010000000)
            ]
            [                              (0)    (101111101011110000100000000)
                (1011111010111100001000000000)  (10001111000011010001100000000)
               (10111110101111000010000000000)  (11101110011010110010100000000)
              (100011110000110100011000000000) (101001101110010010011100000000)
              (101111101011110000100000000000) (110101101001001110100100000000)
            ]
            [                                 (0)     (111011100110101100101000000000)
                (1110111001101011001010000000000)   (10110010110100000101111000000000)
               (11101110011010110010100000000000)  (100101010000001011111001000000000)
              (101100101101000001011110000000000)  (110100001001110111000011000000000)
              (111011100110101100101000000000000) (1000011000011100010001101000000000)
            ]
            [ (0) (1001010100000010111110010000000000)
                 (10010101000000101111100100000000000)
                 (11011111100001000111010110000000000)
                (100101010000001011111001000000000000)
                (101110100100001110110111010000000000)
                (110111111000010001110101100000000000)
               (1000001001100010100110011110000000000)
               (1001010100000010111110010000000000000)
               (1010011110100011010110000010000000000)
            ]
            [ (0) (1011101001000011101101110100000000000)
                 (10111010010000111011011101000000000000)
                (100010111011001011001001011100000000000)
                (101110100100001110110111010000000000000)
                (111010001101010010100101000100000000000)
               (1000101110110010110010010111000000000000)
               (1010001011111011010000000101100000000000)
               (1011101001000011101101110100000000000000)
               (1101000110001100001011100010100000000000)
            ]
            [ (0) (1110100011010100101001010001000000000000)
                 (11101000110101001010010100010000000000000)
                (101011101001111101111011110011000000000000)
                (111010001101010010100101000100000000000000)
               (1001000110000100111001110010101000000000000)
               (1010111010011111011110111100110000000000000)
               (1100101110111010000100000110111000000000000)
               (1110100011010100101001010001000000000000000)
              (10000010111101111001110011011001000000000000)
            ]
            [ (0) (10010001100001001110011100101010000000000000)
                 (100100011000010011100111001010100000000000000)
                 (110110100100011101011010101111110000000000000)
                (1001000110000100111001110010101000000000000000)
                (1011010111100110001000001111010010000000000000)
                (1101101001000111010110101011111100000000000000)
                (1111111010101000100101001000100110000000000000)
               (10010001100001001110011100101010000000000000000)
               (10100011101101011000010000001111010000000000000)
            ]
            [ (0) (10110101111001100010000011110100100000000000000)
                 (101101011110011000100000111101001000000000000000)
                (1000100001101100100110001011011101100000000000000)
                (1011010111100110001000001111010010000000000000000)
                (1110001101011111101010010011000110100000000000000)
               (10001000011011001001100010110111011000000000000000)
               (10011111001010010101110011010101111100000000000000)
               (10110101111001100010000011110100100000000000000000)
               (11001100101000101110010100010011000100000000000000)
            ]
            [ (0) (11100011010111111010100100110001101000000000000000)
                 (111000110101111110101001001100011010000000000000000)
                (1010101010000111101111101110010100111000000000000000)
                (1110001101011111101010010011000110100000000000000000)
               (10001110000110111100100110111111000001000000000000000)
               (10101010100001111011111011100101001110000000000000000)
               (11000110111100111011010000001011011011000000000000000)
               (11100011010111111010100100110001101000000000000000000)
               (11111111110010111001111001010111110101000000000000000)
            ]
            [ (0) (100011100001101111001001101111110000010000000000000000)
                 (1000111000011011110010011011111100000100000000000000000)
                 (1101010100101001101011101001111010000110000000000000000)
                (10001110000110111100100110111111000001000000000000000000)
                (10110001101000101011110000101110110001010000000000000000)
                (11010101001010011010111010011110100001100000000000000000)
                (11111000101100001010000100001110010001110000000000000000)
               (100011100001101111001001101111110000010000000000000000000)
               (100111111101111101000010111101101110010010000000000000000)
            ]
            [ (0) (101100011010001010111100001011101100010100000000000000000)
                 (1011000110100010101111000010111011000101000000000000000000)
                (10000101001110100000110100100011000100111100000000000000000)
                (10110001101000101011110000101110110001010000000000000000000)
                (11011110000010110110101100111010011101100100000000000000000)
               (100001010011101000001101001000110001001111000000000000000000)
               (100110110110111001100100101010001110110001100000000000000000)
               (101100011010001010111100001011101100010100000000000000000000)
               (110001111101011100010011101101001001110110100000000000000000)
            ]
        ] def

        /normalize {
            /base exch def
            /num exch def
            num length 1 sub -1 1 {
                /i exch def
                num i 1 sub 2 copy get num i get base idiv add put
                num i num i get base mod put
            } for
            { %loop - extend input as necessary
                num 0 get base lt {exit} if
                /num [0 num {} forall] def
                num 0 num 0 get num 1 get base idiv add put
                num 1 num 1 get base mod put
            } loop
            % Trim leading zeros
            /num [/i true def num {dup 0 eq i and {pop} {/i false def} ifelse} forall] def
            num length 0 eq {/num [0] def} if
            num
        } bind def

        /bigadd {
            2 copy length exch length
            2 copy sub abs /offset exch def
            lt {exch} if
            /a exch def /b exch def
            0 1 b length 1 sub {
                dup a exch offset add 2 copy get b 5 -1 roll get add put
            } for
            a
        } bind def

        % Convert value plus one to binary
        /v [ 1 ] def
        0 1 barlen 1 sub {
            /i exch def
            vals i get barcode barlen i sub 1 sub get 48 sub get
            [ exch {48 sub} forall ] v bigadd /v exch def
        } for
        /v v 2 normalize def

        % Split into 5-bit codewords
        /v [ 5 v length 5 mod sub 5 mod {0} repeat v aload pop ] def
        /cws v length 5 idiv array def
        0 1 cws length 1 sub {
            /i exch def
            v i 5 mul 5 getinterval
            0 exch {add 2 mul} forall 2 idiv
            cws exch i exch put
        } for

    } if

    % Basic metrics for the each symbol
    %     ver    row col dcol dcws rscw rsbl  ro ri rl
    /metrics [
        [ (A)     16  18   16   10   10    1   4 99  6 ]
        [ (B)     22  22   20   19   16    1   4 99  8 ]
        [ (C)     28  32   28   44   26    1   4 22 11 ]
        [ (D)     40  42   36   91   44    1   4 16 16 ]
        [ (E)     52  54   48  182   70    1   4 22 22 ]
        [ (F)     70  76   68  370  140    2   4 22 31 ]
        [ (G)    104  98   88  732  280    4   6 21 47 ]
        [ (H)    148 134  120 1480  560    8   6 20 69 ]
        [ (S-10)   8  11   10    4    4    1  99 99 99 ]
        [ (S-20)   8  21   20    8    8    1  99 99 99 ]
        [ (S-30)   8  31   30   12   12    1  99 99 99 ]
        [ (T-16)  16  17   16   10   10    1  99 99 99 ]
        [ (T-32)  16  33   32   24   16    1  99 99 99 ]
        [ (T-48)  16  49   48   38   22    1  99 99 99 ]
    ] def

    % Select metrics of an appropriate symbol
    /i 0 def
    { % loop
        /m metrics i get def
        /vers m 0 get def           % Version of symbol
        /rows m 1 get def           % Rows in symbol
        /cols m 2 get def           % Columns in symbol
        /dcol m 3 get def           % Data columns in symbol
        /dcws m 4 get def           % Data codewords in symbol
        /rscw m 5 get def           % Error correction codewords 
        /rsbl m 6 get def           % Error correction blocks
        /riso m 7 get def           % Riser offset
        /risi m 8 get def           % Riser interval
        /risl m 9 get def           % Riser length
        /dcpb dcws rsbl idiv def    % Data codewords per block
        /ecpb rscw rsbl idiv def    % Error codewords per block
        /okay true def
        version (unset) ne version vers ne and {/okay false def} if  % The version must match that supplied
        cws length dcws gt {/okay false def} if
        okay {exit} if
        /i i 1 add def
    } loop

    % Extend cws to ncws codewords by addition of pad characters
    stype not {
        /cws [ cws aload pop dcws cws length sub {129} repeat ] def
    } {
        /cws [ dcws cws length sub {0} repeat cws aload pop ] def
    } ifelse

    % De-interleave the codewords into blocks
    /cwbs rsbl array def  % Array of data codeword blocks
    /ecbs rsbl array def  % Array of error correction blocks
    0 1 rsbl 1 sub {
        /i exch def
        /cwb dcpb array def 
        0 1 dcpb 1 sub {
            /j exch def
            cwb j cws j rsbl mul i add get put
        } for 
        cwbs i cwb put
    } for

    % Log and anti-log tables and function to calculate product in the field
    /gf stype {32} {256} ifelse def
    /gf-1 gf 1 sub def
    /pm stype {37} {301} ifelse def
    /rsalog [ 1 gf-1 { dup 2 mul dup gf ge {pm xor} if } repeat ] def
    /rslog gf array def
    1 1 gf-1 {dup rsalog exch get exch rslog 3 1 roll put} for
    /rsprod {
        2 copy 0 ne exch 0 ne and { 
            rslog exch get exch rslog exch get add gf-1 mod rsalog exch get
        } {
            pop pop 0
        } ifelse
    } bind def

    % Generate the coefficients for the Reed-Solomon algorithm
    /coeffs [ 1 ecpb {0} repeat ] def
    0 1 ecpb 1 sub {
        /i exch def 
        coeffs i 1 add coeffs i get put
        i -1 1 {
            /j exch def
            coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod xor put
        } for 
        coeffs 0 coeffs 0 get rsalog i get rsprod put
    } for
    /coeffs coeffs 0 coeffs length 1 sub getinterval def

    % Reed-Solomon algorithm to derive the error correction codewords
    0 1 cwbs length 1 sub {
        /i exch def
        /rscws [ cwbs i get aload pop ecpb {0} repeat ] def
        0 1 dcpb 1 sub {
            /m exch def
            /k rscws m get def
            0 1 ecpb 1 sub {
                /j exch def
                rscws m j add 1 add coeffs ecpb j sub 1 sub get k rsprod rscws m j add 1 add get xor put
            } for
        } for
        ecbs i rscws dcpb ecpb getinterval put
    } for

    % Extend codewords with the interleaved error correction codes
    /cws [ cws aload pop rscw {0} repeat ] def
    0 1 rscw 1 sub {
        /i exch def
        cws dcws i add ecbs i rsbl mod get i rsbl idiv get put
    } for

    % Module matrix for layout of the codewords
    /mmat dcws rscw add stype {5} {8} ifelse mul array def
    /r 0 def /c 0 def
    0 stype {2} {1} ifelse cws length 1 sub {
        /i exch def
        stype not {
            (00000000) 8 string copy dup cws i get 2 8 string cvrs
            dup length 8 exch sub exch putinterval [ exch {48 sub} forall ]
            dup 0 4 getinterval /top exch def
            4 4 getinterval /bot exch def
        } {
            (00000) 5 string copy dup cws i get 2 5 string cvrs
            dup length 5 exch sub exch putinterval [ exch {48 sub} forall ]
            /c1 exch def
            (00000) 5 string copy dup cws i 1 add get 2 5 string cvrs
            dup length 5 exch sub exch putinterval [ exch {48 sub} forall ]
            /c2 exch def
            /top [ c1 0 3 getinterval aload pop c2 0 2 getinterval aload pop ] def
            /bot [ c1 3 2 getinterval aload pop c2 2 3 getinterval aload pop ] def
        } ifelse
        mmat r dcol mul c add top putinterval
        mmat r 1 add dcol mul c add bot putinterval
        /c c top length add def
        c dcol eq {/c 0 def /r r 2 add def} if
    } for

    % Create bitmap and add finder patterns
    /mmv {cols mul add} bind def
    /pixs [ rows cols mul {-1} repeat ] def

    % Centre pattern
    /artifact [
        {cols {0} repeat} bind 
        {cols {1} repeat} bind 
        {0   cols 2 sub {1} repeat   0} bind 
        {0 1 cols 4 sub {0} repeat 1 0} bind 
        {cols 1 sub 2 idiv {-1} repeat 1 cols 1 sub 2 idiv {-1} repeat} bind 
        {cols 1 sub 2 idiv {-1} repeat 0 cols 1 sub 2 idiv {-1} repeat} bind 
        {1   cols 2 sub {0} repeat   1} bind 
        {1 0 cols 4 sub {1} repeat 0 1} bind 
    ] def
    /cpat <<
        /A (121343)
        /B (12134343)
        /C (12121343)
        /D (1213434343)
        /E (1212134343)
        /F (1212121343)
        /G (121213434343)
        /H (121212134343)
        /S (56661278)
        /T (5666666666127878)
    >> vers 0 1 getinterval get def
    pixs 0 rows cpat length sub 2 idiv mmv 
    [ cpat {artifact exch 49 sub get exec} forall ] putinterval

    % Risers
    0 1 risl 1 sub {
        /i exch def
        riso risi cols 1 sub {
            /j exch def
            [ 1 i 12 mod 0 eq {1} {0} ifelse ] dup
            pixs j i mmv
            3 -1 roll putinterval
            i risl 1 sub ne {
                pixs cols j sub 2 sub rows i sub 1 sub mmv 
                3 -1 roll putinterval
            } {pop} ifelse
        } for
    } for

    % Black dots
    <<
        /A [ [12 5] ]
        /B [ [16 7] ]
        /C [ [26 12] ]
        /D []
        /E [ [26 23] ]
        /F [ [26 32] [70 32] [26 34] [70 34] ]
        /G [ [27 48] [69 48] ]
        /H [ [26 70] [66 70] [106 70] [26 72] [66 72] [106 72] ]
        /S-10 []
        /S-20 [ [10 4] ]
        /S-30 [ [15 4] [15 6] ]
        /T-16 [ [8 10] ]
        /T-32 [ [16 10] [16 12] ]
        /T-48 [ [24 10] [24 12] [24 14] ]
    >> vers get {pixs exch aload pop mmv 1 put} forall

    % Place the modules onto a pixel map between alignment patterns
    /j 0 def
    0 1 pixs length 1 sub {
        /i exch def
        pixs i get -1 eq {
            pixs i mmat j get put
            /j j 1 add def
        } if
    } for

    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx cols
    /pixy rows
    /height rows 72 div 2 mul
    /width cols 72 div 2 mul
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/codeone dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER codeone--

% --BEGIN ENCODER gs1-cc--
% --REQUIRES preamble raiseerror renmatrix micropdf417 pdf417--
% --DESC: GS1 Composite 2D Component
% --EXAM: (01)95012345678903(3103)000123
% --EXOP: ccversion=b cccolumns=4
% --RNDR: renmatrix
%%BeginResource: uk.co.terryburton.bwipp gs1-cc 0.0 2015050900 201765 192297
%%BeginData:        650 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /pdf417 dup /uk.co.terryburton.bwipp findresource put
dup /micropdf417 dup /uk.co.terryburton.bwipp findresource put
begin
/gs1-cc {
    
    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /ccversion (a) def
    /cccolumns -1 def
    /lintype () def
    /linwidth -1 def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /cccolumns cccolumns cvi def
    /linwidth linwidth cvi def

    % Select columns based on linear type
    cccolumns -1 eq {
        <<
            /ean13                  4
            /upca                   4
            /ean8                   3
            /upce                   2
            /gs1-128
                ccversion (c) ne {4} {linwidth 52 sub 17 idiv} ifelse
            /databaromni            4
            /databarstacked         2
            /databarstackedomni     2
            /databartruncated       4
            /databarlimited         3
            /databarexpanded        4
            /databarexpandedstacked 4
        >> lintype get /cccolumns exch def 
    } if

    % Expand ordinals of the form ^NNN to ASCII
    /expand {
        /in exch def
        /out in length string def
        /j 0 def
        in
        { % loop
            (^) search {
                dup out exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi out exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup out exch j exch putinterval
                length j add /j exch def
                out 0 j getinterval exit
            } ifelse 
        } loop
    } bind def
 
    % Parse out AIs
    /ais [] def
    /aival 2 dict def
    barcode dup length 1 sub 1 exch getinterval
    {  % loop
        dup () eq {exit} if
        (\)) search pop
        exch pop
        exch (\() search {
            exch pop exch 3 1 roll 
        } { 
            () 3 1 roll
        }  ifelse
        [ ais aload pop counttomark 2 add index ] /ais exch def
        aival 3 1 roll expand put
    } loop
    pop
    
    % Method selection
    /isupper {dup 65 ge exch 90 le and} bind def  % A-Z
    /isnum0  {dup 48 ge exch 57 le and} bind def  % 0-9
    /isnum1  {dup 49 ge exch 57 le and} bind def  % 1-9
    {  % common exit
    
        % (10/11/17)...
        ais length 1 ge {
            ais 0 get (10) eq ais 0 get (11) eq or ais 0 get (17) eq or {
                -1 (10) exit
            } if
        } if

        % (90){0-3 digits not starting 0}{upper alpha}...
        ais length 1 ge {
            ais 0 get (90) eq {
                /v aival (90) get def
                v length 1 ge {
                   v 0 get isupper {
                       0 (11) exit
                   } if
                } if
                v length 2 ge {
                   v 0 get isnum1
                   v 1 get isupper and {
                       1 (11) exit
                   } if
                } if
                v length 3 ge {
                    v 0 get isnum1
                    v 1 get isnum0 and
                    v 2 get isupper and {
                        2 (11) exit
                    } if
                } if
                v length 4 ge {
                    v 0 get isnum1
                    v 1 get isnum0 and
                    v 2 get isnum0 and
                    v 3 get isupper and {
                        3 (11) exit
                    } if
                } if
            } if
        } if

        % Freeform
        -1 (0) exit
    
    } loop
    /method exch def
    /npre exch def

    /fnc1 -1 def /lnumeric -2 def /lalphanumeric -3 def /liso646 -4 def

    /tobin {
        string dup length 1 sub 0 exch 1 exch {1 index exch 48 put} for
        dup 3 -1 roll 2 2 index length string cvrs dup length 2 index length exch sub exch putinterval 
    } bind def
 
    /alpha <<
        65 1 90 {dup 65 sub 5 tobin} for
        48 1 57 {dup 4 add 6 tobin} for
        fnc1 (11111)
    >> def

    /numeric <<
        0 1 119 {
            dup (00) 2 string copy dup 3 -1 roll 11 2 string cvrs
            dup length 2 exch sub exch putinterval 
            dup 0 get 65 eq {dup 0 94 put} if 
            dup 1 get 65 eq {dup 1 94 put} if 
            exch 8 add
            (0000000) 7 string copy dup 3 -1 roll 2 7 string cvrs 
            dup length 7 exch sub exch putinterval
        } for
        lalphanumeric (0000)
    >> def
 
    /alphanumeric <<
        48 1 57 {dup 43 sub 5 tobin} for
        fnc1 (01111)
        65 1 90 {dup 33 sub 6 tobin} for
        42 (111010)
        44 1 47 {dup 15 add 6 tobin} for
        lnumeric (000)
        liso646 (00100)
    >> def
    
    /iso646 <<
        48 1 57 {dup 43 sub 5 tobin} for
        fnc1 (01111)
        65 1 90 {dup 1 sub 7 tobin} for
        97 1 122 {dup 7 sub 7 tobin} for
        33 (11101000)
        34 (11101001)
        37 1 47 {dup 197 add 8 tobin} for
        58 1 63 {dup 187 add 8 tobin} for
        95 (11111011)
        32 (11111100)
        lnumeric (000)
        lalphanumeric (00100)
    >> def

    method (10) eq {  % TODO: fixme
        ais 0 get (11) eq ais 0 get (17) eq or {
            aival ais 0 get get
            dup 0 2 getinterval cvi 384 mul exch
            dup 2 2 getinterval cvi 1 sub 32 mul exch
            4 2 getinterval cvi add add 
            (0000000000000000) 16 string copy dup 3 -1 roll 2 16 string cvrs
            dup length 16 exch sub exch putinterval
            [ 1 0
              4 -1 roll {48 sub} forall
              ais 0 get (11) eq {0} {1} ifelse
            ] /cdf exch def
            /ais ais 1 ais length 1 sub getinterval def
        } {
            /cdf [ 1 0  1 1 ] def
        } ifelse
        ais length 0 ne {
            ais 0 get (10) eq {
                /gpf [ aival (10) get {} forall ] def
                ais length 1 gt {/gpf [ gpf aload pop fnc1 ] def} if  % TODO: check
                /ais ais 1 ais length 1 sub getinterval def
            } {
                /gpf [fnc1] def  % TODO: check
            } ifelse
        } {
            /cdf [ cdf aload pop 0 0 0 0 0 1 1 1 1 ] def
            /gpf [] def
        } ifelse
        /mode (numeric) def
    } if

    method (11) eq {
        /cdf [ 1 1 ] def
        /ai90 aival (90) get def
        npre 1 add ai90 length ne {
            ai90 npre 1 add ai90 length npre sub 1 sub getinterval
        } {
            ()
        } ifelse
        /ai90rem exch def
        /nalpha 0 ai90rem {dup 65 ge exch 90 le and {1 add} if} forall def
        /nnums  0 ai90rem {dup 48 ge exch 57 le and {1 add} if} forall def
        /mode nalpha nnums gt {(alpha)} {(numeric)} ifelse def
        nalpha nnums add ai90rem length ne {/mode (alphanumeric) def} if
        /cdf [
            cdf aload pop
            mode (alphanumeric) eq {0} if   
            mode (numeric) eq {1 0} if   
            mode (alpha) eq {1 1} if   
        ] def
        /ais1 ais length 1 gt {ais 1 get} {-1} ifelse def
        ais1 (21) eq ais1 (8004) eq or { 
            /cdf [ cdf aload pop ais1 (21) eq {1 0} {1 1} ifelse ] def
        } {
            /cdf [ cdf aload pop 0 ] def
        } ifelse
        /nval npre 0 ne {ai90 0 npre getinterval cvi} {0} ifelse def
        (BDHIJKLNPQRSTVXZ) ai90 npre 1 getinterval search {
            length exch pop exch pop
            /aval exch def
        } {
            pop /aval -1 def
        } ifelse 
        nval 31 lt aval -1 ne and {
            (00000) 5 string copy dup nval 2 5 string cvrs
            dup length 5 exch sub exch putinterval
            [ exch {48 sub} forall ] /nbits exch def
            (0000) 4 string copy dup aval 2 4 string cvrs
            dup length 4 exch sub exch putinterval
            [ exch {48 sub} forall ] /abits exch def
            /cdf [
                cdf aload pop 
                nbits aload pop
                abits aload pop
            ] def
        } {
            (0000000000) 10 string copy dup nval 2 10 string cvrs
            dup length 10 exch sub exch putinterval
            [ exch {48 sub} forall ] /nbits exch def
            (00000) 5 string copy dup ai90 npre get 65 sub 2 5 string cvrs
            dup length 5 exch sub exch putinterval
            [ exch {48 sub} forall ] /abits exch def
            /cdf [
                cdf aload pop
                1 1 1 1 1
                nbits aload pop
                abits aload pop
            ] def
        } ifelse
        mode (numeric) eq {
            /gpf [ ai90rem {} forall ais length 1 gt {fnc1} if ] def
        } {
            /encs mode (alpha) eq {alpha} {alphanumeric} ifelse def
            /in [ ai90rem {} forall ais length 1 gt {fnc1} if ] def
            /out in length 6 mul array def
            /j 0 def
            0 1 in length 1 sub {
                in exch get encs exch get 
                dup [ exch {48 sub} forall ] out exch j exch putinterval
                length j add /j exch def
            } for
            /cdf [
                cdf aload pop 
                out 0 j getinterval aload pop
            ] def
            /gpf [] def
            ais length 1 gt mode (alpha) ne or {/mode (numeric) def} if
        } ifelse
        /ais ais 1 ais length 1 sub getinterval def
        ais length 0 ne {
            ais1 (21) eq ais1 (8004) eq or {
                /gpf [
                    gpf aload pop
                    aival ais1 get {} forall
                ] def
                /ais ais 1 ais length 1 sub getinterval def
                ais length 0 ne {/gpf [gpf aload pop fnc1] def} if
            } if
        } if
    } if

    method (0) eq {
        /cdf [ 0 ] def
        /gpf [] def
        /mode (numeric) def
    } if

    % Pre-defined fixed length data field AIs
    % any AI whose prefix is not included in this table must be
    % terminated with "FNC1", even if it's fixed length
    /aifixed 23 dict def
    [
        0 1 4 {} for
    ] {
        (00) 2 string copy dup dup 1 5 -1 roll 48 add put aifixed 3 1 roll put
    } forall
    [
        11 1 20 {} for
        23
        31 1 36 {} for
        41
    ] {
        10 2 string cvrs dup aifixed 3 1 roll put
    } forall

    % Append the remaining AI data
    0 1 ais length 1 sub {
        /i exch def
        /ai ais i get def
        /val aival ai get def
        gpf length ai length add val length add array
        dup 0 gpf putinterval
        dup gpf length ai [ exch {} forall ] putinterval
        dup gpf length ai length add val [ exch {} forall ] putinterval
        /gpf exch def
        i ais length 1 sub ne aifixed ai 0 2 getinterval known not and {  % Append FNC1
            gpf length 1 add array
            dup 0 gpf putinterval
            dup gpf length fnc1 put
            /gpf exch def
        } if
    } for

    % Calculate the number of bits remaining to the next valid symbol size
    /rembits {
        /used exch def
        ccversion (c) ne {  % cc-a or cc-b
            <<
            /a [
                [167 138 118 108 88 78 59]
                [167 138 118  98 78]
                [197 167 138 108 78]
            ]
            /b [
                [ 336  296 256 208 160 104  56]
                [ 768  648 536 416 304 208 152 112  72 32]
                [1184 1016 840 672 496 352 264 208 152 96 56]
            ]
            >> ccversion get cccolumns 2 sub get /bitcaps exch def
            -1 bitcaps {dup used ge {exch} if pop} forall
            dup -1 ne {used sub} if
        } {
            << /c -1 >> ccversion get pop  % Assert cc-c
            /m used 8 div ceiling cvi dup 6 idiv 5 mul exch 6 mod add def
            m   40 le               {8 } if
            m   41 ge m  160 le and {16} if
            m  161 ge m  320 le and {32} if
            m  321 ge               {64} if
            /eccws exch def
            /m m eccws add 3 add def
            /c linwidth 52 sub 17 idiv def
            m c idiv 90 gt {/c c 1 add def} if
            /r m c div ceiling cvi def
            /tgt c r mul eccws sub 3 sub dup 5 idiv 6 mul exch 5 mod add 8 mul def
            used 8296 le {tgt used sub} {-1} ifelse
        } ifelse
        dup -1 eq {  % Upgrade CC-A to CC-B or CC-B to CC-C to fit
            pop
            ccversion (a) eq {
                /ccversion (b) def
            } {
                ccversion (b) eq lintype (gs1-128) eq and {
                    /ccversion (c) def
                    /cccolumns linwidth 52 sub 17 idiv def
                } {
                    /ccversion -1 def
                } ifelse
            } ifelse 
            used rembits
        } if
    } bind def

    /encode {
        dup /raw ne {exch get} {pop} ifelse
        [ exch {48 sub} forall ]
        dup length exch
        gpfenc exch j exch putinterval
        /j exch j add def
    } bind def

    % Pre-compute alphanumeric and numeric runlengths and position of next ISO646-only characters
    /numericruns [ gpf length {0} repeat 0 -1 ] def
    /alphanumericruns [ gpf length {0} repeat 0 ] def
    /nextiso646only [ gpf length {0} repeat 9999 ] def
    gpf length 1 sub -1 0 {
        /i exch def
        gpf i get
        (00) 2 string copy
        dup 0 gpf i get dup fnc1 eq {pop 94} if put 
        i gpf length 1 sub lt {dup 1 gpf i 1 add get dup fnc1 eq {pop 94} if put} if
        numeric exch known {
            numericruns i numericruns i 2 add get 2 add put
        } {
            numericruns i 0 put
        } ifelse
        dup alphanumeric exch known {
            alphanumericruns i alphanumericruns i 1 add get 1 add put
        } {
            alphanumericruns i 0 put
        } ifelse
        dup iso646 exch known exch alphanumeric exch known not and {
            nextiso646only i 0 put
        } {
            nextiso646only i nextiso646only i 1 add get 1 add put
        } ifelse
    } for
   
    % Encode the general purpose field
    /gpfenc 8296 array def
    /i 0 def /j 0 def
    {  % loop
        i gpf length eq {exit} if
        {  % not a loop but common exit point
    
            mode (numeric) eq {
                i gpf length 2 sub le {
                    2 string 
                    dup 0 gpf i get dup fnc1 eq {pop 94} if put
                    dup 1 gpf i 1 add get dup fnc1 eq {pop 94} if put
                    dup numeric exch known {
                        numeric encode
                        /i i 2 add def
                        exit
                    } if
                    pop
                    lalphanumeric numeric encode 
                    /mode (alphanumeric) def
                    exit
                } {
                    gpf i get dup 48 lt exch 57 gt or {
                        lalphanumeric numeric encode
                        /mode (alphanumeric) def
                        exit
                    } if
                    /rem cdf length j add rembits def
                    rem 4 ge rem 6 le and {  % C1 + 1 into 4 to 6 bits
                        (000000) 6 string copy 0 rem getinterval
                        dup gpf i get 47 sub 2 4 string cvrs
                        dup length 4 exch sub exch putinterval /raw encode
                        /i i 1 add def
                        exit
                    } {  % C1.FNC1
                        2 string dup 0 gpf i get put dup 1 94 put numeric encode 
                        /i i 1 add def
                        exit
                    } ifelse
                } ifelse
            } if
    
            mode (alphanumeric) eq {
                gpf i get fnc1 eq {
                    fnc1 alphanumeric encode
                    /mode (numeric) def
                    /i i 1 add def
                    exit
                } if
                gpf i get dup iso646 exch known exch alphanumeric exch known not and {
                     liso646 alphanumeric encode
                     /mode (iso646) def
                     exit
                } if
                numericruns i get 6 ge {
                    lnumeric alphanumeric encode
                    /mode (numeric) def
                    exit
                } if
                numericruns i get dup 4 ge exch i add gpf length eq and {
                    lnumeric alphanumeric encode
                    /mode (numeric) def
                    exit
                } if
                gpf i get alphanumeric encode
                /i i 1 add def
                exit
            } if
    
            mode (iso646) eq {
                gpf i get fnc1 eq {
                    fnc1 iso646 encode
                    /mode (numeric) def
                    /i i 1 add def
                    exit
                } if
                numericruns i get 4 ge nextiso646only i get 10 ge and {
                    lnumeric iso646 encode
                    /mode (numeric) def
                    exit
                } if
                alphanumericruns i get 5 ge nextiso646only i get 10 ge and {
                    lalphanumeric iso646 encode
                    /mode (alphanumeric) def
                    exit
                } if
                gpf i get iso646 encode
                /i i 1 add def
                exit
            } if
    
        } loop
    } loop
    /gpf gpfenc 0 j getinterval def

    % Create pad
    /pad cdf length gpf length add rembits array def
    pad length 0 gt {
        0 5 pad length 1 sub {  % Fill with 00100
            /i exch def
            pad i [ 0 0 1 0 0 ] 0 pad length i sub 5 2 copy gt {exch} if pop getinterval putinterval 
        } for 
        mode (numeric) eq {  % Prefix shift from numeric to ASCII
            /pad [ 0 0 0 0 pad aload pop ] 0 pad length getinterval def
        } if
        mode (alpha) eq {  % Prefix FNC1
            /pad [ 1 1 1 1 1 pad aload pop ] 0 pad length getinterval def
        } if
    } if

    % Concatinate fields
    /bits [
        cdf aload pop
        gpf aload pop
        pad aload pop
    ] def

    ccversion (a) eq {
        /pwr928 [
            [ 0 0 0 0 0 0 1 ]
            68 {7 array} repeat
        ] def
        1 1 68 {
            /j exch def
            /v 0 def
            6 -1 1 {
                /i exch def
                /v pwr928 j 1 sub get i get 2 mul v 928 idiv add def
                pwr928 j get i v 928 mod put 
            } for   
            pwr928 j get 0 pwr928 j 1 sub get 0 get 2 mul v 928 idiv add put
        } for
        /cws [ 28 {0} repeat ] def
        /b 0 def /c 0 def
        {  % loop
            b bits length eq {exit} if
            /bs bits b 69 bits length b sub 2 copy gt {exch} if pop getinterval def
            /bsl bs length def
            /cs cws c bsl 10 idiv 1 add getinterval def
            /csl cs length def
            0 1 bsl 1 sub {
                /i exch def
                0 1 csl 1 sub {
                    /j exch def
                    cs j 2 copy get
                    pwr928 i get j 7 add csl sub get
                    bs bsl i sub 1 sub get
                    mul add put
                } for
            } for
            csl 1 sub -1 1 {
                /i exch def
                cs i 1 sub 2 copy get cs i get 928 idiv add put
                cs i 2 copy get 928 mod put
            } for 
            /b b bsl add def
            /c c csl add def
        } loop
        /cws cws 0 c getinterval def
        /barcode cws length 4 mul string def
        0 1 cws length 1 sub {
            /i exch def
            (^   ) 4 string copy dup cws i get 10 4 string cvrs
            dup length 4 exch sub exch putinterval
            barcode i 4 mul 3 -1 roll putinterval
        } for
        options (dontdraw) true put
        options (cca) true put
        options (columns) cccolumns put
        /args barcode options //micropdf417 exec def
    } if

    ccversion (b) eq {
        /barcode bits length 8 idiv string def
        0 1 barcode length 1 sub {
            /i exch def
            bits i 8 mul 8 getinterval 0 exch {add 2 mul} forall 2 idiv
            barcode exch i exch put
        } for
        options (dontdraw) true put
        options (ccb) true put
        options (columns) cccolumns put
        /args barcode options //micropdf417 exec def
    } if

    ccversion (c) eq {
        /barcode bits length 8 idiv string def
        0 1 barcode length 1 sub {
            /i exch def
            bits i 8 mul 8 getinterval 0 exch {add 2 mul} forall 2 idiv
            barcode exch i exch put
        } for
        options (dontdraw) true put
        options (ccc) true put
        options (columns) cccolumns put
        /args barcode options //pdf417 exec def
    } if

    args
    dontdraw not //renmatrix if

    end

} bind def
/gs1-cc dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER gs1-cc--

% --BEGIN ENCODER ean13composite--
% --REQUIRES preamble raiseerror renlinear renmatrix ean5 ean2 ean13 micropdf417 pdf417 gs1-cc--
% --DESC: EAN-13 Composite
% --EXAM: 2112345678900|(99)1234-abcd
% --EXOP: includetext
% --RNDR: renlinear renmatrix
%%BeginResource: uk.co.terryburton.bwipp ean13composite 0.0 2015050900 84039 84015
%%BeginData:         72 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /ean13 dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/ean13composite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (ean13) put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //ean13 exec //renlinear exec

    % Plot the separator
    -1 72 rmoveto <<
        /ren //renmatrix
        /pixs [
            0 1  93 {0} repeat  1 0
            1 0  93 {0} repeat  0 1
            0 1  93 {0} repeat  1 0
        ]
        /pixx 97
        /pixy 3
        /height 6 72 div
        /width 97 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    -2 6 rmoveto comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/ean13composite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER ean13composite--

% --BEGIN ENCODER ean8composite--
% --REQUIRES preamble raiseerror renlinear renmatrix ean5 ean2 ean8 micropdf417 pdf417 gs1-cc--
% --DESC: EAN-8 Composite
% --EXAM: 02345673|(21)A12345678
% --EXOP: includetext
% --RNDR: renlinear renmatrix
%%BeginResource: uk.co.terryburton.bwipp ean8composite 0.0 2015050900 84340 84317
%%BeginData:         75 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /ean8 dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/ean8composite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    % Get the result of encoding with ean8 and gs1-cc
    options (lintype) (ean8) put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //ean8 exec //renlinear exec

    % Plot the separator
    -1 72 rmoveto <<
        /ren //renmatrix
        /pixs [
            0 1  65 {0} repeat  1 0
            1 0  65 {0} repeat  0 1
            0 1  65 {0} repeat  1 0
        ]
        /pixx 69
        /pixy 3
        /height 6 72 div
        /width 69 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    comp options //gs1-cc exec
    dup (pixx) get 69 exch sub 6 rmoveto
    //renmatrix exec

    grestore

    end

} bind def
/ean8composite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER ean8composite--

% --BEGIN ENCODER upcacomposite--
% --REQUIRES preamble raiseerror renlinear renmatrix ean5 ean2 upca micropdf417 pdf417 gs1-cc--
% --DESC: UPC-A Composite
% --EXAM: 416000336108|(99)1234-abcd
% --EXOP: includetext
% --RNDR: renlinear renmatrix
%%BeginResource: uk.co.terryburton.bwipp upcacomposite 0.0 2015050900 84017 84082
%%BeginData:         72 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /upca dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/upcacomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (ean13) put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //upca exec //renlinear exec

    % Plot the separator
    -1 72 rmoveto <<
        /ren //renmatrix
        /pixs [
            0 1  93 {0} repeat  1 0
            1 0  93 {0} repeat  0 1
            0 1  93 {0} repeat  1 0
        ]
        /pixx 97
        /pixy 3
        /height 6 72 div
        /width 97 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    -2 6 rmoveto comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/upcacomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER upcacomposite--

% --BEGIN ENCODER upcecomposite--
% --REQUIRES preamble raiseerror renlinear renmatrix ean5 ean2 upce micropdf417 pdf417 gs1-cc--
% --DESC: UPC-E Composite
% --EXAM: 00123457|(15)021231
% --EXOP: includetext
% --RNDR: renlinear renmatrix
%%BeginResource: uk.co.terryburton.bwipp upcecomposite 0.0 2015050900 88475 84857
%%BeginData:         87 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /upce dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/upcecomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    % Define the separator
    /sep <<
        /ren //renmatrix
        /pixs [
            0 1  49 {0} repeat  1 0
            1 0  49 {0} repeat  0 1
            0 1  49 {0} repeat  1 0
        ] 
        /pixx 53
        /pixy 3
        /height 6 72 div
        /width 53 72 div
        /opt options
    >> def

    gsave

    options (lintype) (upce) put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //upce exec //renlinear exec

    % Plot the separator
    -1 72 rmoveto <<
        /ren //renmatrix
        /pixs [
            0 1  49 {0} repeat  1 0
            1 0  49 {0} repeat  0 1
            0 1  49 {0} repeat  1 0
        ]
        /pixx 53
        /pixy 3
        /height 6 72 div
        /width 53 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    -2 6 rmoveto comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/upcecomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER upcecomposite--

% --BEGIN ENCODER databaromnicomposite--
% --REQUIRES preamble raiseerror renlinear renmatrix databaromni micropdf417 pdf417 gs1-cc--
% --DESC: GS1 DataBar Omnidirectional Composite
% --EXAM: (01)03612345678904|(11)990102
% --EXOP:
% --RNDR: renlinear renmatrix
%%BeginResource: uk.co.terryburton.bwipp databaromnicomposite 0.0 2015050900 83884 87420
%%BeginData:        100 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /databaromni dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databaromnicomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (databaromni) put
    options (linkage) true put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //databaromni exec
    dup (sbs) get /linsbs exch def
    dup (bhs) get 0 get 72 mul /linheight exch def
    //renlinear exec

    % Plot the separator
    /sepfinder {
        /fp exch def
        fp 1 fp 12 add {
            /i exch def
            bot i get 0 eq {
                bot i 1 sub get 1 eq {
                    1
                } {
                    sep i 1 sub get 0 eq {1} {0} ifelse
                } ifelse
            } {
                0
            } ifelse
            sep exch i exch put
        } for
        /f3 [1 1 1 1 1 1 1 1 1 0 1 1 1] def
        true 0 1 12 {dup bot exch fp add get exch f3 exch get eq and} for {
            % Right shifted module for value 3 finder
            sep fp [ 0 0 0 0 0 0 0 0 0 0 1 0 0 ] putinterval
        } if
    } bind def
    mark
    0 linsbs {1 index 1 eq {{0}} {{1}} ifelse repeat} forall
    counttomark 1 sub array astore /bot exch def pop pop
    /sep [ bot {1 exch sub} forall ] def
    sep 0 [0 0 0] putinterval
    sep sep length 4 sub [0 0 0 0] putinterval
    18 sepfinder 64 sepfinder
    0 linheight rmoveto <<
        /ren //renmatrix
        /pixs sep
        /pixx sep length
        /pixy 1
        /height 1 72 div
        /width sep length 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    -5 1 rmoveto comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/databaromnicomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER databaromnicomposite--

% --BEGIN ENCODER databarstackedcomposite--
% --REQUIRES preamble raiseerror renlinear renmatrix databaromni databarstacked micropdf417 pdf417 gs1-cc--
% --DESC: GS1 DataBar Stacked Composite
% --EXAM: (01)03412345678900|(17)010200
% --EXOP:
% --RNDR: renlinear renmatrix
%%BeginResource: uk.co.terryburton.bwipp databarstackedcomposite 0.0 2015050900 89818 86093
%%BeginData:         96 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /databarstacked dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databarstackedcomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (databarstacked) put
    options (linkage) true put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //databarstacked exec
    dup (pixs) get 0 2 index (pixx) get getinterval /bot exch def
    dup (pixy) get /linheight exch def
    //renmatrix exec

    % Plot the separator
    /sepfinder {
        /fp exch def
        fp 1 fp 12 add {
            /i exch def
            bot i get 0 eq {
                bot i 1 sub get 1 eq {
                    1
                } {
                    sep i 1 sub get 0 eq {1} {0} ifelse
                } ifelse
            } {
                0
            } ifelse
            sep exch i exch put
        } for
        /f3 [1 1 1 1 1 1 1 1 1 0 1 1 1] def
        true 0 1 12 {dup bot exch fp add get exch f3 exch get eq and} for {
            % Right shifted module for value 3 finder
            sep fp [ 0 0 0 0 0 0 0 0 0 0 1 0 0 ] putinterval
        } if
    } bind def
    /sep [ bot {1 exch sub} forall ] def
    sep 0 [ 0 0 0 0 ] putinterval
    sep sep length 4 sub [ 0 0 0 0 ] putinterval
    18 sepfinder
    0 linheight rmoveto <<
        /ren //renmatrix
        /pixs sep
        /pixx sep length
        /pixy 1
        /height 1 72 div
        /width sep length 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    1 1 rmoveto comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/databarstackedcomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER databarstackedcomposite--

% --BEGIN ENCODER databarstackedomnicomposite--
% --REQUIRES preamble raiseerror renlinear renmatrix databaromni databarstackedomni micropdf417 pdf417 gs1-cc--
% --DESC: GS1 DataBar Stacked Omnidirectional Composite
% --EXAM: (01)03612345678904|(11)990102
% --EXOP:
% --RNDR: renlinear renmatrix
%%BeginResource: uk.co.terryburton.bwipp databarstackedomnicomposite 0.0 2015050900 89894 86165
%%BeginData:         96 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /databarstackedomni dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databarstackedomnicomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (databarstackedomni) put
    options (linkage) true put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //databarstackedomni exec
    dup (pixs) get 0 2 index (pixx) get getinterval /bot exch def
    dup (pixy) get /linheight exch def
    //renmatrix exec

    % Plot the separator
    /sepfinder {
        /fp exch def
        fp 1 fp 12 add {
            /i exch def
            bot i get 0 eq {
                bot i 1 sub get 1 eq {
                    1
                } {
                    sep i 1 sub get 0 eq {1} {0} ifelse
                } ifelse
            } {
                0
            } ifelse
            sep exch i exch put
        } for
        /f3 [1 1 1 1 1 1 1 1 1 0 1 1 1] def
        true 0 1 12 {dup bot exch fp add get exch f3 exch get eq and} for {
            % Right shifted module for value 3 finder
            sep fp [ 0 0 0 0 0 0 0 0 0 0 1 0 0 ] putinterval
        } if
    } bind def
    /sep [ bot {1 exch sub} forall ] def
    sep 0 [ 0 0 0 ] putinterval
    sep sep length 4 sub [ 0 0 0 0 ] putinterval
    18 sepfinder
    0 linheight rmoveto <<
        /ren //renmatrix
        /pixs sep
        /pixx sep length
        /pixy 1
        /height 1 72 div
        /width sep length 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    1 1 rmoveto comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/databarstackedomnicomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER databarstackedomnicomposite--

% --BEGIN ENCODER databartruncatedcomposite--
% --REQUIRES preamble raiseerror renlinear renmatrix databaromni databartruncated micropdf417 pdf417 gs1-cc--
% --DESC: GS1 DataBar Truncated Composite
% --EXAM: (01)03612345678904|(11)990102
% --EXOP:
% --RNDR: renlinear renmatrix
%%BeginResource: uk.co.terryburton.bwipp databartruncatedcomposite 0.0 2015050900 90784 87051
%%BeginData:        100 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /databartruncated dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databartruncatedcomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (databartruncated) put
    options (linkage) true put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //databartruncated exec
    dup (sbs) get /linsbs exch def
    dup (bhs) get 0 get 72 mul /linheight exch def
    //renlinear exec

    % Plot the separator
    /sepfinder {
        /fp exch def
        fp 1 fp 12 add {
            /i exch def
            bot i get 0 eq {
                bot i 1 sub get 1 eq {
                    1
                } {
                    sep i 1 sub get 0 eq {1} {0} ifelse
                } ifelse
            } {
                0
            } ifelse
            sep exch i exch put
        } for
        /f3 [1 1 1 1 1 1 1 1 1 0 1 1 1] def
        true 0 1 12 {dup bot exch fp add get exch f3 exch get eq and} for {
            % Right shifted module for value 3 finder
            sep fp [ 0 0 0 0 0 0 0 0 0 0 1 0 0 ] putinterval
        } if
    } bind def
    mark
    0 linsbs {1 index 1 eq {{0}} {{1}} ifelse repeat} forall
    counttomark 1 sub array astore /bot exch def pop pop
    /sep [ bot {1 exch sub} forall ] def
    sep 0 [0 0 0] putinterval
    sep sep length 4 sub [0 0 0 0] putinterval
    18 sepfinder 64 sepfinder
    0 linheight rmoveto <<
        /ren //renmatrix
        /pixs sep
        /pixx sep length
        /pixy 1
        /height 1 72 div
        /width sep length 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    -5 1 rmoveto comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/databartruncatedcomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER databartruncatedcomposite--

% --BEGIN ENCODER databarlimitedcomposite--
% --REQUIRES preamble raiseerror renlinear renmatrix databarlimited micropdf417 pdf417 gs1-cc--
% --DESC: GS1 DataBar Limited Composite
% --EXAM: (01)03512345678907|(21)abcdefghijklmnopqrstuv
% --EXOP:
% --RNDR: renlinear renmatrix
%%BeginResource: uk.co.terryburton.bwipp databarlimitedcomposite 0.0 2015050900 80661 80522
%%BeginData:         79 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /databarlimited dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databarlimitedcomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (databarlimited) put
    options (linkage) true put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //databarlimited exec
    dup (sbs) get /linsbs exch def
    dup (bhs) get 0 get 72 mul /linheight exch def
    //renlinear exec

    % Plot the separator
    mark
    1 linsbs {1 index 0 eq {{1}} {{0}} ifelse repeat} forall
    counttomark 1 sub array astore /sep exch def pop pop
    sep 0 [0 0 0] putinterval
    sep sep length 4 sub [0 0 0 0] putinterval
    0 linheight rmoveto <<
        /ren //renmatrix
        /pixs sep
        /pixx sep length
        /pixy 1
        /height 1 72 div
        /width sep length 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    comp options //gs1-cc exec 
    dup (pixx) get 72 exch sub 1 rmoveto 
    //renmatrix exec

    grestore

    end

} bind def
/databarlimitedcomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER databarlimitedcomposite--

% --BEGIN ENCODER databarexpandedcomposite--
% --REQUIRES preamble raiseerror renlinear renmatrix databarexpanded micropdf417 pdf417 gs1-cc--
% --DESC: GS1 DataBar Expanded Composite
% --EXAM: (01)93712345678904(3103)001234|(91)1A2B3C4D5E
% --EXOP:
% --RNDR: renlinear renmatrix
%%BeginResource: uk.co.terryburton.bwipp databarexpandedcomposite 0.0 2015050900 86979 83324
%%BeginData:         98 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /databarexpanded dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databarexpandedcomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (databarexpanded) put
    options (linkage) true put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //databarexpanded exec
    dup (sbs) get /linsbs exch def
    dup (bhs) get 0 get 72 mul /linheight exch def
    //renlinear exec

    % Plot the separator
    /sepfinder {
        /fp exch def
        fp 1 fp 12 add {
            /i exch def
            bot i get 0 eq {
                bot i 1 sub get 1 eq {
                    1
                } {
                    sep i 1 sub get 0 eq {1} {0} ifelse
                } ifelse
            } {
                0
            } ifelse
            sep exch i exch put
        } for
    } bind def
    mark
    0 linsbs {1 index 1 eq {{0}} {{1}} ifelse repeat} forall
    counttomark 1 sub array astore /bot exch def pop pop
    /sep [ bot {1 exch sub} forall ] def
    sep 0 [0 0 0] putinterval
    sep sep length 4 sub [0 0 0 0] putinterval
    [  % Finder pattern module positions
        18 98 bot length 13 sub {} for
        69 98 bot length 13 sub {} for
    ] {sepfinder} forall 
    0 linheight rmoveto <<
        /ren //renmatrix
        /pixs sep
        /pixx sep length
        /pixy 1
        /height 1 72 div
        /width sep length 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    1 1 rmoveto comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/databarexpandedcomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER databarexpandedcomposite--

% --BEGIN ENCODER databarexpandedstackedcomposite--
% --REQUIRES preamble raiseerror renlinear renmatrix databarexpanded databarexpandedstacked micropdf417 pdf417 gs1-cc--
% --DESC: GS1 DataBar Expanded Stacked Composite
% --EXAM: (01)00012345678905(10)ABCDEF|(21)12345678
% --EXOP: segments=4 
% --RNDR: renmatrix renlinear
%%BeginResource: uk.co.terryburton.bwipp databarexpandedstackedcomposite 0.0 2015050900 89645 89413
%%BeginData:         95 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /databarexpandedstacked dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databarexpandedstackedcomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (databarexpandedstacked) put
    options (linkage) true put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //databarexpandedstacked exec
    dup (pixs) get 0 2 index (pixx) get getinterval /bot exch def
    dup (pixy) get /linheight exch def
    //renmatrix exec

    % Plot the separator
    /sepfinder {
        /fp exch def
        fp 1 fp 12 add {
            /i exch def
            bot i get 0 eq {
                bot i 1 sub get 1 eq {
                    1
                } {
                    sep i 1 sub get 0 eq {1} {0} ifelse
                } ifelse
            } {
                0
            } ifelse
            sep exch i exch put
        } for
    } bind def
    /sep [ bot {1 exch sub} forall ] def
    sep 0 [ 0 0 0 ] putinterval
    sep sep length 4 sub [ 0 0 0 0 ] putinterval
    [  % Finder pattern module positions
        19 98 bot length 13 sub {} for
        70 98 bot length 13 sub {} for
    ] {sepfinder} forall 
    0 linheight rmoveto <<
        /ren //renmatrix
        /pixs sep
        /pixx sep length
        /pixy 1
        /height 1 72 div
        /width sep length 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    bot 0 get 0 eq {2} {0} ifelse 1 rmoveto
    comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/databarexpandedstackedcomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER databarexpandedstackedcomposite--

% --BEGIN ENCODER gs1-128composite--
% --REQUIRES preamble raiseerror renlinear renmatrix code128 gs1-128 micropdf417 pdf417 gs1-cc--
% --DESC: GS1-128 Composite
% --EXAM: (00)030123456789012340|(02)13012345678909(37)24(10)1234567ABCDEFG
% --EXOP: ccversion=c
% --RNDR: renlinear renmatrix
%%BeginResource: uk.co.terryburton.bwipp gs1-128composite 0.0 2015050900 86884 89985
%%BeginData:        100 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /gs1-128 dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/gs1-128composite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (inkspread) (0) put
    options (dontdraw) true put

    % Dummy plot of linear part with CC-A to get width
    options (linkagea) true put
    linear << options {} forall >> //gs1-128 exec
    (sbs) get 0 exch {add} forall /linwidth exch def

    % Create 2D part and determine type
    options (lintype) (gs1-128) put
    options (linwidth) linwidth put
    comp options //gs1-cc exec /compsym exch def
    compsym (pixx) get 99 eq {(a)} {(c)} ifelse /linktype exch def 

    % Plot linear part
    linktype (a) eq {
        options (linkagea) true put
        options (linkagec) false put
    } {
        options (linkagea) false put
        options (linkagec) true put
    } ifelse
    linear << options {} forall >> //gs1-128 exec
    dup (sbs) get /linsbs exch def
    dup (bhs) get 0 get 72 mul /linheight exch def
    //renlinear exec

    % Plot the separator
    mark
    1 linsbs {1 index 0 eq {{1}} {{0}} ifelse repeat} forall
    counttomark 1 sub array astore /sep exch def pop pop
    0 linheight rmoveto <<
        /ren //renmatrix
        /pixs sep
        /pixx sep length
        /pixy 1
        /height 1 72 div
        /width sep length 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    linktype (a) eq {
        /s linwidth 2 sub 11 idiv def
        /p s 9 sub 2 idiv def
        /x s p sub 1 sub 11 mul 10 add p 0 eq {2 add} if 99 sub def
        x 1 rmoveto
    } {
        -7 1 rmoveto 
    } ifelse

    compsym //renmatrix exec

    grestore

    end

} bind def
/gs1-128composite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER gs1-128composite--

% --BEGIN ENCODER gs1datamatrix--
% --REQUIRES preamble raiseerror renmatrix datamatrix--
% --DESC: GS1 Data Matrix
% --EXAM: (01)03453120000011(17)120508(10)ABCD1234(410)9501101020917
% --EXOP:
% --RNDR: renmatrix
%%BeginResource: uk.co.terryburton.bwipp gs1datamatrix 0.0 2015050900 78248 77990
%%BeginData:        134 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /datamatrix dup /uk.co.terryburton.bwipp findresource put
begin
/gs1datamatrix {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Expand ordinals of the form ^NNN to ASCII
    /expand {
        /in exch def
        /out in length string def
        /j 0 def
        in
        { % loop
            (^) search {
                dup out exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi out exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup out exch j exch putinterval
                length j add /j exch def
                out 0 j getinterval exit
            } ifelse 
        } loop
    } bind def
    
    % Parse out AIs
    /ais [] def
    /aival 2 dict def
    barcode dup length 1 sub 1 exch getinterval
    {  % loop
        dup () eq {exit} if
        (\)) search pop
        exch pop
        exch (\() search {
            exch pop exch 3 1 roll 
        } { 
            () 3 1 roll
        } ifelse
        [ ais aload pop counttomark 2 add index ] /ais exch def
        aival 3 1 roll expand put
    } loop
    pop

    % Pre-defined fixed length data field AIs
    % any AI whose prefix is not included in this table must be
    % terminated with "FNC1", even if it's fixed length
    /aifixed 23 dict def
    [
        0 1 4 {} for
    ] {
        (00) 2 string copy dup dup 1 5 -1 roll 48 add put aifixed 3 1 roll put
    } forall
    [
        11 1 20 {} for
        23
        31 1 36 {} for
        41
    ] {
        10 2 string cvrs dup aifixed 3 1 roll put
    } forall

    % Create the datamatrix data 
    /fnc1 -1 def
    /dmtx [ fnc1 ] def
    0 1 ais length 1 sub {
        /i exch def
        /ai ais i get def
        /val aival ai get def
        dmtx length ai length add val length add array
        dup 0 dmtx putinterval
        dup dmtx length ai [ exch {} forall ] putinterval
        dup dmtx length ai length add val [ exch {} forall ] putinterval
        /dmtx exch def
        i ais length 1 sub ne aifixed ai 0 2 getinterval known not and {  % Append FNC1
            dmtx length 1 add array
            dup 0 dmtx putinterval
            dup dmtx length fnc1 put
            /dmtx exch def
        } if
    } for

    % Compose input to datamatrix
    /barcode dmtx length 1 add 5 mul string def
    /i 0 def /j 0 def {
        i dmtx length eq {exit} if
        dmtx i get dup fnc1 eq {
            pop barcode j (^FNC1) putinterval
            /j j 4 add def
        } {
            barcode exch j exch put
        } ifelse
        /i i 1 add def
        /j j 1 add def
    } loop
    /barcode barcode 0 j getinterval def

    % Get the result of encoding with code128
    options (dontdraw) true put
    options (parsefnc) true put
    /args barcode options //datamatrix exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if
 
    end

} bind def
/gs1datamatrix dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER gs1datamatrix--

% --BEGIN ENCODER gs1qrcode--
% --REQUIRES preamble raiseerror renmatrix qrcode--
% --DESC: GS1 QR Code
% --EXAM: (01)03453120000011(8200)http://www.abc.net(10)ABCD1234(410)9501101020917
% --EXOP:
% --RNDR: renmatrix
%%BeginResource: uk.co.terryburton.bwipp gs1qrcode 0.0 2015050900 78280 77938
%%BeginData:        133 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /qrcode dup /uk.co.terryburton.bwipp findresource put
begin
/gs1qrcode {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Expand ordinals of the form ^NNN to ASCII
    /expand {
        /in exch def
        /out in length string def
        /j 0 def
        in
        { % loop
            (^) search {
                dup out exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi out exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup out exch j exch putinterval
                length j add /j exch def
                out 0 j getinterval exit
            } ifelse 
        } loop
    } bind def
    
    % Parse out AIs
    /ais [] def
    /aival 2 dict def
    barcode dup length 1 sub 1 exch getinterval
    {  % loop
        dup () eq {exit} if
        (\)) search pop
        exch pop
        exch (\() search {
            exch pop exch 3 1 roll 
        } { 
            () 3 1 roll
        } ifelse
        [ ais aload pop counttomark 2 add index ] /ais exch def
        aival 3 1 roll expand put
    } loop
    pop

    % Pre-defined fixed length data field AIs
    % any AI whose prefix is not included in this table must be
    % terminated with "FNC1", even if it's fixed length
    /aifixed 23 dict def
    [
        0 1 4 {} for
    ] {
        (00) 2 string copy dup dup 1 5 -1 roll 48 add put aifixed 3 1 roll put
    } forall
    [
        11 1 20 {} for
        23
        31 1 36 {} for
        41
    ] {
        10 2 string cvrs dup aifixed 3 1 roll put
    } forall

    % Create the qrcode data 
    /fnc1 -1 def
    /qrc [ fnc1 ] def
    0 1 ais length 1 sub {
        /i exch def
        /ai ais i get def
        /val aival ai get def
        qrc length ai length add val length add array
        dup 0 qrc putinterval
        dup qrc length ai [ exch {} forall ] putinterval
        dup qrc length ai length add val [ exch {} forall ] putinterval
        /qrc exch def
        i ais length 1 sub ne aifixed ai 0 2 getinterval known not and {  % Append FNC1
            qrc length 1 add array
            dup 0 qrc putinterval
            dup qrc length fnc1 put
            /qrc exch def
        } if
    } for

    % Compose input to qrcode
    /barcode qrc length 1 add 5 mul string def
    /i 0 def /j 0 def {
        i qrc length eq {exit} if
        qrc i get dup fnc1 eq {
            pop barcode j (^FNC1) putinterval
            /j j 4 add def
        } {
            barcode exch j exch put
        } ifelse
        /i i 1 add def
        /j j 1 add def
    } loop
    /barcode barcode 0 j getinterval def

    % Get the result of encoding with qrcode
    options (dontdraw) true put
    options (parsefnc) true put
    /args barcode options //qrcode exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if
 
    end

} bind def
/gs1qrcode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER gs1qrcode--

% --BEGIN ENCODER hibccode39--
% --REQUIRES preamble raiseerror renlinear code39--
% --DESC: HIBC Code 39
% --EXAM: A123BJC5D6E71
% --EXOP: includetext
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp hibccode39 0.0 2015050900 63169 62924
%%BeginData:         92 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code39 dup /uk.co.terryburton.bwipp findresource put
begin
/hibccode39 {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /textxoffset 0 def
    /validatecheck false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /textxoffset textxoffset cvr def

    % Create a string of the available characters
    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def
    /charvals 43 dict def
    0 1 42 {charvals exch dup barchars exch 1 getinterval exch put} for

    % Validate the input
    0 1 barcode length 1 sub {
        barcode exch 1 getinterval charvals exch known not {
            /bwipp.hibccode39badCharacter (HIBC Code 39 must contain only digits, capital letters, spaces and the symbols -.$/+%) //raiseerror exec
        } if
    } for

    /barlen barcode length validatecheck {1 sub} if def

    /checksum 41 def
    0 1 barlen 1 sub {
        barcode exch 1 getinterval charvals exch get
        checksum add /checksum exch def
    } for
    /checksum checksum 43 mod def
    validatecheck {
        barcode barlen get barchars checksum get ne {
            /bwipp.hibccode39badCheckDigit (Incorrect HIBC Code 39 check digit provided) //raiseerror exec
        } if
        /barcode barcode 0 barlen getinterval def
    } if

    /barcode barlen 2 add string dup 1 barcode putinterval def
    barcode 0 43 put
    barcode barlen 1 add barchars checksum get put

    /text barlen 4 add string def
    text 0 42 put
    text 1 barcode putinterval
    text barlen 2 add barcode barlen 1 add get dup 32 eq {pop 95} if put
    text barlen 3 add 42 put

    % Get the result of encoding with code39
    options (dontdraw) true put
    options (includecheck) false put
    options (validatecheck) false put
    /args barcode options //code39 exec def

    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args
 
    dontdraw not //renlinear if

    end

} bind def
/hibccode39 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER hibccode39--

% --BEGIN ENCODER hibccode128--
% --REQUIRES preamble raiseerror renlinear code128--
% --DESC: HIBC Code 128
% --EXAM: A123BJC5D6E71
% --EXOP: includetext
% --RNDR: renlinear
%%BeginResource: uk.co.terryburton.bwipp hibccode128 0.0 2015050900 67220 66909
%%BeginData:         91 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code128 dup /uk.co.terryburton.bwipp findresource put
begin
/hibccode128 {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /textxoffset 0 def
    /validatecheck false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /textxoffset textxoffset cvr def

    % Create a string of the available characters
    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def
    /charvals 43 dict def
    0 1 42 {charvals exch dup barchars exch 1 getinterval exch put} for

    % Validate the input
    0 1 barcode length 1 sub {
        barcode exch 1 getinterval charvals exch known not {
            /bwipp.hibccode128badCharacter (HIBC Code 128 must contain only digits, capital letters, spaces and the symbols -.$/+%) //raiseerror exec
        } if
    } for

    /barlen barcode length validatecheck {1 sub} if def

    /checksum 41 def
    0 1 barlen 1 sub {
        barcode exch 1 getinterval charvals exch get
        checksum add /checksum exch def
    } for
    /checksum checksum 43 mod def
    validatecheck {
        barcode barlen get barchars checksum get ne {
            /bwipp.hibccode128badCheckDigit (Incorrect HIBC Code 128 check digit provided) //raiseerror exec
        } if
        /barcode barcode 0 barlen getinterval def
    } if

    /barcode barlen 2 add string dup 1 barcode putinterval def
    barcode 0 43 put
    barcode barlen 1 add barchars checksum get put

    /text barlen 4 add string def
    text 0 42 put
    text 1 barcode putinterval
    text barlen 2 add barcode barlen 1 add get dup 32 eq {pop 95} if put
    text barlen 3 add 42 put

    % Get the result of encoding with code128
    options (dontdraw) true put
    options (validatecheck) false put
    /args barcode options //code128 exec def

    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args
 
    dontdraw not //renlinear if

    end

} bind def
/hibccode128 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER hibccode128--

% --BEGIN ENCODER hibcdatamatrix--
% --REQUIRES preamble raiseerror renmatrix datamatrix--
% --DESC: HIBC Data Matrix
% --EXAM: A123BJC5D6E71
% --EXOP:
% --RNDR: renmatrix
%%BeginResource: uk.co.terryburton.bwipp hibcdatamatrix 0.0 2015050900 68711 64879
%%BeginData:         74 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /datamatrix dup /uk.co.terryburton.bwipp findresource put
begin
/hibcdatamatrix {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /validatecheck false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Create a string of the available characters
    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def
    /charvals 43 dict def
    0 1 42 {charvals exch dup barchars exch 1 getinterval exch put} for

    % Validate the input
    0 1 barcode length 1 sub {
        barcode exch 1 getinterval charvals exch known not {
            /bwipp.hibcdatamatrixBadCharacter (HIBC Data Matrix must contain only digits, capital letters, spaces and the symbols -.$/+%) //raiseerror exec
        } if
    } for

    /barlen barcode length validatecheck {1 sub} if def

    /checksum 41 def
    0 1 barlen 1 sub {
        barcode exch 1 getinterval charvals exch get
        checksum add /checksum exch def
    } for
    /checksum checksum 43 mod def
    validatecheck {
        barcode barlen get barchars checksum get ne {
            /bwipp.hibcdatamatrixBadCheckDigit (Incorrect HIBC Data Matrix check digit provided) //raiseerror exec
        } if
        /barcode barcode 0 barlen getinterval def
    } if

    /barcode barlen 2 add string dup 1 barcode putinterval def
    barcode 0 43 put
    barcode barlen 1 add barchars checksum get put

    % Get the result of encoding with datamatrix
    options (dontdraw) true put
    options (validatecheck) false put
    /args barcode options //datamatrix exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/hibcdatamatrix dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER hibcdatamatrix--

% --BEGIN ENCODER hibcpdf417--
% --REQUIRES preamble raiseerror renmatrix pdf417--
% --DESC: HIBC PDF417
% --EXAM: A123BJC5D6E71
% --EXOP:
% --RNDR: renmatrix
%%BeginResource: uk.co.terryburton.bwipp hibcpdf417 0.0 2015050900 65468 65072
%%BeginData:         78 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /pdf417 dup /uk.co.terryburton.bwipp findresource put
begin
/hibcpdf417 {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /columns 2 def
    /validatecheck false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /columns columns cvi def

    % Create a string of the available characters
    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def
    /charvals 43 dict def
    0 1 42 {charvals exch dup barchars exch 1 getinterval exch put} for

    % Validate the input
    0 1 barcode length 1 sub {
        barcode exch 1 getinterval charvals exch known not {
            /bwipp.hibcpdf417BadCharacter (HIBC PDF417 must contain only digits, capital letters, spaces and the symbols -.$/+%) //raiseerror exec
        } if
    } for

    /barlen barcode length validatecheck {1 sub} if def

    /checksum 41 def
    0 1 barlen 1 sub {
        barcode exch 1 getinterval charvals exch get
        checksum add /checksum exch def
    } for
    /checksum checksum 43 mod def
    validatecheck {
        barcode barlen get barchars checksum get ne {
            /bwipp.hibcpdf417BadCheckDigit (Incorrect HIBC PDF417 check digit provided) //raiseerror exec
        } if
        /barcode barcode 0 barlen getinterval def
    } if

    /barcode barlen 2 add string dup 1 barcode putinterval def
    barcode 0 43 put
    barcode barlen 1 add barchars checksum get put

    % Get the result of encoding with pdf417
    options (dontdraw) true put
    options (columns) columns put
    options (validatecheck) false put
    /args barcode options //pdf417 exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/hibcpdf417 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER hibcpdf417--

% --BEGIN ENCODER hibcmicropdf417--
% --REQUIRES preamble raiseerror renmatrix micropdf417--
% --DESC: HIBC MicroPDF417
% --EXAM: A123BJC5D6E71
% --EXOP:
% --RNDR: renmatrix
%%BeginResource: uk.co.terryburton.bwipp hibcmicropdf417 0.0 2015050900 65606 65195
%%BeginData:         78 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /micropdf417 dup /uk.co.terryburton.bwipp findresource put
begin
/hibcmicropdf417 {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /columns 2 def
    /validatecheck false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /columns columns cvi def

    % Create a string of the available characters
    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def
    /charvals 43 dict def
    0 1 42 {charvals exch dup barchars exch 1 getinterval exch put} for

    % Validate the input
    0 1 barcode length 1 sub {
        barcode exch 1 getinterval charvals exch known not {
            /bwipp.hibcmicropdf417BadCharacter (HIBC MicroPDF417 must contain only digits, capital letters, spaces and the symbols -.$/+%) //raiseerror exec
        } if
    } for

    /barlen barcode length validatecheck {1 sub} if def

    /checksum 41 def
    0 1 barlen 1 sub {
        barcode exch 1 getinterval charvals exch get
        checksum add /checksum exch def
    } for
    /checksum checksum 43 mod def
    validatecheck {
        barcode barlen get barchars checksum get ne {
            /bwipp.hibcmicropdf417BadCheckDigit (Incorrect HIBC MicroPDF417 check digit provided) //raiseerror exec
        } if
        /barcode barcode 0 barlen getinterval def
    } if

    /barcode barlen 2 add string dup 1 barcode putinterval def
    barcode 0 43 put
    barcode barlen 1 add barchars checksum get put

    % Get the result of encoding with micropdf417
    options (dontdraw) true put
    options (columns) columns put
    options (validatecheck) false put
    /args barcode options //micropdf417 exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/hibcmicropdf417 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER hibcmicropdf417--

% --BEGIN ENCODER hibcqrcode--
% --REQUIRES preamble raiseerror renmatrix qrcode--
% --DESC: HIBC QR Code
% --EXAM: A123BJC5D6E71
% --EXOP:
% --RNDR: renmatrix
%%BeginResource: uk.co.terryburton.bwipp hibcqrcode 0.0 2015050900 64983 68179
%%BeginData:         74 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /qrcode dup /uk.co.terryburton.bwipp findresource put
begin
/hibcqrcode {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /validatecheck false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Create a string of the available characters
    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def
    /charvals 43 dict def
    0 1 42 {charvals exch dup barchars exch 1 getinterval exch put} for

    % Validate the input
    0 1 barcode length 1 sub {
        barcode exch 1 getinterval charvals exch known not {
            /bwipp.hibcqrcodeBadCharacter (HIBC QR Code must contain only digits, capital letters, spaces and the symbols -.$/+%) //raiseerror exec
        } if
    } for

    /barlen barcode length validatecheck {1 sub} if def

    /checksum 41 def
    0 1 barlen 1 sub {
        barcode exch 1 getinterval charvals exch get
        checksum add /checksum exch def
    } for
    /checksum checksum 43 mod def
    validatecheck {
        barcode barlen get barchars checksum get ne {
            /bwipp.hibcqrcodeBadCheckDigit (Incorrect HIBC QR Code check digit provided) //raiseerror exec
        } if
        /barcode barcode 0 barlen getinterval def
    } if

    /barcode barlen 2 add string dup 1 barcode putinterval def
    barcode 0 43 put
    barcode barlen 1 add barchars checksum get put

    % Get the result of encoding with qrcode
    options (dontdraw) true put
    options (validatecheck) false put
    /args barcode options //qrcode exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/hibcqrcode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER hibcqrcode--

% --BEGIN ENCODER hibccodablockf--
% --REQUIRES preamble raiseerror renmatrix codablockf--
% --DESC: HIBC Codablock F
% --EXAM: A123BJC5D6E71
% --EXOP:
% --RNDR: renmatrix
%%BeginResource: uk.co.terryburton.bwipp hibccodablockf 0.0 2015050900 60823 64313
%%BeginData:         74 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /codablockf dup /uk.co.terryburton.bwipp findresource put
begin
/hibccodablockf {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /validatecheck false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Create a string of the available characters
    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def
    /charvals 43 dict def
    0 1 42 {charvals exch dup barchars exch 1 getinterval exch put} for

    % Validate the input
    0 1 barcode length 1 sub {
        barcode exch 1 getinterval charvals exch known not {
            /bwipp.codablockfBadCharacter (HIBC Codablock F must contain only digits, capital letters, spaces and the symbols -.$/+%) //raiseerror exec
        } if
    } for

    /barlen barcode length validatecheck {1 sub} if def

    /checksum 41 def
    0 1 barlen 1 sub {
        barcode exch 1 getinterval charvals exch get
        checksum add /checksum exch def
    } for
    /checksum checksum 43 mod def
    validatecheck {
        barcode barlen get barchars checksum get ne {
            /bwipp.hibccodablockfBadCheckDigit (Incorrect HIBC Codablock F check digit provided) //raiseerror exec
        } if
        /barcode barcode 0 barlen getinterval def
    } if

    /barcode barlen 2 add string dup 1 barcode putinterval def
    barcode 0 43 put
    barcode barlen 1 add barchars checksum get put

    % Get the result of encoding with codablockf
    options (dontdraw) true put
    options (validatecheck) false put
    /args barcode options //codablockf exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/hibccodablockf dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END ENCODER hibccodablockf--

% --END TEMPLATE--

%%EndProcSet
%%BeginProcSet: lm-ec.enc 0 0
% This file belongs to the Latin Modern package. The work is released
% under the GUST Font License. See the MANIFEST-Latin-Modern.txt and
% README-Latin-Modern.txt files for the details. For the most recent version of
% this license see http://www.gust.org.pl/fonts/licenses/GUST-FONT-LICENSE.txt
% or http://tug.org/fonts/licenses/GUST-FONT-LICENSE.txt

/enclmec[
/grave
/acute
/circumflex
/tilde
/dieresis
/hungarumlaut
/ring
/caron
/breve
/macron
/dotaccent
/cedilla
/ogonek
/quotesinglbase
/guilsinglleft
/guilsinglright
/quotedblleft
/quotedblright
/quotedblbase
/guillemotleft
/guillemotright
/endash
/emdash
/cwm
/perthousandzero
/dotlessi
/dotlessj
/ff
/fi
/fl
/ffi
/ffl
/uni2423
/exclam
/quotedbl
/numbersign
/dollar
/percent
/ampersand
/quoteright
/parenleft
/parenright
/asterisk
/plus
/comma
/hyphen
/period
/slash
/zero
/one
/two
/three
/four
/five
/six
/seven
/eight
/nine
/colon
/semicolon
/less
/equal
/greater
/question
/at
/A
/B
/C
/D
/E
/F
/G
/H
/I
/J
/K
/L
/M
/N
/O
/P
/Q
/R
/S
/T
/U
/V
/W
/X
/Y
/Z
/bracketleft
/backslash
/bracketright
/asciicircum
/underscore
/quoteleft
/a
/b
/c
/d
/e
/f
/g
/h
/i
/j
/k
/l
/m
/n
/o
/p
/q
/r
/s
/t
/u
/v
/w
/x
/y
/z
/braceleft
/bar
/braceright
/asciitilde
/hyphen.alt
/Abreve
/Aogonek
/Cacute
/Ccaron
/Dcaron
/Ecaron
/Eogonek
/Gbreve
/Lacute
/Lcaron
/Lslash
/Nacute
/Ncaron
/Eng
/Ohungarumlaut
/Racute
/Rcaron
/Sacute
/Scaron
/Scedilla
/Tcaron
/Tcedilla
/Uhungarumlaut
/Uring
/Ydieresis
/Zacute
/Zcaron
/Zdotaccent
/IJ
/Idotaccent
/dcroat
/section
/abreve
/aogonek
/cacute
/ccaron
/dcaron
/ecaron
/eogonek
/gbreve
/lacute
/lcaron
/lslash
/nacute
/ncaron
/eng
/ohungarumlaut
/racute
/rcaron
/sacute
/scaron
/scedilla
/tcaron
/tcedilla
/uhungarumlaut
/uring
/ydieresis
/zacute
/zcaron
/zdotaccent
/ij
/exclamdown
/questiondown
/sterling
/Agrave
/Aacute
/Acircumflex
/Atilde
/Adieresis
/Aring
/AE
/Ccedilla
/Egrave
/Eacute
/Ecircumflex
/Edieresis
/Igrave
/Iacute
/Icircumflex
/Idieresis
/Eth
/Ntilde
/Ograve
/Oacute
/Ocircumflex
/Otilde
/Odieresis
/OE
/Oslash
/Ugrave
/Uacute
/Ucircumflex
/Udieresis
/Yacute
/Thorn
/Germandbls
/agrave
/aacute
/acircumflex
/atilde
/adieresis
/aring
/ae
/ccedilla
/egrave
/eacute
/ecircumflex
/edieresis
/igrave
/iacute
/icircumflex
/idieresis
/eth
/ntilde
/ograve
/oacute
/ocircumflex
/otilde
/odieresis
/oe
/oslash
/ugrave
/uacute
/ucircumflex
/udieresis
/yacute
/thorn
/germandbls
] def

%%EndProcSet
%%BeginProcSet: lm-ts1.enc 0 0
% This file belongs to the Latin Modern package. The work is released
% under the GUST Font License. See the MANIFEST-Latin-Modern.txt and
% README-Latin-Modern.txt files for the details. For the most recent version of
% this license see http://www.gust.org.pl/fonts/licenses/GUST-FONT-LICENSE.txt
% or http://tug.org/fonts/licenses/GUST-FONT-LICENSE.txt

/enclmts1[
/grave
/acute
/circumflex
/tilde
/dieresis
/hungarumlaut
/ring
/caron
/breve
/macron
/dotaccent
/cedilla
/ogonek
/quotesinglbase.ts1
/.notdef
/.notdef
/.notdef
/.notdef
/quotedblbase.ts1
/.notdef
/.notdef
/twelveudash
/threequartersemdash
/cwmcapital
/arrowleft
/arrowright
/tieaccentlowercase
/tieaccentcapital
/tieaccentlowercase.new
/tieaccentcapital.new
/.notdef
/cwmascender
/blanksymbol
/.notdef
/.notdef
/.notdef
/dollar
/.notdef
/.notdef
/quotesingle.ts1
/.notdef
/.notdef
/asteriskmath
/.notdef
/comma
/hyphendbl
/period
/fraction
/zero.taboldstyle
/one.taboldstyle
/two.taboldstyle
/three.taboldstyle
/four.taboldstyle
/five.taboldstyle
/six.taboldstyle
/seven.taboldstyle
/eight.taboldstyle
/nine.taboldstyle
/.notdef
/.notdef
/angleleft
/minus
/angleright
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/mho
/.notdef
/bigcircle
/.notdef
/Orogate
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/ohm
/.notdef
/.notdef
/.notdef
/dblbracketleft
/.notdef
/dblbracketright
/arrowup
/arrowdown
/grave.ts1
/.notdef
/born
/divorced
/died
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/leaf
/married
/musicalnote
/.notdef
/.notdef
/orogate
/.notdef
/longs
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/tildelow
/hyphendbl.alt
/breve.ts1
/caron.ts1
/hungarumlaut.ts1
/dblgrave.ts1
/dagger
/daggerdbl
/dblverticalbar
/perthousand
/bullet
/centigrade
/dollar.oldstyle
/cent.oldstyle
/florin
/colonmonetary
/won
/naira
/guarani
/peso
/lira
/recipe
/interrobang
/gnaborretni
/dong
/trademark
/permyriad
/paragraph.alt
/baht
/numero
/discount
/estimated
/openbullet
/servicemark
/quillbracketleft
/quillbracketright
/cent
/sterling
/currency
/yen
/brokenbar
/section
/dieresis.ts1
/copyright
/ordfeminine
/copyleft
/logicalnot
/published
/registered
/macron.ts1
/degree
/plusminus
/two.superior
/three.superior
/acute.ts1
/mu
/paragraph
/periodcentered
/referencemark
/one.superior
/ordmasculine
/radical
/onequarter
/onehalf
/threequarters
/Euro
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/multiply
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/divide
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
] def

%%EndProcSet
%%BeginProcSet: texps.pro 0 0
%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]FontType 0
ne{/Metrics exch def dict begin Encoding{exch dup type/integertype ne{
pop pop 1 sub dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get
div def}ifelse}forall Metrics/Metrics currentdict end def}{{1 index type
/nametype eq{exit}if exch pop}loop}ifelse[2 index currentdict end
definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{dup
sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1 roll
mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def dup[
exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}if}
forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}def
end

%%EndProcSet
%%BeginProcSet: special.pro 0 0
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/@beginspecial{SDict begin/SpecialSave save N gsave
normalscale currentpoint TR @SpecialDefaults count/ocount X/dcount
countdictstack N}N/@setspecial{CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto
0 vs rlineto hs neg 0 rlineto closepath clip}if ho vo TR hsc vsc scale
ang rotate rwiSeen{rwi urx llx sub div rhiSeen{rhi ury lly sub div}{dup}
ifelse scale llx neg lly neg TR}{rhiSeen{rhi ury lly sub div dup scale
llx neg lly neg TR}if}ifelse CLIP 2 eq{newpath llx lly moveto urx lly
lineto urx ury lineto llx ury lineto closepath clip}if/showpage{}N
/erasepage{}N/setpagedevice{pop}N/copypage{}N newpath}N/@endspecial{
count ocount sub{pop}repeat countdictstack dcount sub{end}repeat
grestore SpecialSave restore end}N/@defspecial{SDict begin}N
/@fedspecial{end}B/li{lineto}B/rl{rlineto}B/rc{rcurveto}B/np{/SaveX
currentpoint/SaveY X N 1 setlinecap newpath}N/st{stroke SaveX SaveY
moveto}N/fil{fill SaveX SaveY moveto}N/ellipse{/endangle X/startangle X
/yrad X/xrad X/savematrix matrix currentmatrix N TR xrad yrad scale 0 0
1 startangle endangle arc savematrix setmatrix}N end

%%EndProcSet
%%BeginProcSet: color.pro 0 0
%!
TeXDict begin/setcmykcolor where{pop}{/setcmykcolor{dup 10 eq{pop
setrgbcolor}{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll
}repeat setrgbcolor pop}ifelse}B}ifelse/TeXcolorcmyk{setcmykcolor}def
/TeXcolorrgb{setrgbcolor}def/TeXcolorgrey{setgray}def/TeXcolorgray{
setgray}def/TeXcolorhsb{sethsbcolor}def/currentcmykcolor where{pop}{
/currentcmykcolor{currentrgbcolor 10}B}ifelse/DC{exch dup userdict exch
known{pop pop}{X}ifelse}B/GreenYellow{0.15 0 0.69 0 setcmykcolor}DC
/Yellow{0 0 1 0 setcmykcolor}DC/Goldenrod{0 0.10 0.84 0 setcmykcolor}DC
/Dandelion{0 0.29 0.84 0 setcmykcolor}DC/Apricot{0 0.32 0.52 0
setcmykcolor}DC/Peach{0 0.50 0.70 0 setcmykcolor}DC/Melon{0 0.46 0.50 0
setcmykcolor}DC/YellowOrange{0 0.42 1 0 setcmykcolor}DC/Orange{0 0.61
0.87 0 setcmykcolor}DC/BurntOrange{0 0.51 1 0 setcmykcolor}DC
/Bittersweet{0 0.75 1 0.24 setcmykcolor}DC/RedOrange{0 0.77 0.87 0
setcmykcolor}DC/Mahogany{0 0.85 0.87 0.35 setcmykcolor}DC/Maroon{0 0.87
0.68 0.32 setcmykcolor}DC/BrickRed{0 0.89 0.94 0.28 setcmykcolor}DC/Red{
0 1 1 0 setcmykcolor}DC/OrangeRed{0 1 0.50 0 setcmykcolor}DC/RubineRed{
0 1 0.13 0 setcmykcolor}DC/WildStrawberry{0 0.96 0.39 0 setcmykcolor}DC
/Salmon{0 0.53 0.38 0 setcmykcolor}DC/CarnationPink{0 0.63 0 0
setcmykcolor}DC/Magenta{0 1 0 0 setcmykcolor}DC/VioletRed{0 0.81 0 0
setcmykcolor}DC/Rhodamine{0 0.82 0 0 setcmykcolor}DC/Mulberry{0.34 0.90
0 0.02 setcmykcolor}DC/RedViolet{0.07 0.90 0 0.34 setcmykcolor}DC
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}DC/Lavender{0 0.48 0 0
setcmykcolor}DC/Thistle{0.12 0.59 0 0 setcmykcolor}DC/Orchid{0.32 0.64 0
0 setcmykcolor}DC/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}DC/Purple{
0.45 0.86 0 0 setcmykcolor}DC/Plum{0.50 1 0 0 setcmykcolor}DC/Violet{
0.79 0.88 0 0 setcmykcolor}DC/RoyalPurple{0.75 0.90 0 0 setcmykcolor}DC
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}DC/Periwinkle{0.57 0.55 0 0
setcmykcolor}DC/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}DC
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}DC/MidnightBlue{0.98 0.13 0
0.43 setcmykcolor}DC/NavyBlue{0.94 0.54 0 0 setcmykcolor}DC/RoyalBlue{1
0.50 0 0 setcmykcolor}DC/Blue{1 1 0 0 setcmykcolor}DC/Cerulean{0.94 0.11
0 0 setcmykcolor}DC/Cyan{1 0 0 0 setcmykcolor}DC/ProcessBlue{0.96 0 0 0
setcmykcolor}DC/SkyBlue{0.62 0 0.12 0 setcmykcolor}DC/Turquoise{0.85 0
0.20 0 setcmykcolor}DC/TealBlue{0.86 0 0.34 0.02 setcmykcolor}DC
/Aquamarine{0.82 0 0.30 0 setcmykcolor}DC/BlueGreen{0.85 0 0.33 0
setcmykcolor}DC/Emerald{1 0 0.50 0 setcmykcolor}DC/JungleGreen{0.99 0
0.52 0 setcmykcolor}DC/SeaGreen{0.69 0 0.50 0 setcmykcolor}DC/Green{1 0
1 0 setcmykcolor}DC/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}DC
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}DC/LimeGreen{0.50 0 1 0
setcmykcolor}DC/YellowGreen{0.44 0 0.74 0 setcmykcolor}DC/SpringGreen{
0.26 0 0.76 0 setcmykcolor}DC/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}
DC/RawSienna{0 0.72 1 0.45 setcmykcolor}DC/Sepia{0 0.83 1 0.70
setcmykcolor}DC/Brown{0 0.81 1 0.60 setcmykcolor}DC/Tan{0.14 0.42 0.56 0
setcmykcolor}DC/Gray{0 0 0 0.50 setcmykcolor}DC/Black{0 0 0 1
setcmykcolor}DC/White{0 0 0 0 setcmykcolor}DC end

%%EndProcSet
TeXDict begin @defspecial

 systemdict /pdfmark known{userdict /?pdfmark systemdict /exec get
put}{userdict /?pdfmark systemdict /pop get put userdict /pdfmark systemdict
/cleartomark get put}ifelse

 /DvipsToPDF{72.27 mul Resolution div} def/PDFToDvips{72.27 div Resolution
mul} def/BPToDvips{72 div Resolution mul}def/BorderArrayPatch{[exch{dup
dup type/integertype eq exch type/realtype eq or{BPToDvips}if}forall]}def/HyperBorder
{1 PDFToDvips} def/H.V {pdf@hoff pdf@voff null} def/H.B {/Rect[pdf@llx
pdf@lly pdf@urx pdf@ury]} def/H.S {currentpoint HyperBorder add /pdf@lly
exch def dup DvipsToPDF 72 add /pdf@hoff exch def HyperBorder sub /pdf@llx
exch def} def/H.L {2 sub dup/HyperBasePt exch def PDFToDvips /HyperBaseDvips
exch def currentpoint HyperBaseDvips sub /pdf@ury exch def/pdf@urx
exch def} def/H.A {H.L currentpoint exch pop vsize 72 sub exch DvipsToPDF
HyperBasePt sub sub /pdf@voff exch def} def/H.R {currentpoint HyperBorder
sub /pdf@ury exch def HyperBorder add /pdf@urx exch def currentpoint
exch pop vsize 72 sub exch DvipsToPDF sub /pdf@voff exch def} def
 
@fedspecial end
%%BeginFont: LMRoman10-Regular
%!PS-AdobeFont-1.0: LMRoman10-Regular 2.004
%%CreationDate: 7th October 2009
% Generated by MetaType1 (a MetaPost-based engine)
% Copyright 2003--2009 by B. Jackowski and J.M. Nowacki (on behalf of TeX USERS GROUPS).
% Supported by CSTUG, DANTE eV, GUST, GUTenberg, NTG, and TUG.
% METATYPE1/Type 1 version by B. Jackowski & J. M. Nowacki
% from GUST (http://www.gust.org.pl).
% This work is released under the GUST Font License.
% For the most recent version of this license see
% This work has the LPPL maintenance status `maintained'.
% The Current Maintainer of this work is Bogus\l{}aw Jackowski and Janusz M. Nowacki.
% This work consists of the files listed in the MANIFEST-Latin-Modern.txt file.
% ADL: 806 194 0
%%EndComments
FontDirectory/LMRoman10-Regular known{/LMRoman10-Regular findfont dup/UniqueID known{dup
/UniqueID get 0 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
17 dict begin
/FontInfo 9 dict dup begin
/version(2.004)readonly def
/Notice(Copyright 2003--2009 by B. Jackowski and J.M. Nowacki (on behalf of TeX USERS GROUPS).)readonly def
/FullName(LMRoman10-Regular)readonly def
/FamilyName(LMRoman10)readonly def
/Weight(Normal)readonly def
/isFixedPitch false def
/ItalicAngle 0 def
/UnderlinePosition -146 def
/UnderlineThickness 40 def
end readonly def
/FontName /LMRoman10-Regular def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 0 /.notdef put
readonly def
/PaintType 0 def
/FontType 1 def
/StrokeWidth 0 def
/FontMatrix[0.001 0 0 0.001 0 0]readonly def
%/UniqueID 0 def
/FontBBox{-430 -290 1417 1127}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA0525392EECAC163E584A9104D99AD0BC
1B1844A0E222653FA481B8809B26A46F4C483A5D7E95816EA6582584156CFEDE
B994ADCFF4645140E3617E4D7E1B0E4541CB9F562E55829B4DD880AABE2229E9
4A9FA259A734D29BBA91BA1E2055CBEA4339BCBFF98D32CEFF11F296225CAABA
DCA10577A5D431B714726C1278D8101ABD1BD8D0BD0174FFF9148F8C61C241D9
2AD360A28616CB4A0670C1BF13E4018CA53FFC8B28E49B3AF8134528F971DEDA
55E9075B8973BD0B1C001D7F241CAA67472027935C0A16779AC34D17950388CF
0E0191A473BE7581A249D043279E83EA19B511D1D8FA3933F37C594054DB8297
45ECDBC2E8976B243A996D477A529B8667BB3FB7783D0B773B952A4520909BA1
EB4AB2FA4D38CD9B2CF575F8E0FDB2E85A6D59CB0AFEE208F8B5D960088A941E
6E9BEBBF2E02CBA386FDEE2F4A0A453A960D80C90142B34FE01BF72F67105E03
114D181D6A3990035A36F1ACEF46E884A818302042894B42069DD5885B97B047
D34FBF7245DEF708B5E500E71FACA6F55938C1C9E03601F110B9B96EB91E0E1C
58D594B02A771F8480466FDC743843460B3AFF1867367D645017E2A7C96B0FBB
A9189D995DAB0521ADF024FABC33682BDB8605155E5D1813E23B4A9890D852DB
2AC72D7543ED8D34C8E29A88758EF0B5364C156A3D213BCD9060892C3754E0C8
E5ECD8CD5A580EA0561ACA1E90AC5D7729DFA7B1CFCCC98DB829C1B2EA250F4E
B54CDFB18B56D98AFCD392F4DA49FE9F9CFC94137C35FA857342908ECF4D0019
6506644F2611FF4E67B09224177126E4E059D7C2A941A01BD875FEAD28864048
1DDE56A671FBC3511A79E5EF3F153E265FD840474B66B830CA5A09455CA1AFBE
B124FF3365AD824CDBE10A17B08E3A47282CE6140B0966D4EB82CB5B034DC6DC
5D6CBE6E1C99160BB1F4A87545E4D6D3EC7E30BF52F8F79A877416F69BBB5EA4
07530D50EAFE96BF6AC0F277A8A357761836E499F221A6DDE9AC0A03ADD0EF91
31B26E4332321F4FD59C51B515530BEA1AB37479F31B9E6E94E5470A0BF30403
FDB51DBE8C7D053D1B5FF78EA8CA01F3CE6E1E8E573F5EE8C282321B49B73D9D
3E9CC4C3005DEB4CA3A2828B2D8BCDAC49F4AEFA7101055E20CD98B420454D0A
2C7C4B3933BC81AC0FF01C1D51D262D6B85AD7B970750CD0D6F2500EDBAB25C3
46F96A6028A1106D2DA63EA507C2D74449CAC20DBDDD3380C5439DCB36E82A5A
72E24259E976632937402347FE0E201D60308E19DEA3902F3C361CBED5CFF784
282EF746A5C778F2C04047A5CBDB888C84AD3CF84D54A2CAB96E83FFA40604A0
1EC8E8810CCF5AFC45FD42ACE7AF59B50DC33F7A65D806A3FD22988D44043964
7B2BA0C7BC5A9BAA7896608E7C20CFA05F71EE0B7C7B67D8C7AEF4721E7BB6D8
AFFDC6C60F4F30BDAD96F4316349A0C9B26D646AE3703B6892B61D3CB4AB4187
842AEFF43B202FB9C5CFBABEDDC1257ACE67CBE6928F02D22F3D0EC630CFA02C
0F9C4E60E3A54474E96780A532F3F6B1F8FF071E03D1BB27C6A591AAF6BEBA12
81240CC0667E2ED796A8D6BC9CE98F2B71D9862113C69F0ABD2C8E0CD7C39008
6369D35D3E5A083C3E82E9BC568943DE1A68599E2F3EF62EA528B388FB28E80F
116D6062165B9EE0BA0C870AB44BB1683934B4D4429450A21C9EA0419C3A9D9E
4014CC17E17E0CA2B89117411197AA294D99144EF52364BBEF00969C9FA34784
61D1319CF4B7FFAA33E67189A63DFEBB88CCFE63251C667912F605356788B310
59712DFECD2A63DDEA51BCC61B14C231ECBC73C511681AD69F4B470F2ECB11C3
5BA9D7B664BEA7448A6B067FE9BCAA3B24E051FE87B31B6B7BB613ED01CA4D65
F79C7CE47DAD329C8020A4D71BE0F7AACCB3BE5EF63B1C4E79B49BED733F52A5
3D468179AC6BA242538EC564F080D8F2D112116C9B9732C4AF86476579DF658A
C6B29DFE3FED2EF67B28A1DD29D10C7BEEDAE714ACF1277D793D674E60F47D9F
89D1C1D46AF5304326F7002E83160972074FB6F90585C75CD51EDB22B4AA3644
E0B7B8CB2A919122800171B474419D914DDFDEFA36EDF85949E44024E035D446
8AE5C73036F3704B16222179BC125FB2A341ED546BB25A11C28B5846B2474652
31691DD7E1FA97D2920568999A59AD14685C049D0ADFE3ABFD04852B9606E8E0
74B6742A1847C136340CD545E53D67D82FD4E55C35805B7926FDFFEFB6640F29
E00F81BC52A1AE935F30DEEF5E1A8ABDD3012BDD34303AC60DFCD69198918FA4
340BAA063C6DBEE7AA46A79400E279407A451B1D866FA197A055E91732A95B59
5E32FF28C330E73A2D5F605E33B1B0E004120E72412526349C5B4D3FE5690BF4
E925AB2CBDFA9F7291EB281588AEF77FA121D1C64E3A6BA529C11644D17A9535
FDD857AD224A2DB7270781DAAA348A6EA38062CE26D5FAB880E771BFD4419920
3C9403AD934334BEF890240C606276B34A7453D932AE04BA8C1ECD87A1A38A0C
CAB4AFFB3159A66A113E066238B6CEBA0994A9165727AAAEC6FE417204F04709
7E04281B01B6D90EE76A7C997C39DC72471B7831EBC8ADB195E2FA2302597BFF
0F12D7DF5CE2197167150731721E1C0EDE4B8C30E1F06EC82B82F60534847BA9
4967D7CE8031E1273A9000C8139BAF088951C2DCEF712384E73099943D762D20
ABC42DFCCF4ED0E151DCDC6BB1C1C6313CF0CD29AC91D2D374734280ADB1EC4B
28AA2AC59FFF274B4E1CA95D4E35208026AB554031EA6AE8C8655B4BF53F63A4
8C7F4EFCAFF31F6E61A732E1B1A2C0601C57F5B7B1717C456ED996C6B9DE9E13
36BB337D4E9D38D33E46E3F79F2BC92D811CC6DAB2EE4CC3A2C7C042E823D2F3
B7D9F84290D6229967002025704008128186513B63199C3E19E8142BCF137ABC
080089A09EF7487CDBA0B34AC1E44E37956FB033A3BC39266774AC94A09D60E1
904E59419D24DF068C106C4CC9C3E2E9788EDD3A24389AAC09486F9F9874A71B
79F6063FF117C9767B7B3638761D9C2DFE3DFB24004666BA8435FE10EC622EBE
16E092A4D2E6AA02F37B2F668A6D2D0CE9092BAAB0834C3F82F2A80550E3A89A
A8A18E4A00E72032EAF44C1A0EF2C695AEB08870DB22CBA2D2D284F09826DAF8
57D7474DEB0219B34350059E316D8EE8C8572A5A86DFEE5664191F1C11943BB7
6D70D356FE5D145C73670A8F64B5D774B8A235D811FA7F846BF8CBCC06AA8533
8FCA723339562A07092ADCA96F853077AEF7EFBFC7B803EFA1554980E13B37FE
C33DF3B23FC7BFEDA3E643839B74411B7B4A3385DA035E9EE81724A19ABB78BC
C7D6CC7D75E360338F293DB4C2900598D990A8698C857A01BAA2C5C2C79D8578
DF1E5081EFB6EBBD8AFBBD15A44362A10F1795E0780C412A606D33C0739CB56F
B281D67E3B28B421338F959AEF7D3E933A0347B77F4CBCB931F9ADB92E0D6199
0B09C6A749C3666EDFC4567EF8239569CA8DBB4063FB54132B4206B20812D54A
6CD838E51E38E72E5D6E3ABF1764E9CC6A430741A82F21FB94C2D83DB8D42A9E
6C43BF0B5B58D943D62484F8949B2CE9B87D9CEE04DFF82BF14931BDCF67BA4B
EDF8592C876A83CF48E4A2F7E92558E57F43EF3BB68F3FC3DCEC70597CE93846
0E736B1DE553BE603600E77410A768936DBB1162F16ABBA50F261E0D4DB631F1
05D77CDF18A2EDA5801DE620C8987AF36CD7F1B78D3C62F09DB17818A5F1AD15
C37D3EB3CF8F554A5389129C3D22C556E2F6E624ACC2B41BED13009B9EB33BE4
747AF13D0369EABE30E90ECFCE19F5BC63300FD44C35250329D5BAA3159E63FB
30583AFBF18010B75004203E9C274FC1F0F59D7A86D619FE0E895127F3FBF6C6
3C2901CE4AFADD0873708C0957A342418FE27AE87A1879F88AA4117D8064EDF3
5EE62A351F1F2FA51C4C0B5E613FEFC6B1084D6ED8793065587F40DEC9D81F1F
FDCCDD170A6C69F93243D25495055E377E32DF8E4EF595082237F224EC94332F
D441BA7C86123582F655B10A7DFD2D950DB053BB719CE9B2D2F75106CCA90E75
B24D6E3EB9254F7781AF73C474593EB984673353F46204B4DDFCD4F291E0BB1A
9D79E829E1B64DE91C306B8D803E670F03DE2BA917E3284D54F612C02DD4C626
D15910F33E4FF64CEDAC3265364A924F030D7B393F9582725A47ADE1BDA0E7CE
A438A12D0216F822CBAED2657A1913E3C0A21FC6671CB75856B0FC7626D42E7B
65AC7ADC46008D953CD80A6044904AFCC4FF4BC074370AB93855CD45405C5A1D
24BE64BCD5B5207541D34D08480F1A1CA16F2E2F80713BD457397797B1F5E1DF
730CF36E7E0DA7F9805EA526D43F2D092368CFC4E14862D0B702E894290BA038
91644EEDD4DD9074727F4FBD3C035BAEBD18239DA9049B276CC51C86FEBB1542
4B17BAACFAD06CDD33783088F76EEDD62B70DDFDCE42BE4F1AB909E96F7AA5BF
5E6CE5043A286C7059F595DE647221CB17973F4072013D02D83317F23357B647
C862F5BB1A4B3F8CF3C20A8E023AEDE14834A48C46AE9BC294D1647D5DF3E770
995DB9E60042601B77C15A096749F478B3BFC0B850A258E9EFC4E9DA426F9E7F
8D2811727965C758F80D93D5FAF5B4BBEC5416501276491B79153F8DF73D7682
03B994916D5EF2A997E3D910E754B16CD1648D0A7233986CEF5A3DE144D44BB6
8F1FBD1166D8ED27FA10B52AB7C029A71A1BF21301669070A03AEACB67AC9A4C
A3E4242EDDA8146103B7D094FC1DBFA8012920F318C56526EFA8AF51BF06EA53
C4CA7EA1C1D0DF8B24B9932439743AFAF5F71D77DE7B4D89F5A49591E1414EA3
B759FE9C5A0CB20536B0E38CF4BB1D748D528B25856958961620FA42DBBE5C9C
C6EC08DB9DECA517BCDD0362C3A8055B1A84E1C16B7E0F2202AD5B6BB05B3316
6249746F0524DF72645893386DECD69B4EAEBEF322648F56EA101B2B0BEA4FC5
F6ACAB079419D6DB276705AF4264845ED9EC42B85DA266904ACC0C07337E21EF
5C8427F3892B7232C1F778F3EAF1051C41D33085D48B17E6B9D9B87CC743CD66
3428BC064DA608FF77025B7681DB1D32BA0B2D0930B962045A81539DFD46D97F
7EB378343C12155843895629C960634CB3C5AF28979DECF60ECEE40939F3BA8A
A5ABC54581DF763F03516A6EEA22D2EA136FE2B8C7CAE8040C82B038658176A8
81B33381A8A917587C9F2B88639153CC35596DA918AE888095A07528C8343292
E178983EAD8652BDFF82CC4E4AE64C608EEE0A2FA4E6E74BE7E335888B50062D
8E062552AB41688EB7E6869190C0E77E0EFA31A94D66E413B344914CBF11F60E
84DF1261252400F85D007AE9249B2FC9743322506B1BBE7BC8CB78B21AD75A50
66779F26081CE1DCF8FCBF985B41005EA0771D9289936BE110C37AE06BE77056
1CD930E8AE76E353293828B0B11ACA917354CD7B5811508053C9B5914FC368A1
BDC9A16AAE28B0F040E7EE32051306E1823F29FB7E3F617AF96FAA938D96A6FC
2785A8C80F736AD3161236231558A33BEC1D91D932FEA8A790C218DD6FCF2714
60614018593934FB9469E4CCCF24ED92A55F0A2AABECE3873C20AF6233D8625A
DC3ADDB0D6E0D7C6C9F700CB9419CAAAED470B4E2C60928AB8E917656140AFB2
AAF466E0BD8AEBF7FA8472DD441E25944ACCE82CCACC073C15DD9CFAA477132F
878AD0702A921DD2E8EFDDDBA23BCC56407A5FDE179A5573D0119BBB538753C3
37CF381BE0C589186D24D5FBE88DA213D3C314505BE94706322FD8812BB27937
AFD964197D213804BCD6CF66E574064E2B0AEEF95960D1149906D7E794EA5B24
9B7A07735A36737C99E1B7D6043FEC386E3A32D3EB9DF7477A180FF3D6F876D5
E3064BB81E60C03EDE3F8DDD32A240FD49AEE908C7972AB2A420AA53D0BDEDEA
A3693ECC7071FEEB02814EE5D641FCF55E65DEA77DABEAC83CF88F4569F10675
B9C43FBE7FE5588C7C6F1EB7A024989A6D910914C0224A700E1245ADAD0833BA
B5DE70958048F037C56C14FDBCE691048469BC4A622FB185F711441471ED9720
22B4D84CF007C1D9B1D447350C0254C27B0A0F8D3ECD1B056A35C37842C492DE
E3B9F179EC5881CEBF7EBC3B30AC8AEB18B09AC718320DBD7E3AB84696304079
D28D41F52248D706E117DE4BCCDE81C0486C57E52DD412FB66F40610C2299F6C
60070E8CF6E319718C9CE7C399999253CD1B97676042C99707E714CBECA6C2E7
E0A6FDC0D15A6913B9819B3642F42ABB9A82A7C1BB8209A249087BFCF44024E3
1AB358FE1118431DAB4869A982293003C83BC5371513272676E778C9227C34D7
640F5016E9E8FE8ABEFA3D85BF7B6D1B4A3A2059B4D78762E43ED9306459497F
92EF2645A1382AC9F838EAF647DEF397ABEC466F56A4614EDB06F59EB50246E1
D3C022B0C181F21093450D19267E31DD5F4C43A33EA29CBE2AB98CD0305DD935
D8F0F5EE3153D60C078DA169F77B32BCF9CE3782D3EE1739B003DB2ECD2FDC63
940F7AF6A1D65E11DDA40CA0A4929782F3E0117B78F1B38562E968F162D67BB5
DB67595670D82A537DA5B90388374D2E7BBDBA729271D1230281E2EE9B02570A
B1195D2F25778C99A04E82B1BE8D3870F6E3046F51A44EA785E273ED52156C07
2485C5377874A00CE959974D7BC3394593C5B714D11C02CC38D1DD42E3743CD8
EE84A9DCE4EFC789DC62ADB82B0A55BD56905DEEBA4791B6383FB3CF998B8479
6AD4F1646204CFA8DE394D015BEB91297C8AC75E14B1FF34449F491D791F5D84
81C14DC7BDDCF92439A3AEFCF1D503F67E5C1F345C050D451FC9CF98ACE7F8A4
CB9C06F5A2CEDE9C68F323E4BEB6A86084AF0E901B4CB170B03CC44F6B34BC47
F3A32755362A59A03E715AC1329D7087AE7FA7566551A6F3DDBD778BF5928631
89FA8B4FFCBC5621C3707CCE1F9266F4FCFAB4D928BF979CD69BA1043A2D06C7
2F4B64E36621339C3A72C5F7B47978DEF521A2A1441F24A66033FB688FF4C0E8
E17D70D9C485EC1BB6E19BE9B11B5BB63C10BCF07C6F02FB1F11D7C48435ED15
ED6A4BFA43040264442F31889EC981697F5330602830E1038363124F1B60E65A
13C4E5FD0FFE16E623CE25814E30876470718C276632DAD1840E633128073B7A
A530ADC514DA05821DD89F3FA8506F268809EDFDDC647A3C41FD3F4E45681175
F8FE3057BF6E9FBCF3F635F1FD8DA05FB81366C3F3E3F3693001CD131D8C3330
918BEBD96204FD6BB42529610091D8A9F09161A41BAC6A15727CE914A10FF218
9BA69836D76D228AB453597E80B7D3FD49E1D68309BB22DD1B68A0A278E02684
B907CEF368DD836DE551257895D8AAE708196E122DAA1E98C127199A84F061CC
3214548269750120302A372703A175DAC0EA3CACADE7333428063F1762AFC734
20ECFA624352956BEB81E63BCD7434505F539E420221C6397E36FED57A8BF210
D4AC4C64DDC84B9308959DDFEFE780DD8C4EF214BF549D9C0E48027C94A8AAEE
C417AA6A4833417E36F75B06C555D966E73FA7A1164CF197CECA742D4A49D460
2BB869D5A85CE51EDC81601C6FCD650277B6A0C00767CE1BC19F391E08E575B2
EE78E04C5FEBD8D5542DE899339842E6524793E24B0D160100C2DB33BAE394A3
F96517CFF904BA2676748644105038841988EAA2F939B6B9F8600A76C3459030
9D8A9CBE69D2B6F60090EF1DB81A77C19C9BDB4426F2E6E52F6410BD76E446C7
CF8AA3DE4A4A3EA5B0A1FA8465D257173CBEF53B315D8BECF976D4C7EA2FA6C1
8AD874B9B88D345869D96C57CAFCFA148BE140BCCDE6A49D9F9E43B6A83BC488
F512F8067175476917012FBF0613823E364B69357920BEE4A0333AD0D3897B1A
83AE9A7FE4BF8799AD4FC0BE438049DD58719392C09593CAC84EB80581802EFB
8FBD6FD2D909977882A9A1E80EFBDF822E40493803D47C96A2745580EDC957AC
4291730A82AB99CDEED10BE76BC555C63113ADAD38F76C7ACCE6A76CADED0E11
9E5ACD18F96868A8BCC914FA5EB82DFB0A5C797F8826C5D1FBE73F88F7ED0041
9F673E4C6AF2DFF2E264B94AF73074469DCACBABC2031D1E1CF627EF644C10B6
D200AE32705CFBF7A12EC415F3FD1B6DCFE6A6C3E91243E50DBE5DA38D700443
A638FB7F35261F2A0E0BA573C477839F178CC1B15E331F250334F7043B31D6AC
E43541A8C0D10C0B97B503F0677601A35722C36EB1627EB1F1589DE405A8F821
C2EEA5310936F6232750B85308CE4BF209AD55F2D683CE217DF2D10EFCFF7628
07D1F610D26FFFA12CFD0E9247BD4F2CE894D6189EA60562F85E8BE3A69D94C9
7D5FA7F1C90D70B5187331B37E2894F9FB61694AEA08DA49E20BC42CB63AAD25
E7467ACC964FB0F37723C0C4BFA4DFE3FD4AE99F5A8595EA8733D75422B85C36
411BAB3D72DC17FA6DA648A6E95483E1FBB4DEBECD7F1DA1FE2A0EFAC740A45F
E966833B2F8D60CA40D2F1CEC1E150F553908DFCEAE061855719D9E4F15CBC8D
3BECEB718B49F2297D416D2A3401DAAE76C3422C2AD3A949D41A94C28119DDC4
15526A257154FD69557C15388CC763B7B0E6C116B3C87E992DE617DE48BFABD4
B800D58CFC32379D202E9FE870D53EC343C11F2D22729A2C7FD9A30D9E8FFA9D
0A9D090B86A2B91B82C4AA2E6EEA7D38726F2A1891340BF1DA9F49EDA513D1CE
E71ECEDB5E0C03AE37BD7ECB937DF74507591F850538F355187F54782429A21E
2A52099C6E75778A369CE351C805E8E2DD8A29811E6DB9E8BC8392B8940C458A
631EB49A6383A5CDAB2CFB5B30B3566EB48440D16A80A98303C4B5A78173F07E
3FD7A174C40F2366A89977662CCDC02EFEA6D19ABBB21273D4C40A207840D6DD
0F833C6374CBD1C137BF68BAE02943FAEF0D36E3CF03D2E7C58E3C508AC53F34
6D5AB105D504A536A7CE3A8297DDD879DD2411CCCEAF45E1ACB497CB6F88ACB8
C90E71F6DC60216554DC152B2CD12041A9722DAC7684B9DE946533F9E7C1898D
2AEA861D0A93C6419A595D112305734269B4DDAA76870828E5A3401A97F5DF6C
E47CF745E42FF495D4DC15D52DAE64F1831E2FCC5EC3D5A4F5C2CEA86F987AC8
A404A1E3544B0FC0E0613259D3F69663FFDEA27788C79062A6F0E358BB96C815
AB13296F3745582FCA48E6160259DE798B725558C8B7BD66940343D5A9B84110
0B8DFC38281F497454E52766AB705E9749DC91B35EF73B4C6F230A97150D0E5B
8D0A3F7A59D9B902E98BA4D447B70248587B7F4F6BB623914884A193955B388C
F75B423EDF4F18C0DA19C4CB927080B286AB1CCC12AD3D5617EEE8DEF5E7410B
896BB3E651A8C015BE75966176EFB1F5683C070D78A06006E7E92D25A6F5EC9E
278065B231C6C1734124CA3176AB14F48826ED2E56C67571D8F66E921BF3FDFC
F57B30BA747DB8C0EC672AE7E8BFC768B0E7C4F285F9BD614A00DE6825572189
A19315AD3F237FAA52C5AA0E215357F7DC728D263C9A3578EF05590EF4F3A1CC
03F54E22E2B141D5B27256828D31249CE92AB0B25D8B9067B59F8C8A49FB435D
4009A62CE2C040976600A90CEEC671DA40B407AC3F01E85F9C3EA15E1E777D1C
D1E22606278B4EF7B4BB62E18C43FAC309B193882419B253F67146294E78153C
EFE299EE7459799DC16D93CA35EB458CAD1AB52FE22BB8ECA12177C7C01F58AA
70AE9037BAF2779ED8034237F25540F71DFBA7145400776E2A65C4A068C3B509
2F3E1234B3D8EF2F91B0675612197DD34000D9B35BC93FF2EFF7DB3731D5832F
22CAA7A8676A83FA6E29AAADFD82C6585E084B84F5D61AAED6765B2D3E2804A6
BA4ED736AE66FF448E2A5F48EE557BC3D255443F9C36A543B27051116A15C25C
8F655BF7D1612317A1CAB777FC839976A411B02081F07CC2CBAF800162DA0993
4CD93AFE810000DB2F0D2F05C6773A7E26264822A608BEC0246FAF7EB80C6D25
673D893C070CF405F9027EC85A5770A26ABFCE9BB6F317D1927FDFCD08F11CA9
C72A278C045B1D2572EC08DE1424D2420AC33425A3FE184EFED5F7091C9A9B20
0C8836B997BA06CE2A3726FE20D669E65AD7D43399461FEB76701C814FC35FB9
95912980707299900AE4F349771B17DBE1B7FD3B7AF5D8ED5009FB809985FBD9
A3E99D1D6124A3B4DA19A52E983E07BFCD447294B1F96ED4AC5B1BAF7B8885AE
BB46DDA8ED86888DDA3065C5091D99EEEAC430924659B31E06A5D7D9D85748FD
8B81BE6AC0D179D8120F9E6B125C9B833F41DA40D17653B80730495803061FE1
95FAFF9403C27630AE1F32E2A525D41B5B8ADAD8D04D3711239238B8CAE9CE16
79120CC4D5947F074E35E35172BEC6F4580AB5F541431E0E308517DC05AB4226
7C94FF60FB482B26DB483FCB8E97F39B43FE3DC97535A6E4F812454833BEF059
47F6414AFB850F01817FEE4E7B14727B086F27E43E6E3EA6EF0DE68E1CC5F395
D837E0B2E643F33539F5018462944E1080623ED300A8E2D012AB1B72A4A59AD7
58D0F717817F3007FE1FC2E2A2D16FF35C3D8F5FD37B1D57603AF1ADAD376537
2680DA64C30D35B103D73176C8E1606A061E66067CA19042D27FCE2CC85BB5DA
E1FC5751649009B86F08003D189DBDBA916602E032521102C48CB58FD53CC14C
A2F32F6196D2E4BA1BAE2EAA53FF433AAA6D12256F204A7A0A0680F1E0C94AB5
509CD19279CE7A23C71963F3680ED798C70F7F154C0F22A6B5990B708E8E8315
0023EDC5D0F37C2111F4B06818ABDF3337B13915116E6563E8AAAD56D0136C16
C2109C87627A1CFEA2A6707D6B09AFCD00B51202BFF8AB5B5A9B4EB45A97E404
E705015940783248ADD641A983CA3BCD930955DFBE0DA8B9619E7552996746E1
0C865DC98E53B30F37981E5716C2F05DEFEFC548CC14351A8DABE69F2695D04F
60989565DDE13C7F0CF7EE9CD6B158EA2599E0A4DD88897E118D3795C0CBFB72
04DC6106447C1B7DD226CFBA55A428BCD167EA1DC8475192428C7329586D1E03
21559F67C057FD7902194490A4C1383B2BB2F981BFA79544B1A2F756D81ACAE2
35A58C64DC18601BB1B3E49E42E7B668D99299AAFC1A4965F05C12882197DE25
DC942224F8089BDD425EBA2FCB5BCE94E18AB3F95D064734F8E130512DF61000
16BDFA4A73702F45F552E8F9DFC8C9093A07D46B3102148B03F0B16A43C6F99C
93C537BDE3A1A9A4C90286999ADC8E984DBD791ACD0672EFA91DA6164FAA374E
3C846535939358D67A476D5A021D50886FE4E385E858EF6CF333D987339F41FD
5557085F0408A462B7639B2610BE2FDD5E67DFD533388C37C63F8B023CEFDA13
60E320862F2CA6E025850386DE1A7208C46AEE9AE963718BAECBCD412C2BC6BC
69C898B2348F345EA56D9F24F947B9FB2A4967D4EBBB0BB24EF5C95044FDE239
2FAEE38BE1EB6D086F2AB69CC4A0CA80D0B50FA873765FAC542ACF3BC988693C
547BAEDA43D8A0E83AD725089C8E78B68456B61D69BD455269A5C75BB7CEC0F0
81877B317766DEA2090316916B563D8E86273DF6CFEB55341D3FCD1B53E15238
A93F53D2EEB87F9A79564DBFFF9566BEA8DFAD1CD13FE4F4BD5FE4EF0FF8D32D
5A7179D025981DB0F1AA37EB7E091123B76D649736BABFACACD94FEE02EA7EDB
7DD9DC1B25612390133A26FC69AA03ED308F28A23FE7A7DF7F4EE6D26ADE52A3
270DFE501ABDEAB9327E296740F0DD9B42A45921550627C2920C97B1584B7E00
DA82B974AE4327AA4FD8482B7EA745BAD97812C0CDF25A65582B0EB9095343CE
772F8502DD9589876E99276FF6C905EABB6DADF878EF8FF5E7BD112C99266BAD
7AAD4B07B301F4DF677811F04F651B3A28E333D5043BF8DC51096B86BE1F92C1
9CE2D314E85C035F58841A33137C07AB3D35ACFDB0B2AFB03CC96E0DDEEE9FE7
26F7C12D5C234119A43929F9729847B5A4A1E37B766568C833B98C74B15426DA
05AFD553AFE0EDF8A1D4878FBE6A8D6BD3179330993557EF5523D6EE9BC66EF4
9BA3F2E9C583DA5729C57DCB33BAD83120E618BBA0C7F201C3E6822BF981212D
16DFB95131565720F61FF5AC827C2A085375313DCF0512BA7DF406499A2B12B9
53D0AE1984D78EF2399E862A2252306D492C4F6A7635B85ECF70EF5733EDB267
31D14A01D92E2AD1967EA896C09692E9057801F243B335B5B29208C2C3AD13AE
A937254A27DBD9A20CA017FA6B91966ABD8FD9BC3A76BDFC773C1957E23347C4
C78D0C370689EF5B4B1597C62154E0B91E21C1B3F2D82E9407B8FF6B00ADFEE9
BB9491D96675544C2391D53460EF0BAAFA416C0AD757374D6A137B757B0F6726
BCF115DA1535E9CBF067454217CB82BA0F846091839CA49D29195773CFF84EE5
BD2F6E5EF145F2B9D6611331C6DB2E16059E78CC7621B1E7E9D9AE9AA465942C
8C19D915CFC9411501E817A9C1AC42B75BFC767EECE17C65560A0EE4086C3773
12A29D535497FC6FAFF006765DF51E5FE8366CFF6FF31BCF32B3B2AFA2DB7769
0128A03D84EF3F57A9EF6666C16305389F1055074A08BCD6CF66E574064ED800
C05B33A5FE5BCFE16F81B25B5C72225368CD91A3BB5F43BFB1D32844D5338B93
3CEE760790F94D8A01F235C4403E05B988B626D61E5570EA404FF3CB8B044E34
BB5437F75671939E4D9204CCC611ED14FB2F017F512EEDAEBDF8B5D566FCCC49
DC4F860064EC9FD92503E01001F5FB965434B51BC5C9FE203C53FFF50A204D54
CFFBFDD570C4C8890F1E152B1DC45DD205A97C944B34487DAF1BB6D934295DDA
32D7445ECC1140D481213BF1E9E3F318B496AC776043134334580E4E1F22551A
EE8318E6DDB981C45E13732321055D27A93D8C76370C87943275C36814C460BB
788A0E5152C5C8FA2C67038ABB237E8B453C48B904E58A069C2A9DA7AEE1F42E
318FAA9B1E97A66B2E9B937B85A69977BA8352BB68ECC89C182981B95AFC6AD4
12742960F1B7EA0FDB1228C5AF0AF8638AA4BCFB0B711A771548C11BFCD146DF
F1E58F49E0D52251D437D555CB1FEF227CD15A08CA2A245C3EDAFDB7EA560346
347B43A543D52D3F0687A49751BD76AE76C9CB2090624BB22393DDB90DF1D854
5651EA77686F53F34502EBAE22FE9FEEF344C5218AD07EBB2F326B40406378E8
1CF88EF1B4ABF193F6F0F901537ABE3F15F31DE8A2CDD3F5477B7C100C82E82F
AEC0BBEA7AEF0C20673C9C5F76C2F9071A4BF4FFF2AFD7A0B06B3F26F9B6B63A
B1B045CF5A585471FD2528CB9881A8D662574F73F1B56DC959DE82E9467C9825
5B361BFB67AF9124F5FD8268BA3DD3558B16E94DD6CBC32B1D1632368D09ABD8
296C88DA67A92B90A9B4E8BB7A7729BB91A865A736171E731194F7C92D83695E
DEB559F0D4A8F736C91551B5D45C74E7DA1FAE6C0E145BFA019E1685D4F82277
72F200BD95426B83175316E6E2ECB7BDE6902166FD5B9C3A456A6DF0234233EF
08A17ED68AEFBBC8914D0B4827F7C2A76466650B00DCAF38B8C9332CA8DC2E6F
451974F01F1116278357D8659BCC81753C2906EAC08FC3FB9C19E6C5F35440E9
4C8261317E023D1EE84E77FA872027C73EBADFA0C6E2C7FAE2B6477320DAF01F
C329D22DD8C4E4F91B1730A230B9886D898CB6B51822E9C6092E977D6027A633
D126CD63FDEE48E210E261C16EF1A023636226F3333CC0516EE29A951A033277
0F1EB78C7DC4285871DEFD070173D7AF2FFFDF728B7EB14228DDDDCFF135EDE8
E530CCD921ACF0AFD7A972250F2EA50E2A559E25C13A34A45E59D1D51E5A9421
2F7E51FAE541F3A3FB992E00893A100BEC19E13A6511D4EA600B1ADC4C3748D4
B50226AAF44834DA5F3BCC3029DB39095E006F462FB0C041D7B8AD117442D802
DF52CEE62D333C8680E45E8E328C429CB0DD0279D0FC834B3DA7B3B8C176ABD5
2627F119FDC4AD5B38CE04E4C555757F69C669C5EC4037775419329BA90A6860
DC939E6D418E4020AFAD9B94D5744485A1164A287A8C8C869CE3BAB8C4891D68
A761DB008A2A61151013D6B8AC2EAA1986507AB035C835C8A5FAFED0A6298620
E5154BD4372980CCC046978FB9CFFB44D28F85FC48B08D9412BACB2DAAA28DA8
6CE91A6C01B4664214B4E095F2C33829E7A0740198C15E1DDEBE02BF2C6F3918
9A1A07946720C31C5D12522AF7CC17918E9B16A4F4719E66EE3C64292C209A83
2AF504B1BCEFB0914789C7A667358A1D0D17E663657B75338691E9EF477B91F0
0F910ECD8C5D6D3D394304194538BD8434FB03FB210C0ACBD5FDAD9448B616C1
A2AC048C04EC131FA9CC2355C664139419373923D5BE1FDD292F80E973E27128
C51C4F80598937ECAAD0FE2A9EC2744C84C939845A71885BF10131BC8969A7E5
2BFC97C3C1CC59ED40A970EB9ECA0C92948EEF95C118FACA7BB622E36E4EF950
D4618697F341825ABD849980EBBAF61719BC50DFACBBC2ED5DE4AD49B5EE0AFE
3B6468AA01ABC8EFFD9B0B6F1EE95FDE1E01D0E78EC979866E4CA2F3528521C1
815338E802EBD38F0DB5BD23B4507496C95A57D76C2C39A36BCBCEDC1CCB2F04
0914451A48CD6DC39120D16ABA9E1E768404609B43776382C4389362AEA7FE4E
03637B459B44FC6BBF7432E4876FB3C6856091CEF0000AC12460C125C5CD901E
CEF7777382B77264E93192E37A07A6CA7A0D15C41094F704AD4A2236651359D3
942F98C02657D3081C58AA70AE9037BAF2779ED8034237F25540F71DFD1F82B8
DAB677BC1AE4BBD043BA99CF39FDA56C856E0F16AF30A52AA3E631B7417F217B
0BE86CEC32409D8B66D459ED1FB15E3D9E752D94747250D79F3541DFF07C1F51
E14FA0D48C8A3F63ED30CCE41E5BB788B2873C258591F9C5FCCB5E7F9D9F6D46
2A3C3239C9397C79645EE322A5AF3616C49C07BEDA6A2349283F0AF62704F47A
9041EFE8E17902A5728F9AEFC3DB3E81B5EB263B9677474C1AE29233DC3E92F5
C7379278D200DA126D47E4E00BAF7C55379066FC8C4F948986B1F80EFD950B74
E614A53A179DB0C939EB45253B4022AB3359D2EBB743BEA31AC3431C62DB2DDD
223779B1E6F7503E0C8A30AA00FC99195E85BD6420F6F968B2F6AE2133A32FD0
C3EBBC3CE06191C0BA6CB7E33875B819AEB1EFE37A3656C9B2060FF203AA6E60
F1173DD50937EEA219B78822A55E3E6844FE1E557A302BAF9183DC66E9B2499E
FD2A7F2611808203C03FBD9C6FEDA5EF8B6778869A1713C9B0AC672EB691181B
46D6323843FFE132EEA49E11D6BD6E0DCEEDC4068CB10A9E09D504E360902F06
80AC09575B8AD8AD43E1C61761683E32EEB5B01778D98C33906CF97A9DD83BA6
3F33983BE6202E89777695B9CDF0E3E671A8BB4EFAC3818877C03C1100D8EBF3
CECA4AADE5DCBB3F0CFEA4EF01D5BFB0418A0E4E57B13B956E26191B12F8E56F
0064A844F5EF74DC514FD192BC3581A31F2DA8A5556CFDB9C55F080D93E03148
83988B3A4A2B72A1B4A3D2189FB90C0961CCFF80326873EBF3F736035F6AC83E
492590CBFFE768538B1DF061BB3B5290DBC5E083A1E0241CAAA6A9EDA5BF150E
373526CF55A76CC97FA47FFDD7D892E0B8BB19653B9CE7A86A6666E25BAB5DB4
6CD7200BA2F1BC6A57928E5DB7B48BD20D22D55B9DEEE859A2E5B079FFD86D29
45F28F1190BE3F7D9017B446DC924912DC98E39C62F47CFBB85BFDF8A699A64C
FBF0FCA8D2C581016862EFCA1E621ED2A65D66DFDB2098887BC845E63A5B7E4A
0CF91F7087EE721F64CA0E33B511878F1E0C83E15237199C9877FAAA0D6E5613
A6C69F92676D92FBF5A527BF5A471FFC465B8D40FA63BA53CD71AC8A5ED11448
A8641530351D74405DEF39A01E9C18183C34B5BC8206754648B35B9C84FBE4B9
4E616C0BDDB44A1151E2CE030223474BE8A196AC89067C7D659080A08A54C360
2D37BB20A18A2606939F993310890EA3D630838F6E008F90A1CAD1C2D3424E9C
D58A179A2BB40AC54D2E45D203039252129BADF8C69BC5EC029BCBA01A455AF2
9279CE534BB8EA5564BD91E07D49C8224435F88F91BF1370742CD2662FC9CF4D
1A5F32B6E6F0DB26D2A2BEF33383ABB4AA36B73CE97C83E306D223CE7774FA5A
F973D985C02DDCAA7708B467D1D15A151E76DB702FABD13F17C5CC8048A9850A
B9E8BE225001F0CB10F8DD82910F9A54F139C6D9B107BBF43CDEF5D2A41B5CDE
D1A9D574718B9EDE98BA4C7AAA81B42EC94C58208B09AB28544504409575CA53
824C6C5452E34A39E05BFA77CFB2AAFD32A72C7AD830937DAB9BC3FDBFAC578A
525BF8B960B22DFFC0E3C2B178B121D38CE79E3AD729E30028E43296A0548A7D
1F298270EAA54F518FF6356D0543D1C17BA3C86CCF13F7C55EA79B0658E7DF9C
1B3B4A28545B49091D1687034AF1752C33E6FDC967E75503D554FA90FE87FF6A
54995220D4500F7D6E49783E9FC958D3954BB4737612ED90DDE033E35DB499AA
42EA63A8CD56AFC62B6A88BD1ACFED36BA2DC0FDCBA1C570AB49AF1379531536
75A67577F2B7D5013B609FAC8FC19A58B641199652536BC111B23B695AD1DE3E
935E231AB657C704B4FAADE3CCBBD9E87DB78472DF419022F6B4D7B1E210382D
B0321D08CFF6FE7728F3068203896C931C86081B9870A584F81C6B774EA235F6
F3C221A21FA27814F2945BD12376C76382F651D0F1C98A2EFCA1A117133DD39B
C60F687306A10050B3B14A0C43F5BB9FA2C36526B2411B2B72CF351729DA0FA2
D76D94BCE9E2F06F49A6F65CFF1A4F8BA05BF8210708DC6C5E1A644D9C19E829
4721AF852399414A067A84E0976D5F3C82542C5E344F803547170067B51D03AA
7A845D4664D911B0E64203574E588A6F1143DAF25B727E1722FD55C474A37022
FAD1348169A0DAAD30374D34BD4CEFBADB2725A9452350192F905F9EFE361717
14D3BEBCC2D016EF4B68FE6C549FFD52BC02589DFAE6B1527A47A2EB5562F40D
56A25209C262DA698BA0D13DBA590A293A0032D6CF19AD21811FD0A4E11C873E
88DFFDF63CA60BB3CE6D39B62E74D162022753ECFCF0A21A76715A7856FA2C8C
10F6B6CF80898FAB4BADFEE9ED03021AB7D98CCC9F5ABFDB71AC67AB7696B479
360490EC08C18B48E1C966330A3DA363331BDB4A21737805D0C1CE0383D95884
4F545060C666801C182AF99D4A8A3DEAE7AB680FCABB0A87D3C5CB53AAB37664
5961C355BCD58EE082F497851499E3E82C66DB5D38FBF245D7B5398122676622
88C29CE561373FFA666F6A4161E6593F9EF189A6067BCC5CCBC4A7C3D0AD578D
0B0451F2767A6BF819765A8055D1622C478F8FDA342685F858DE3F53F1CEA685
9C8957032A6D45BD084D6678957DF6391153F939FDF131F3CB897AE1DEF890B7
294168C39592C74D17AC97E14D33FEA24683F2370B1ABFB841B44E5800A7AAE8
E64103613C40802E0D32EF0DF8FE6F2D4E2880EB4A142B1C2EC723699FD4A5BA
72587E32274197FF8C194008B9C7622AB6CFFF3022D1FFC91F6F2C6B28808CEB
9BD6ED0CE40CE159C111A6468D2DAB04B3ACAC61986BC3AF3979850D0FF6FF28
AB27D2F132BF72F1BE104309CFC79129AC467D4856A8FE1E3057ED9B6CCA466A
3EA918A1EC68A19E2AFCCBB41E1272EECD29EDB3025F9B12B5215919CC2C70B1
97770BCE78D444F6EDF9840A8B741F645E95EF3FE72CC66F826A3A692434D4D3
BE6ED6DABA6016F095B68FA387BC053E36BBF9C0955610BCB009883036F88A06
D57725D1051C7E8344B56F83FBE176C468E63CD83E29CB969639BF2C227E8BFB
63807FC36AB88C65629859FC35DC8A32BCFEBFDB16A0642E5CC69E5A25A663A5
C6B4A83F47864D1624747054CC3E674581B8E88960A10A818E8D945FE492C0C7
83EC9AC7A95C0832ED8BBF473B4E0CAA5E8F73A090F636497E8C40D6FD344033
5795412A0C4996F7292D36D4B6BDD139C69E0B2048B60A8A33E7FE4B7CB450A9
C45FCC1397C6B0A86284D5B1003F0ADE2D6AB5B07064C07CCE41472971848451
A245DC37C2D48458246B14631585122452AA1469B0C3DBE762B0C2995358F9CE
AFE7D68C9CEFE49C4DD9745142652D545B63AB30DC3F3BB4B4EFDC6DD658FEAF
E642F6F311EBC83C00B458426157AE838C755ADA472EC3CD85FFE3D6F4629CC4
1AFF7700001FC838E8843F5B2D5D6FBC1FB006AA6E60F1173DD50937EEA219B7
8822A55E3E6845AC91D7B9804A7F49654F2B9CC5E6F2006EB0C32DF290076F8F
EEA3D9137DF428A563CF4C5677613BEA94BA0345F38AB0B03187728AF15BEF6E
BCEDDC19B9F7DB251410D921E5EFD3BEC41F18FB8C6D2B457E60950E1CEE73BF
E2A6191A51723300EA98739492C91EE775E06E20F34A81B8A8EF20AD5F81706E
AFDD970B0B09BA37237B9A8B346890443C692249430BFC3D84DD1BF24F80D097
5BC3A1EB6C07862D3090AC8A81D8019BF968EE3121032B4F2C9F3B1B48224627
B776221603B39A31DEB68B5D86E27E02670CAC5ADDE78A45B552D7C6C98468AC
A69BDFB6B23568A9F686824DF8DBF0EFD6A0F917F3760EDAFD45D53E5141FC64
FF28F1CA6D4F1BEA1C640181908257154853E92C12B26A2295E900D7206F8293
785364A5FBFBF1F16C034A24BA4FA16E84B73917E43FF456B5C435C544606C83
FBE5FC602B7E70A0047A05623D54F22D000AD8968BA2383121482B7727ED2FEE
F31983E07927FF6ABB32590E6E1CF675F16D72C3C6FC29D60D85375C57F14FD8
765468462B9AADD9F877A33AE08A7D848E5EB55B277B74316AD3CFA839A3F272
6AFF3A2E092658E4EAE5B077319C3433A852EB0B3E5A1B0528FA9F8BCF9EB493
3FF678DAE5837FF6A42C21893F4FA98854D55FC992F6E27E100BD329B282FC53
B9F4E7363300652BEB5E6B6CF2161C8AF4879CEAA37352D164013DA9C1D285F1
5E4FADCAA403859680902B9B5A88CCFD133C91C1AC68C603F4E5E0F97FC9B58B
6A605314F854A16AC3011DA8D648EDCF410380BF34AC17B2E42C84A0B24C1063
C6147D914FADF25E9246C0118081A739201A18E0B2B745E35BA82E8DD209DDDB
0964A51388B669C597141ADACC7692A690B5C6DAA74681BE30C4E671CD96973F
8D37C19E11FBC7F3914AFC8AE0EDD3B2A799A6FA035D98B3923481C321995BD0
23F95E71A2A3C258F7D7BE6DAFE1F3D2CA18A22F42FD252E9A1165B4ABE31F7D
7D6F5FC74311E51A3F52CD273D67E589DE38FFAD26376939CC85C4B8AA607DD6
C884CC8A93D55990B01110D3FBD341AD62184274F2BBA2AD823BEF7DA8C97C30
F1452006AA3B1A16804DD802B666A82EFE254436F63898712D63BCE010820920
6616681FB9477E2A1243CB87523D2492EBC0F85F5B07293FB92453683899ECE7
EC3DDFF5B0B8CCBF3D9CF8E5F2124566BC16EC17989C1052F8E184590223348E
5C71043965683DCBA5BAA51ED9F1F601F0F088C4C28594EEED0E3C26FCE96B24
DED8A0DA83D58D8413A45EB189AD5A99D72D0A04E30A519843CF0206062083EA
C81F243EB34B23DCE5DEFABD0DB4DB4CBDA9C46711076E1EAF6A46CB3392E364
FAE54DB1FF3EC1E7F54BD410B550C786D3AFFBF2FF71E6B9FA184973861CE1F1
14BC5B1C3F05A327DAF222DE1D337321C2D70FFC31C83EC0639AC0CA4CF29303
374135BD971EEF0B2EF3E89B1C4155B230528703877FA955528772A15B531E24
C5862B4C2DE344AA8F2E1891AEB8D5F7D5A2D86679B8725971AC9EFD97A1D4BF
494AAFB77C7CBD65F29DF4150285B50807327565BAB0514702CA7AB9E9B427C1
7BA6D397A6B7ACD24114DAA2F8A6563F5050DEA499563C06A17FB58DC3E51F32
83B609ACCA06ADF071EE5D9EE66CB1C6F84E5F16FB96432A38D4D09E278D619B
16544D5E43856D32D4C5FC8AC4D29EE34C791AA52F59008CF04F21F30F697536
506872B3C1F09FCE72140B15BE1FEA8CC599C30EF025A876D72D84E24108D4FA
80BE13BE199FE1A3559EF26E1D624917AABB4473C730E1CE290190456555DAA7
14E9DF190A1EB9BEBFF5E0B8C614A36725C7A0678CAB7EF2CAF0917788A7E5D8
476DE8E213826D494864461E89F9399252B2D0F2E33023013BE174050A368691
86AA71F0C1ADF3AA8290123A8B67E6AE0C769C3AD2D7AA13FDD13235C6D10891
6318648507B20B083FBC2C10C7B5EB22D5F83D6A29C4C8F8836F876639D11D0D
94C2F28359648418FA08F3E04238FFE8E360365C9A9D3A428F4427086EC8CCDC
86509FA88537690E4626BD68BE331948BEBB489330CD7490C1B9B07CA69C233A
BF6F2C7D48890DE902DF4BB1159FB3C76525FB088ED2F4CE9BBF3022171B2BE4
DA0275BA7CFF033B73C1C7B49F9B9D46E03C2C0580E5B08D778D1ABDF011BA71
0A98896B7E94E8385E6989649B9C394099E3991574F2E11716D07DE628A7F68F
BF06D56EF45BA488F8AEFEBB9877F75637FE9F54BAD880A38BF73B72A08BEC2F
7C6F9F7BB862DE9557A5DFB843FF5E1CD93A1BA108DDAC0D9A91D5D52C0F238C
C78250AD3310E722891032F2276B20DAE2A21245B47D702E8E1FD0AAD683E7BE
DD5DE0D5930713C27757ACBAEB095ADA7331A584011217B1092983D248A24D90
D6BA096F92EB7331D53A177C00B72C4201BDE3C7EAF34D85C0A176AF593ABCAE
016A654A94FED40107AB05224CB3A8D23FCAFA46855895F6E4B6A19B305BFE1E
244AEEC105ECE02C576E9A15B2FAEFFECC5E883516CD551B31D1607760B62AA5
A3D359C1C0E0FA504D49C2FF4B7DFB107622ABF7B04346FE2F14BA35BB6E9431
F02893BEBDB65521D0010402575DAFFF833C4D59C1941D65B8D891A8D599425D
869F75A82E91082947E1C5B7625FA2BC95AB5A520D8565C4194DFD2AE7CA7B61
FC05F5F1D631CCC8CFF4B5B18DF2ADF12B41D29D94F0AECE9781D01EB59BE5D5
D3EA400A36EA914EE2E7C2325C2F00CB1EC12A5C247FDD3909099FC43DAF5327
344CFAFE0896A9B4C02062BF0B1535ABD3E960141A4ED295EE8058962F36ADCF
F171DEFB5FBDEBF16A6972588478BF941F1F70968F0F5B4ABCFC637803167EA6
E1027FF8BB76E9A59197CCC51AEAC50B3D93C7BE15407405843BD3928C4691D3
E6D6CD0135C4219272E5AE63530484DC26EE40A2448D4F6F1B050D844A097861
538E91C2566FF6628884ECE0D52F99B8FC8A95731221B246968C140D2F151E7E
458D927891B81ECEBE284A04795A77A62962501FDF15CC3E67E2D94C5B60311F
1F375F19F7518F9A70A46D637BDEE075EA9BD0B3A61D6A019A86C87326727AAF
4473532869278A4A831B2AF76AEAF89AA0727267676217EF6BC4A7D233105724
53CF654FA8A6AE4233641F0A0E5A6B91F46DFCB5A8FC9C061D9A52400E969229
0B1D0F7AFEC1F48CA35D6DA4CCC8C10E17C86C3EF1744A58E04F214C6423539D
2BADC3014DF95BEE0E61B122BC1283D909B401B23147286813E5D13431BEE01A
47B3F7665AEFA05EF590DAA6DDAF421E4D6214161968F68B0AF5D3FEF5006FEB
5427B2AAB3A2C4C5F6A2E9ACDE3B34037EABE0D13A3E2593B4F664CD29B5DEF9
33FA301EBF8060B71FBF4568A992B98C0B75461AE00226B5624DC375E70D8DE6
58E36E1F703902199AFF71F26EE8CDE7B40BAEC9508B2D8CF8ED6F7154C50751
10EF28ACEEB254684BDFC9481FD4C20ECDBDCD0E3C4369595CC2D45B2E06EAA0
EF1E8951B22EE495A72B67CD9E6B11D7F46EF17452A1E6CB38E053FA86C9DF4B
AA612AF0BC8F8D8E616B0B703941A27A62CE38A288C3241FFE3A03E5A081D25D
AEEFBE63D608906A9C1E0A06A9137DB417D7AB8475BCED9343F03E796D2A2779
8AB824CE50B15960C8F88E1A7D8E4DBD7B8E9687151AEBBC2F9F7C4243D40BA2
C3A7FF70A2F61A7B9920E7D8A5144EB828CE0AE5AECD9769773E551DBA5A527C
A754F912B3C5380DCF935CD32F05B4EA556956099759ECCA96F9B691ED33E644
AC417A1D1F44AD2FE86CA01D829C474B0514299334530DC8D3A3F1A8787931F6
1A705F34B65A7D17B8BE932709F98705723A5D49D049F420266F034B72EE3B70
7AF899283446B177BFFBD9B94C2C008FF74A20138BEB2D088783D254165ADC4C
980F349927924B24C11120970122E474CF733DCD48BEF8AC77069D6422E471FC
914AB7547004E8EC37198D72FB6D37A2002CB4063C8DF4BFF37564FE33F12D35
28982AB36542C9B8B4A721F0990192B87C7608F42DAEAEA472CCC2E8CA1C72BF
0CB1C8B8628EB05999BEB3A4DA962F105206429A3F12271C17CCEEBBB7D75609
95C7DC5B260F29B5A972BC3565A0306613F609EDE4C7590B7AB710A8CF08157F
21D63C144FCA211F81404A39FDB273B64ED685BB2F05E6532BB840512B9FFDD5
4BDD8C7F84484031FFFC0AE8932A6455493755DD2B924D027DD0BF7FF0F7BBC3
2C2A97754C8B7CCDC8141E6E61E725947962FF04737FC8575F3CDC1E827AA575
0B4ABFEDE5BD3932133425237898C299A77F4EA667E2D60F516F319BBF97F411
6C45E2DFF3C1C3E7B67824F1F3EC516DD5D84026EFEEEBFF875DCF2ABF081F82
BF0164E2C5000A4A1151BF42D264195CD25CBFCB12CEF58273EFC333228594EC
A521D0AFC488F4420CFEBEC8DBE3831273356F2A6AEB209B5AAE73A04E1194CD
EBD673BD2C25E9064469EB7E4DBF2975364992B3996EA3B4F30C40106141EEBD
CCF13767A1D3A0AF7BCC25BFCEA010E023A2FB117C41C8CBFFB37751AB5F9D5F
7E685C44F5AFAC1CC00F6CBF6BE2576B43654C207F12B1FE9D0800C9DA440F8F
4DF4706BCC6CFDEDC298DF2EC7706E9F77C8A04B529CC5FBD3483BC46BCC1E5C
AB15FF190A6E7333901B8625E9502376D42800FFA858182EFCF9911473F49981
2D37582A26DBE4E07B238A0C8DDA24A29309FE80416A7C9BB1DD8636C677A23E
E935CAFA5585E899435EE75109F168D7B2CE44129808D3E3E850F046708C6705
0D6C554509FD8EF3D10D216752DEC7424861C13D57A329D35BF82140517840D6
9973BE71EB2DA9FB58AB98309211A2560D9987FC1B454037C7BB317932882AE8
2292FBE44F6814AB3ED796B8189A3F739C72975C388195E80530872F1C653843
A05DCE23E9D6C1339D085BF92634D63901080ACE7A8462EA4D0A2E3CE3EDA1EC
59EE43FA58D4F24CA9CFE75AB6288B531DD76F5B112B0D2F53BAC5CA95AF81AE
A21D7773B74C3FEB1B544F35BDB8AA0407756F5286E7C12BAE3E8C0DC3C6D2CA
6E03CD0B39180ABC215C3BFD23B43C50E456FE397D0D3F8D2FBA00AB36DFAC8E
4365F5279CBC6F58558CFA0569C08654914FA98AA9AE647E4389C7EA033D7383
B6AB8A61737CF35E3FE28D717A65BDAD7BDB00E9BA0A03159D54173C987AC694
7E95279C07CEED888552651930635E620D5283C7C7C230789DDC5C6C5A4AC9E2
1CE0ACF1C02A9B72F3C264E038611A523D4FCCF54A0886B36BE8F6E9775A927F
2EE1FB3D816E6A00C6D1F4A994FD05DD0D2954B32F80C3725D45D05BDDED7997
5DC15BC1DB4D67B315C4556EA67CD2B3F1AD7905476C504EF844C1AC761A8CAE
6F42121173B82AA713E2450299226C6327DF4A395D8258F3DC9EFFE62BDA524D
48E7EBD23747033D48ACB2A66D41068BAD5ACE0F67C118B6FF52B74EDEFACF2F
EBD7C2D6F9BAA9BABE08CC299D2DB55B4E010A8AFE5E14A1D39168CD48D92671
1FF688DC78F99C0DED17D424EE41CD8ACA6AF07FD555CD82AFF8C527E584BFD0
A3606D42EF3DCC5A1E7D1A6FF34F5A66864E1A5304D5A581E246C9CE5A0C9B3A
2A9A5CDF3344CE96F6459664E76A78F34C22057A7C08553D06B97A2B6480A82C
DD0D012CB2A5AFEB2A3E5BE9EDB8499525589FCE1C3CD88BDA581214487E67AF
3608547FCC3A877E6B4E2C4FA45409B5EA00D67058D7F4740428ACB2112F3BB0
B88FF7EA11F20AE077B8BF4FE7D7D4DB9A9B38C405B8E6462FE28A205DD51DFA
AEC3E3B96EFDC740CF4728A37CA5A2E21E0D5898C508F857C5ADDBD95AFD0B9B
0B02296C98B39096103694319B70F6733BE3C874C7D154A921737C388E7B1304
62CAC1C61A49133B485B551B90E4C1C49EF40DFE1973DC8F7B8C13508DD56974
529CD78CADC41D9815A364DD46D9E3EFF32D693EBBA9E6A7D63C4EFCBBEAF271
68074F3BAC5696FBAFBC62DA227CFF0651F978A0987ECB642E80C30D303B58C8
ACA3A8442E0B017F5EA6D4D3E4B30BA0E9928480542E28B4B936A100991B41A5
B9C1A6DE12F22CD9D3B8E3339E2B945AAB62C357C5E2A41A3BFA403E58DBAF89
0F5F886D61E4D1888F235674F42E77171147B1153F42CF132A910C08682927DC
B0D682BCF657566E28CEC1499D23FB6088524E37DB950A113ECFFA56DB17D0AA
4E5800D626CC47D247CC610668FF164EFBF2FAB4C3B4DC9A68B2966D7BB767D7
1155AD4338BE2FD18655E5F7164D9AF89DBBE3B49616C51E8265379ED8DE9A5D
675BB5B31EB70F31F472166B18FF30E1425EE578CF00FE26DDC6A9B90EA073F4
3ABA5F311D405E902B0C3C140E6405B256460EEE3E5EDE6108EAB8035E0421E2
BBC262C5CE4E1E028647DCBC00B50605C17BEB2D8D71F078290B06FD7F5F2942
F279FF9A0AF45C4AFF75F291A092B87EF4B964F7225E179DF831465F81552A9B
06238965C8A126E42EFCF1239EDF21F4748762C41FFB40300D9680CC4B048137
76A3451FE65A47D2E8E2147C9762683FD55DF3C02946D1F6BFD80F3D50E1CA6A
8EEFDD3CDF340D92FC402A0E4994D2CD46929E756E80659AB3918E184F439BAA
03A931467D20BA2D391DD736F0205FFDCC48211DBAB0B71A45D4603C276D6E78
AD8318094CD882CB216462007DC4C52E4D5CE3A9373169508967A04C572C94AA
6047C1960A223B94F37F2EDA9404CC7832ADC486BD9CC13052A01EE7E6E11EBC
34A4116072C871C1CF07223E1A66B4B070D75FFBD784F3A5742785B6EE7382FF
87F09D88A36C95C022FB7D5245D6CA939D7C3B294AF942A4981CD6E36402284E
10E8FE6D8A8310105BDEE4BA78BAE6ACCE7BF738980A0B7A3046578E66FC7C8D
325D4CF5124321128843DF49C84B14BC885E57E07CF0A0966ECF94F269208FB8
CC6285704503BAE6B6A51F2B2815E0E88DF52A554E02FDD67275C38DC7C06D21
CD197B4C7B75948DE075B321B73A951B8047E07F7A01C041D24ED01904D139D6
C7B9D9F8935AF23F79D58C76690B7DA5C459745FE58568670377A83E0600FBEA
CA995E9A678DD32CC41443AC87D3AB3883D676846787A59D4494EABDF708AFFB
43BEE98459A5F2A9104FF57B7EBAB515DF56E83B525299D6B7D149ADB2FD8E31
2D719C507DDA1BF0CD988B639F404B58912C8521AB6B8FC85ABE9B35971FD450
5F3C77ED71905270650699A9C3A661380B911F3ED8BEF5EFCC301097BC0CC674
10CF57FCEAFBC46248DC0E1C43C845A1936E01BFF6E1B441ABFC38849397E54E
F31B30D6C00BF5D83A18DD0CD97CAFD012B866D4B8FBA0E28D9642BAAD16670C
DF9621FC9D432C35A47F3F4D690B31E8F6E7665F24A93F4754E28F4ECADBC97B
B43F687E2003D74A25543F63E46DE52CC01A232C2456EE913CABB9B2A1C9A16C
CB0A12CA088220D7CC2B4F8940696EAE0FF8E22E698EB26E8171A2820119CC67
3B84AC595B4E3A2CB970503C12B33D86F9BFB8222C59284721E202AF56F30701
9AA8FDE87A4B7F484A55FFA5B83052AC23F4B3644234D920AE2678F0058AECF8
482A8F9FCD33BC5F0C3D63AF49BF39FCDAB2F8C2DF4A64E655BE7CD174065616
4601512B6F890C9FCF40E7E8AF25AB31DCADB49DC2FFAD14708B3AA0108574C5
FB78BE0E8615EACD45673984D60FFBDB8226434DE576FD76BAB100EFAB81CB6F
355F598C20A5F70EFE840959AEF3E34287BE6E17CA0E265ADB289EAC3319CA42
AD0C59D2368A1C335D3D41A7F69777B0BB7370E5C2A77AAB62822B233BD365A8
96A4B67A432AC5F5CD14E5A5E178DD9CC413A85FD8337FE3916FE43E7A044F65
80B4AB6D256DD9013C4B13F7C69B5883AE06A6E0080110E429744B45DF03D1F4
455E52046DAAA02D529CD365B2C1DC5EDD1BB6F2722E25C253DF7CA6305AD5DC
1A9A82BCBE50351EB77DBCE0A4B14D4150353B1486EC5FE8A53E9CE8DC727446
020AB61F1CA27ECB4E791605D4BA0CF6DADDC996E9EDE494ADF51C94F0B51B02
1D7F0BE74E1AFE432BE531E18055CFEC205BA9C60270704BB6069AF546BEE313
6A197807FABDCD9940A0FA580A105E5A51758F24EC0CFDF51381FC3285A4FB83
DF948319CC105926071D24129C3DDC08B6A551B0C0680CC357B350D466B4D20E
E132FE168BE61D4FF9513551F53DA7BE791B44427DAB18EFCE389A6D7CBB108D
65523FA151524667FFDEE2AF8A301055733960AABBD0ED0C8DE7DC366AA36A42
68EE93CF6FE931F6B51635ED4460D4268525D3EFD9895226ADFCA4BC84D4B664
17DE63DA1764C64E0EA585430312744517BFC425440BEBEF8679AA56B19BAA85
4EDE7AF20228644E427215C89A61A723E17B33484A4F187FC41B93F4D1AE0363
E713E8E574D03070BB8925E0FF0E2365BEA16007BEED7A83E2C3D48DACA913B7
7932132FBD3B8E90AD5FFE7179D2096AE48F387E2523C39EDAF5CD7F0C48A175
105E60AE0E07D48E52A869C40EB55CF31782DF1A216557952E53E9B9A49E49DF
90A6AAE92EB1B2F3A5B6447B535F38A7FE08025B5CA336BB3B2D9E1DF62EF184
6CA8502C1B05378D9240AAD686D592A01C31BADEC903BB033FE869995D2E40F5
D71F7F24D2EDFED3CD64AD297EAFAB8E23080313F0F8FD4F786C712D9F38D936
6BC721721489EC703E604FBCF880215B4D1ED011A770D4A171402415EA283421
2A72336D6DAAC949C147AB6CD01F38CD21651118E9173233EC2071BF8BEF3DCD
678CF8164BB3FC154CF0549CB35784DE1FEFBF34A9E2891F394EA3003971E687
F7D855B5191C42502DE23BB0D83302C24ED18B312145C60379E3200E4ADD0F81
1238233B46A65CD2056F6DC741B6D309D7273C28886CAEC6BAF51D01EB94B91D
CEE5E31CFB6F594D326D48E679190A0FAE0EB69ECD221A985F7377BEAA49275B
5E62BC871BCFAE9AB6404EA756BC9177F6308978F8DC7055F1F2F1307DF865ED
AC9CF9FBAEAAC3B3A5CC1C9744253567A7830362372F09E532B5C7659AA3999D
8CA1D3941D1FF042DCB78343767F758B40E87EFB947F6EF31DCC61CDDFC39A27
7187600E1B1EFE2961140479458987FFE44E8010F5D4D89E2EBB9C093CF2C222
DDCB85D19E179DE6EEE684BE3A79FB88188647382BE1B7891A84B9697E22FC61
EE575566BF309006220706DC806409EF7E5BFD966C2815E1A1D86353785D6EEA
A6ABA1B58D3A468B718366587D0F331CA5F267FAAC92EFC1494640BCF0294FF2
103926BD4D876E927A6F436B823B1A2FD914DDADEFB5C5CA3A43E3467D2D0EFF
B92C9AB90C293E955BD720ABD69BA35E8A7D574CC472945192DE24DEEBB4F827
D1310D29BC1B88124571938317954D112B3B2D006EAE46AD967AA19327C41F07
A030808019C4C0DCBC45913DB4B59EF85EF3676F7EEBDA515B4EBE13E394473D
9CD281AF0BC516AE5D6CC4E176544A47869A64E63DA8D69A1F19CEF2A45184E5
7F4CF967AE0084387B52C189DD11831536E2F66A2B9F9683381C56776D27F95A
A0DBFE3DC5EB2E65CBDF1EFB707AC25F7C9EC4EFA5119A14CA01444ACD693258
A53F98DB0DF475C8D74928A382A4573950C39028C333EC869F439054DECF38B5
F6874108F90A96C971445D731DF9B83A7A1136A9CE87477947D790FF3BD138B0
559D3E5887B7EA9C9C54F8335F55CB0E39375DC205CD8FFD81E90BBF30579F13
EA06A36999A7BCC865179B3FAB830E1EAAC293AE37EE0993D38EEF5C7907FADE
B11CB8C655A72354E2E4E58D9E14368C31FBBE5FFDEBABAE351E8C3FFD0625C1
9AA4D6CFA11088344A00A34D9C9FE7C934E128DF0B672A5D06DCFB4C63EDDBBA
AB57A2D4BC94024D032559F8CB38C4494FC7AC2B573C3792E45CEE23C52AA384
A34CFF9EDA896ECFFB9944EB7EEADEC7BD012E823A34E6D8C9087DBF7F8B7139
ADF77EA82BD3657A1CC1020DF70A1E14E4237755E709E57EF521EB0352293C8A
D375A9659C9BDE7AB4E75036059FF34C44B350FD10C3E936AFBC26911A8F0D43
35F9AA9F42C1330C864EA2CBC269D90D21B62674F16AC59608F55AF52A70D79E
8D2B62ACCB6CDFCBAD9EA9F139614730D149FF456770000BD0E0EF2732861F55
74DBB1C71FFDF7DA73C895B284D2599C82C8FBC051E8D31E94882F4F1AF90C7A
388469A4AFE99F2BE5CCE86EF8B6EFE3C6FAC13A4F0786FAFF6850867C9A4650
7B6949BCDB9A568055E7A2915DAF3D8379BB7312E1C6950255DE1629B14C11BF
6D56A1F0B72D203A7C5FF3017508DF9821E2D1F9C0A1B4E3B1270C1BEB1C40B2
15518F7BA93F949077546E40E97EAF026E613F09D9BD2FCD2FBE3811D5E261A6
C73872587024DA9A7F1696ABDD8298F94DB433419A0C1960A4B0727CACD93ECB
1580852356E5585C8EDE79192858A97010D790773C39CF77AFD2E99CCCBE5A45
48C1ECB709D4FD4BD96BCF8A5483930F2B5FC7670608D071261C1FF7133E89B1
75C6A748085E4200592A259BC950CFCA36AB5116220AA648F5E0E43189793DC3
BF4DE8F6C8FF068E138549C9CE3D95D8EF19C7378B759E2635AF7B84C5D59D68
548C3966355B70442F1F05EDE4977DF9E11D75951B186DF6A9B62A7BD1774161
952D462620AFCD9D1A3BE3D924CFD804CB1B33E802732D4B23AD08E64CD0EA50
8DB893617833C8923093E69C079DF7B66876301AE9D423EA39E046EBD32D3867
DDE5345EDB2566546343C950434F1BB411AC59EBCCE8609D15F3A5B2F5DE09DE
97537E792CA83E631A240887FEAF840A325D2D4ED3F9DB786D7E774214C97E75
3FF3E432D45103C7E56876EF473ABA5B021A1598242EDDF42B3B38E0F578D8D8
A1218B9A2F83F114C6DB5331372CD9A152005A82C9BD0D6AFBFCB4548C367509
157E4D9109A5C24FBBB65155F6786FFBB998B5175764E68AF9FE2FFCA3055A4A
032CA6EE62D04B060453F94317D02D74E2C2569CE43D4BB95CF70387C6270755
A3BE7042F6E114D4F54D4DA84DF20998014260A53269FBE38672FC59BF417AB9
1659C255392A89742025378CF853F6A8188534F6EFA2B357EBAB1A189F424831
F6578541FB21A36E4C6B81A054352BFB4D5E3D1751ACBD8540711CE3DB29E8FF
B4AD0E732D6D2F0F976F82A90A3F62C66E4E78C13ED8F4FA88FC206541500F54
B6F1238F2E2E9E6C198D51476F3EEA2F7198E5C2BE2092A692B114CDCF9AA795
21F2CFEF6999F99AA0A2A7AA484EA1B609F6A9259F92472E432712990194A6BD
FBC7AE99E54D87C8AE7446DC3A74512FE0F2FF7860EB0D311D96C1166803871A
DEE2CB97334C924E010317029FBA387EB4EC4342152F983F5144D00CF5CD4E3E
4F05E0FBB1E20E39B9DAD74226EFC5012096BBEA5AB5CCB5C196731EF7E1D0E0
08FEAEA896271A3B6DB3E7D2AE858A1B9980375599E5A0DC2E700FA0A721748E
0F4F02E605F9EC6EDDC1A883F9132D908BA2D4057EC3592A03E259D54CE09360
E8852F4971361A279F53E8F12EEF7E17116174B7469033E2B7BDC7B7C3A79117
F4F747BA9EED48611385468E6622FD6CA218A1CB03FCB945FC24376A45F2DE0C
2131D0ABA5903F42AFB4E19A95C7D9B71C7D637420B70C1CD51750FC5006E25B
A750372C86A036185BFC21BF8409CBA59115FDE6ED9138A53B0A146FE4BA5914
0DADD4CF4BA1285C9898C63CAB854E80B0886B08A72B1D7674BED5A31F9E4B2A
07ED6A2570E21CE75B3DEFE1A57A0DC8CFA9162CE19BB855E9BD68C4C08028F9
4D7779930DE6B3FF0B883A5DA376EF198EDC459F85F1A17907B9F9D06BE66041
C00DD2FEF834AEE3FD940A7592F91B84E1CD8607195141C582FE8B7BFD9CCCBE
1BFF77D3834607E33F7301AC5B13C3896A6993B02EA0F73A2399F6CA5070D2E1
8CC12104F20319333FC06ADFBA741F9A9E0FDDD9189DE5C3F2A05C77B99ACB56
6C43D5774F18A1AD10A9187C32D91D47628C1678A28AF61B53AFA57A14B7F2D4
815E0733979B9FE7F7EBE3A4C35AE1ABF68E252290848C9EA8101E3E1ADC08EF
8EF7902E554313A1F515FFB4885493800C8236B1858FDF5EACE8A5062C82E146
3066E2EADAC0CD2FE149A71C7040457157253E92C29498A23277FF1EB9D4DB33
7D73711E8FFFB971C914710BCC44C90F9085E0C5D8FF88DC14F783DC0C72DD97
51F77D61F516E0E4502C8CA200FBE93AD8048807DB203C6CBD81D6C4C813DC72
D7DDD349030FA665E81EFA14E50016CF96ECF148A8A1E8BB212C9E0EB3AA7759
222A9F55EA7712BB03B500BC04C5AC8E8A45BF0944CFC4A423BCE1E467226AE0
B39365CF469CB1B7518786EF38F5BF06F73DF53FAF013E6207BD04879542CF66
BB4C006E141302BBCAE765F2778C34894E192B68240A1A5D2EC97518BF3968C5
15F2D6AF7A70BF2427A503B26056CCEDF294BF5042ADCDF0B0AF2F35E7B2004F
FC3E579C96D321F56326AFECF8E97444753F21C4198F22E9AF223B7EA064DFCC
E952BD014A5E96679ABF0A92AD4D104C87151EEC9CB06B3771F1B019073774C2
0ED5B64EB4749884F96854C277C63649A9845BBFD1CBF47B9DDC5C6C5A4AC9E2
1CE0ACF1C02A9B72F3C264E2AC2A7283F6F5919A2893BAD39B69EA53D3EE0802
6C4FAEA75B361BC6584603DFF5EDFE3C9875C463C7F90817599278A56566C0FA
3EAC58EF223BE9ABD14475A2737A23D2EB8ADD66D78B93F6C343F097CDD4BA2F
320BB2120CB86DC49354C91BBFF3FFFB68D76FD82C062904F9BD09CEF33DD42F
91276B46C3FA9956F75531F04161B2C21F34CBE80DE64146F26AE6465ADE0940
2C8FFBF26EB6FE3663ABFB7F6C88A6A1AE0EE5062E73519482F277A77E7DBE54
16FE8C7D58E2EE222D4B369FC3919EE24B8CB02E12CFFC2AF1BBB9DE77164C5F
6B43342A87FF745965DC919A12B63D7673DB75A9C68788CEBBBA77A4A812BFCA
73A8E3CA36B075269BC3089D9CC68152679D99FD6E52BA3B7278495127275A2A
4B8B7AE71A3F43E96008CB005AA19A871F8368269BD77624310089E127B66084
21C01A09253AE98A5DA141BDB6CEC4D6BD1AA08275E1E7F657BD8752A46D2AF7
EB3E32938309EA9571B30A9F74E2B52727F7BBDB9A9DA7781294F18B5E7ED330
B352D98EA20DAD98F7031C0CE22CA1757A9B630AAAD6F1CD463AA8E928FDC815
553ECE4EE8FB43AD7CEBAA1E8AC903FB1EF52F939E91730F48DC7AD013DF4548
8C62D0F2D5E093CF83719DB078F5BE10F24A5B45A92D890A2A81504E7E3BC1C7
6E76BDB6DFF9B38445FEA48F722E4EA98EE272B3AA95D4B9734D9FB7982A505B
F7B956661666684C07055FE2A3B6D81785B7918E7033D115F6E002BB180E9906
8F4C5E280DFA90085DDE580FE96DFFE2645458F781186DEE74ADFAD342869083
492931C690C72C1A29F4281D5658996F0631FED4381E84E9CFB625798CC9E10A
0BC4F76B681E74C628238A033689008DD1A9C0467D8E4377D75506A9695A998A
49116A09BB7F320F0CCD98F2F7DF378E1BABB24284F6B1523DB565BBC3A1EE19
170598C4E94B5A824C957E86DAC64E60986F5F5A6A5DD7061E26D1BB371D5606
31F2390CD4A229C2F8295C759A914E6B1A86A53F2E492B3781D4F31C37233AF2
02880CEAF293D11896E3BCACCC6F85A6E451B29B3AA9BAC4A17EB9CE2C7E3EF2
66C9A08AB0A74EB7D2CBC6F37664F4A8D08886459A5752B2E25B0DDBBFD3C91E
A6FD21F1AADFF3D75ABD9EAF321A2AF2256EA0675264922F9A98E6FBC0F57DB2
EFDF96A0DA8A349322561774A46336B100F5654D47A02F868921AF5438A780AA
5094B9437176290ED45EBD01906D59FEA0253535C8A6DD2D07F4B95CA0B019FA
B1E4AA470CFF413429B3CBDE2628B4A301C4AEEEF5B0D0FB8B15431A61AD9B26
CD69B5D7D2B2ADA203EF38F028CD3D3B279ED66EB955E260AF1DCB0E8959857A
589B7E96EBDB545806ED3373D16487801F7A6CFE211D8B45F268AD600D610E32
BDC63998EFFBD8BB34D2423CC387D354FF066474763370EECC9E1E60195986EB
4C4BCE42AC82C2BF34FB77D107652BD59E002C56B3DD423BEFDDDE4100DE4FC0
86BB21AB7251904355FDC5A27F9349F365BFBF3AB63819BF6541E73737B25312
E6C66A69FD11560F9F1980A4676D23FC0E90704445567834CE229AFD6C5BD191
E2FEE105BB5D820CEFE2412AAFD440ECE560A28F181960569352119833995EDA
4207BF15B4BECF94937CE559EF6B0E5F9288C410487290808B88F9421D506386
AC95C3A4E780B78186D7F391CD91B6222E88C0BCFF662088167DB90C3C494595
5899DEC9801331F563B43F92ED5652C5648BAEFE8DDEA9B0EE3DAF641B54F298
A7AC2BC1D0911ACCE91EA283543BFC3DB49AD1D6E8F6EE39EDB8512BDE5022D4
0F805121D2BE59915BD3677F1A9C4E463C6EB0EDBD6387F248D3DEAA67D8ED7A
01FBF6389252B73F1E4CDD4912B3995A7DB9B4C56C828F8A8F7C5C6B40C54DAC
21C52A4D4991997862933CBC859E9595E8F741E29228C49C5BA65EF7B6D502F4
F3CD6942AC9E75A71067F743B7CAA3D8415207B2A64E0CE5813641FBF24FDA81
957FCD77E455C29BC299D4FC801B28073B7AA530ADC5126770338E0B37511CF3
AB6B7EDBB237ED747AD16E7C3D02E3D9E60528611520249698A92CF23C5E8F45
272A04EDC40CB80D8452F4D244BAA1E3B282FD29E62A823849AE2B7D13C56D13
65DA81125A10EB80E6ED8D5EC2F0D27449DAFD5731FF7E0F4C5C5F208770EA65
282F1BDCC44C50A7FF5F8BF26006164709596C0E78321C9CB5060E3A73EBC2A1
3D7C9D53126432B64FCE66F3DA30139CE1DA1012BA4E5145299F34BA971F8F5B
E7DBAD7A9023B62FE16477C573234F03427D0C1ED0639EB5F8BE135EDBBE3BF4
ECE63F06F40DE3CF091CE3E48E71813F2C217744EB750F2F3009708F24FC4285
9E4DE066C571FB44D29CC4A5AA37A99B532607AF0D8BF807D2BDA659CEE7C94E
6B1552C08F8C831C25AE365EA7A44553C0A02F477E6169355E7DB7A40C265DC9
46EEE394D91E2AD22DB3AD036B1EB881D8AAB4A6A5A2A804043F5D31AB909CF8
8D3A429D9AC37D58011A97291A35B5A1EAA58C8E135C5DBE19ECD7851035CF09
D861C7964BEA151336168FA3FEC3A59203A9B6B8CD3E9BFB356A8CD7124C1197
06E8F6070A92ECB856495CFA5AA1B2912109796C1C7ED9476FD94CA6A05BB8C3
A1B410532DE5BF0DA704808D7B0878A09BF1DCA7218548D0FEBE0CBB445E9DC9
9DE3BF32B95CA40F19FE0EEEA84E8EA0068316D0DAC23D6366E798FF67671C82
9F078F248D7692B21D5348E3F6FBFAF7313B1FA589C0DD6CAA6D26C75C6F816E
62D99AC232AC9B5F97FE1B129C727D7D1E05DA3B72EEC9C1B38F428A3ED9EE95
AE9F340D58A2CFCE88A8F9A12D46B8FCA50DF4433B0B8AED6A63BD33B1A2993A
B5D0F5A7DC3BE3B885999BF8DA8733528168E9ACFB570D76D01209F22F4D026A
3744BF5BA2E45F808A44F6F225FAB6045756E1D6148F9BE2064A3764637B6DCE
035C96174DE5818862B99B1F17A6BC6F37AB0B5FD8098A9C316D33EA1C1C409B
81C4838F3CCBDCFE64C8A89E130059356D2B2CD44371504CB3CD74B45B721196
3E8D89445D7B7B0100FF63D6A146862DC40E95DCC8CB8A0CEBBC38EE8787EFC7
FAF8A4D10DF88C738EBDF0415FCE77066A485F3B1D0C21299E38A93996A0EB7A
3357E3A85949B289A9B088BD9EC3B6580F2817D63DE90FD710C418BE6811C470
71415F80482FE2A124DF44AA53B9AD2E903C9AFE56E84319D57DB99568F16546
47F4462F88BEE480D315A783BACEBDBC0C99138A5015E0D8688EBA2DE0D90FE6
5933205B560F00F3D862C4E3C59B14C9738F6AF5989022DC463B75374F6879E2
B078DDAA6B27C43396834E36751300AB9F9A364066A829619C268D692AC008C4
2D510A67435DB54053EF2665CFCF412B99167152D35BC0E671E657EDD87F0869
A693F7C422AE38DAE2C990FD54BE878B4223DD818DE9BED36EB2C52BA18EF531
DE09B52B7093D785F43437257019ABF0B3867EDE0A050E01AE6414B464A3BC2E
E31AB471963343F2ED6E7F4E332E95D926FA14CA654BF7198304A78FD15712A4
2783DF3484CA36F6027A26FF421BFCE5DAB2D853767FE8AB9FD459958E895784
B9D744247FC4DD5575318E1A50DCA6D3A4967C8D4CAAEB97FCA86D77E3E15043
9D42F68AD56967841E1A749084C0602F13B2F4140A0A7DE08275B15E485E8DE3
B310E8DE4864B56B115A9F309C62B22671DC819006D1FF3412D504943284C165
8B6FF324C0F0C5BFD68D4FC3E80AFDD7EEED74F66BE8E8A733E4394DB1F7FF44
DE8B99D6205FECE23D72A9F61619E09C929699C371BEEF45014EE987DEDDF072
4CBAC3C084F337DB3475CA29A6D2542B80700905407541AB354334E7C18C5D66
3B3C05B3BF83F04630F70FADA344057138565B858ED3897B741D8ED7C089B436
0CCAD0A918985C6DB6F33842F755D54A253FB2AE3D37EEB7A4F25624CCB6531A
EC9E3572FC29CC7319733165F9ADE66BD0F0A7165BE3EA9261F7BAD646B37370
1920E63EF630C7BC7A03BF1C3904DF762C6D039B17A0F47077C0B5C2956EFFF9
8DE3CD4C7CAADCAA16EBC63484857FD06F20842F147FA08501D58A8335D97B20
2AAFA64E2FCCADE06BD83F64C67D991623D3958CD2C9AAC9BA95BA57603A82ED
A30BCACB9F5B9A26DC0342164CB04216FDDB33747D149D67F242B92F71193D20
4C1179E7E5120F911D26F787C725AD12BE0DD2A5B6AE12B9ABDDF2DA809074D6
DAF191A323381837AA1047B0DDE6A359C0EE8DDB1950B365A8A28F4E9C5CBDE0
504C023A8450D821B184846B76AB69AC3CF11F513BEF0C35FD17808A1039D064
44FA5C990EF446A30009A7DEBE36A84A818280591BBC29AE365EA7A44553C050
4A454BE5F6623ABAFA8E009A8DE00BA006A77302FC8587FEFB9F157911E60BFC
348713AB5978361D83B9D6C514372866A572B31491F9B2685A0E0B3E84FE5104
8A1F95C18A4F2EC340616C8302E61FFA8A94806AAABDA31A9C1A23E7A19F9ACD
C8671C062D77B6268B7AFB245DE6EE02BF2A97B0542A5CFD67A5D9E9700516FD
02309FC1FFB29C800A6749417B4A476E181E5AB2C2005DDD22E105A1F4AE4D25
29C9B9A1C22D8E273187F24F9D209D78E0A2FD3FA71C28EDFC15762F08A697FD
D95DEF8B2D573EFC2CBFB7C4F51848BFEAA96BC1A456DAD044021E04D419C671
C0EB19A35AF142622D62582BF4A17E92DFB106520F5C74630741BC6EB3C72ECF
BA88DF8D87F32A7BB5B06672CAD5E073D10EC5CDEA5B4F2EF6DCB912FF552089
F383D270C1312811BCF15CDFA0566AF29195C653FA085F712258B8A1B9AAB5D2
134B97F62FAC2F2E1F29EF28B4A46FAEFFCFBE7A85DFF9B89311C8D330F0AD6E
39865395536828DA89CD9B002BD09978B9B81878ACADC8AB8AD59AFA3BA845DF
5A00897A685ED01A153589B091951C019129420415AE2AC91F41CD1B73300A27
B80DFBB205E243C953608656A6EA9191FB546BB34331024B94880767CF3F09D1
1A879A34955D2E75FDB7749970F90B86DE88777C0AD7A055514B6A44044995C0
0F77215A86AB3EE576DA9DF5423398810F7246F2DD3777FA4061CFF9D9C1A829
25C7ED6218050AD00D19CFEBF7C899CB6DC0F30CF38F782C9AE599C3E8760F75
0493009BA9B13FD300A78B984ADD89182F5C3478C47BF8F0EDFC4ABF84F6030D
887AC6A64032139BCA3F65DA6B3517623764136A5FA5E4D9C69298107CE8AC51
4F45903E166D924992DF7E80693F8F917683909E55B7B31C9AB88E096A15A627
73CE160F630FDB3A5B477B14256AEADF217F5E4092D1D03ACD2FADCF192ACA85
880CCF14B26666E8F75BC669D6F157649340F4987821AA9A3831DDEBC6753207
19654F753822663BEA4C213441F6387E331E218D5F5B98C7AB87FD0C0106FA36
7CB1F0D710AC71210359986F177C33E5032432E7BF7E0999E1DD8C3FC2A00E05
F0D6076A34A4B833ECB0547BA75FFFF277230D34376F353D1C520EF85B456DE5
A541A04DC07A7026EBE9E2D290B1EEDFE0322838AAD2FB6B1E5A1600EA8BF680
C97212992BB2F5000FF23382BB11CE78AFF37D6D6BBB94B39D8CCC2DAD557200
C80A73E7E6545A736CFF8B5152BE94C63C1F84255758FF27A75159FA187CE5AF
2F8A4F93075F18B7457131ED416A23AC13161D6D32AF817E9B37405C2AD7E108
5D78394C4AC5F3161C8AF4879CEAA37352D164013DA9C1D285F153AB1F6B997B
7696988A9F2B3AC897A10789DA53D2DF6BC85D785BCDE42E376A4BF181439CE4
ED760F5FA3781BBFE93E0368715B629550A9FBF947BB7C46FBEEC434F4A67670
64EA4E5F469E48F5AD2885076AFE189EFD12293E90635C6028012240B94ED714
24EA00E5BC837AE533317E886BDA402F15AD1E2B70022462719D39E5C3ECC6FF
16E41E2BBFF74C518C728816A1882039D8F3B6260A7DDD22752E59733BE83E81
4C57996987119FF236B15371648F65179672434068150B6AB464C5FA66013875
2C9043F4BD074F11AF4F4C01751CEE39D28B2BCC74EA8110F7C0298DBE219836
441A3EA01E4E8D20A0F0284EC5F788E46EFB2E1FCFC4F780AFF44068ECE88EF8
CEF0D1361138EA6A07CE358D37C95D70CDC6F369BAF077BA71EF7DDE5E7D70AA
D835E4EBB81834478E256BA7A8C1E6C67A82C37CBA9CFB101F1CF130F5C9730E
F85F56A4ABE2DB565449623D7A616E67A5F66DC14BC10987FD1C7209EA67CD1F
2FB341F730CD7A15C217C7C2359DCB616F5702D1955AC328ED87A7C828A3FDD6
B49CD1DD3E845B5363AD0728E741FD78C8181FA210E408DFEBF7BBDD9F40D49F
A46D3396EB725275D1CF7C520708C1B3BBCA5A78349064984C20F9A5E9846938
0197A3484AC67EE13916AD53BD736FAED26417BCCD3683F82131967300A233B2
D28EA100066CDE17ED24A159E73A650ACA5D560FBFF1378006D473B8FE6C1E9B
7B8C002B0DDDF615559DC6D0A2E6E82E68402D02A541574D341132526B0EA0B0
09F23690F4617F95105CF9C3E937B85CF84701F2C5D72EE60455E053A83B4E29
0408D0B8665D3E7E225233254A7CB5AC380B1B20EC06E826F9A59B5C81A52958
CC222108068B915E245D24C4F05D7718BBD1CC09D1B8B407D791BB70311EF9D5
CCEB0FB3BB9528157E5CAA6FD96F1464D9563C2A90ADAA983BA13D26059B7E78
13738F3B885FE08CFBF052D1DB428855E5C3D6ED054402C44FBB0DD7F41CD8C4
564F3CCC413D2833B34AF40511C3FD8580292BC9D70CFDDE7736AFAB1BC7A2C1
7C4E651C41516F82477CD81D65B598880377A9137307FD44F4369C6CCF63B0E6
D69461F38D18200BF73279DBB6BB9DBCE6092C0B43BBB70E4DE3C31B971D7FEA
AE52BC1DEDF04786FEDC41C69FE18DEDF9D81C964728F4C848B3D64666D4C83C
374081979ECA823142A7878703C0538EAC62648F9D1210993316E9D6996CA9C9
A3149496384F0737D384AB3B6D4C649453ACF240CD5E1806A87793F7A42ED6C0
FF7AE95CC6FC5D9B4C17552849E69338F2AD3632099262DAC7640A6FEF29E7C1
8F3E6AD5BA4BE91F654E804E6838419F58E5A3D59296250A24D57006CDADE040
9BBDE1423697620885EC3707BFF5946479636D9B0C1D32CA277886071EC95798
5BA4794E68C333FB073C11CB50CF0358121517FD3D08E185575C3B64228C6E83
4991AF426770039CF85A014494B5582699884D87C1DD310A4CD77359E7BC4A3F
94FE289D03F8A593A3E2E9873652FA8C22BB7FCD04D2C06AB853B6BE7F59D359
C188F871F645BB84FDE693DF8EB0484B9128FB03DA76524780788E35EAE84C04
7D636122BD0ACF4379A85F3E07F2FC2383FFB9E9637D5747B57C4450E341022C
524FDBD2D7ADC365E6929D6868CB9FD3444AB03BAB4433658F68B2919AE1D7EB
D4A7F9875973B90924073C14453DDFDCA4AC463295D8ADCFA2BC5BF8798F9DAB
25543053018C38E6781C1BF4E179776A4DE6ECAC1175C9C2DC0CD0557587481B
A83A774529EF65D55C525379F58748F6AAB4291D443CE51499145F9A58DEB92A
B63A224A99C85AD380BDE937DEC6E357ED7D69B44C70AC66629D74D48CD3D7AE
548401061B7A9CAAF911FF1BC710BB99A44BCF3A576B47527F8A8A21E205168A
33BAF567D30093177F9258DE5DD5AAADBA7B8131FCB8D5DBF1D99268CB8F9D2C
5545F420F1FB1A00823A6293230C06EC9678F0992571426A9D9F41C2754138EF
2F3FD4EF021979EA39FCBB0CD48F907516276C0341C8683F716C35FE0A8B9958
5BC04DC7F1DFE431A1E412D483883A585C5361A54426E8E496E2576C00DD4B67
0881BB8F991D71C5FC45339BAAE826841521139EE17148DAD9935D15A45FF82C
90BA2A36EDC5187F04135430ED42BEC9C9290B664D66F813E8A4944C09B40371
89A27816BF8CFBE68F012F849329C9E6751417BDD31BC01DDF5FF256FFCDF706
B4561A0FCDE966E3767765669D0B23DFEDAF75B58D95A61FE141DAC7D369CB69
F3E3535D4FA687A7A1B92175D0A9FCB6A36613A7295DA37665FB2B035EF491F8
ADA4508409152DDDF7287867384D0343894D33D2D532F14AB3D845877A5C2355
865D542B654DDF5A818BF5C7EC37CC5DDBCE69B4A7AB3416554CBC87B64CCE91
2673A21AF57F81D127FF0C21B55C285DCF259D7B0BAEBDB91577B5DA43807467
7164892E88717C7CDFEF19ABCC95A41F9A40D79B32E9B106FFBF51124D286E04
C5432E2A4A9C3EDA3B2ABE5E00C8E484E6988D4EE57835BA4007321375D12DD0
EB9688359DD107F8C79E3751D9C594736360082D6A434BF4B1C8FE95E164997D
48EDF1B9CE640A2A935095D2EAC33A25E40F97B01244D4CAA8B36A21B11AE003
0E0094745D1CF8501D889F922C1CD5FF4E12564B04131F268D47DB534663F8E9
BA65BF434329FBC87B1FBE92AC773D6A0BB82FFCE83798FE9222EDE47657ACCA
9C04AA77587961DFF814246D751B24F162F5FE975D0DB14A5FF2E82AF19552D7
66E6F59DF28D3E2DEB43C413F5B4F1F785429A0FBE65E04071FFA0CC6DC20CBF
E36655C2842F5C7FD50170AE1C994C8774E1EA5AB6136C25F4FE5AF8C612A5BA
49B6BBEB3D840D90259CBA15A0A90692220E3763771CFD53026C9FF98562C2C4
D273563A3D1791083E7E46BE5886E2B0E8D1FE3E5A659C52A14C879061EAD30E
F58F42E5D143F71E11D71C22595D3A45A7F67E107DF5679DCB8762026222C3D8
0DC7ECB8BB1C01F099F417EA09EA55338134D2C520F09FA76E46744132ECE15C
B145C2302AD7DDC579F64A20A67B5F73F792196AB84D6F037953756322210E06
9F0663D7D88B4AA2BCEB259F56103B1B85E0D39BB4DB89091EEDB704175D288D
A1003B7626B5FA5F4D055576905D5DAE1A0F4304B6714320149241AAD4EE4742
BA18890978A0952FE1D4DD57E9BA5BC746A721FDD8E55D6C3445111A57B150A5
B386F740ED272D98F64E631B6DFE1F5ACF1455974C916A025447CB635F55001D
2E9A740806984105457539DE761B4B2E6B07ABA4C20BEEF311EF11CA4869F064
B70E31F5C9F75559ECDA94157E0F94414478C04A9E3B95DEDC99C92A90699F27
7A3B4ECC568AEB21664754497B06297957FCD8700152C012600F6A5A22E16313
169B5D974277ABA7335BD2FACD28D981F17814166A9D35106EC4D9554A8A2115
4E7406F2BC7414CF1794EB118F8D47A051BFFA8FD40676D293DE868E92521C16
891B59B5A3C7D0379A49FD3EDAA0AA7E0DE60FFF08ADBF48BB9A11FBBAADA4E4
AF29FE5C5EAC45326C87C523C3FF55180ABDF0BB057936732A6D99F0529967B4
827A9F90C22B17352642A96CE523A99AB18DFC5AE2EC45E5B6D1D56DBE2CE9F9
156627EEF4B43823055E0AE5C44A22A5679ECDF238DF91585E1668A358B9D87C
3F7ABE634FD1F4CACDCB4A2573934BCEF8E88373D63DEB61B5F68B48F518CF34
59AE09C0105AC131150086EA853E79E236683175E98474EE585504D646A81325
517DFCDAB7C05E451BD2F7295984626C3495C5575D0D1FF510B4D39631FF9ED9
383BA354036A27E3418331304065405DADB3CD6D155C07087ADC7821B6C90C60
6D8F35D780C30D9709E5C278B18BC6901D1191D01FA1F6DB353B2CA68D0B83F0
1D315100BD6BEF3DF5490A6AE23200D1997BE472C8D68A079FD769B98766B699
6EBAE9B7DBA3D5DAAF60D68B9065AE32C5FE538A9ACF4C0AC2A5B36B8A1F0C6C
010E066A757B4A65E018208555A2078CC03252389C098A3DCE60EAF8ECA4F71C
85C0AE9F07CF80241D991BBD8CD3776F740BC6B0AE202DD42A6799FE5E94FB9D
A88EC67E7E0CACFCD114B0E02D79524DAFCCE5C5A6FAB6C2E1EE81E2CAECDD77
91560684B93ACDE6A2EC74DFE4B9A148D97F2153CF19B68E83E8206196687705
B7751ED2B76A2C54CBBACAF4CC1E4F6AEC7E0DCEB5B99D42E3EBD037E1D93825
D71F39FFD3EB7887AE67A0342C48C18688E43AAF74B7BD78E5E3EC5241ED26D4
A2FFE0EDC362F313A197210106625B9CF4EBEA73A99875D243C5B6D63A2FEE12
8C71F23CE5CA4DEAB6227878AB0014D26180B312B3B817FE65FCBB3BF67AE6DA
1D15662F176598F6AEDAEBD09ADAE636571A0174BD2AE60DFD29F04854E47F63
828C4CAB067E6F733908ED06DF41885B514AEC967C47EFB0B56CBB0FB4D5FEFC
02FB5AAC41D9649896E55C6CADFB0AAF19A9EFC0760A03316F363FADDCE965EB
E0CA46182208C72AED93721C2833CCF5380B8F64A5F225E2E082CBE639F0D8B0
3B8FE210703327DC368BFD5A647979F9D7D8977FF83C0AC3E25E61AED84CACD7
E7AAD439CE4A68641B6F6382793699625AD4656A8411543F4D3520999BC23675
A58D845487C5682F50BFA09950D3483DE23E7DB723EF7DD2D386256720DF3915
3EC23B342EB8EB547A082FF5BF8CAF878FC3EDEDBE12B182ED2DE4144F336FAB
54ACB6F923DB3F835669D852FDADDAC7B737A7D9329C0C14993177D68E9FA5F8
00A4EFBAB162B457D04F0EE27FFE930EFB7DE2287EE58DE80A334DA9BF158624
2B61B82AC7D1FC0357593943759E8A94416EFCC1A3E907421EEB60CCFEA33383
61FD902D17F23E9505EF01E37EA76C6F0CD26EFA93B3523845D9625CAF59E266
32871D66D40597E4F29AD2955AED50409257DA5ED5487C5C8A568AC2E12828BB
8917C5E2C69174395C03302CC8FA03D7D7669CE1FE60E194E997E305253B7589
4FB5B4D590DC5A7676906F6269706CB3AF3BE00CA2A912EFD5C9681CBE9FA148
1A43E1BDA9DA53AB0D0A5076A38554450534BF143E01AB375DD0F4DC0CC00955
5B882E4ED6293AF3B3828D251A1F1D65F77DA5FC9BD23C8E3B8275837E274613
0527F1AF8FD5BE0528951192BC6026DF47306265AD21B7B9FC33EFD87F6D75C6
6425973010D226BB350BC5430C88DBA709406A36A37290F6F299FC88E3C6FAF0
997CE96A8B23A392DF48F4B45E597B9268AF9E5CA67404CBB7B69F6BE11A2075
D90E7B951B07A16794E18378D5DB33AB828E9D80023B3182612B0FF7E34C66A8
6970CEBD72ABA8EE0450E4C446AB05FBA7462D9C2993A3F2EC2CC30764D94A7F
B8F4A2776B795BDDE539979431A458EFDACBAA4839D98D07F1ED8C409CA2C270
600D8B1D6921F11732AC79CFF99431872D5EE0A542761C2C7568F07986893E44
275724CAA6BDDA4E6128F5EA6B550060683D07E370F89F6CE2E231E133AF8F63
AF0DFA7F8C15D9C9F057D881BFDB723FD5A05DC10F5BC858E0F0670F36270EBC
E7091D60B49BD16DF064DD3865625CFC32
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
%%BeginFont: LMRoman12-Bold
%!PS-AdobeFont-1.0: LMRoman12-Bold 2.004
%%CreationDate: 7th October 2009
% Generated by MetaType1 (a MetaPost-based engine)
% Copyright 2003--2009 by B. Jackowski and J.M. Nowacki (on behalf of TeX USERS GROUPS).
% Supported by CSTUG, DANTE eV, GUST, GUTenberg, NTG, and TUG.
% METATYPE1/Type 1 version by B. Jackowski & J. M. Nowacki
% from GUST (http://www.gust.org.pl).
% This work is released under the GUST Font License.
% For the most recent version of this license see
% This work has the LPPL maintenance status `maintained'.
% The Current Maintainer of this work is Bogus\l{}aw Jackowski and Janusz M. Nowacki.
% This work consists of the files listed in the MANIFEST-Latin-Modern.txt file.
% ADL: 806 194 0
%%EndComments
FontDirectory/LMRoman12-Bold known{/LMRoman12-Bold findfont dup/UniqueID known{dup
/UniqueID get 0 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
17 dict begin
/FontInfo 9 dict dup begin
/version(2.004)readonly def
/Notice(Copyright 2003--2009 by B. Jackowski and J.M. Nowacki (on behalf of TeX USERS GROUPS).)readonly def
/FullName(LMRoman12-Bold)readonly def
/FamilyName(LMRoman12)readonly def
/Weight(Bold)readonly def
/isFixedPitch false def
/ItalicAngle 0 def
/UnderlinePosition -175 def
/UnderlineThickness 66 def
end readonly def
/FontName /LMRoman12-Bold def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 0 /.notdef put
readonly def
/PaintType 0 def
/FontType 1 def
/StrokeWidth 0 def
/FontMatrix[0.001 0 0 0.001 0 0]readonly def
%/UniqueID 0 def
/FontBBox{-476 -289 1577 1137}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA0525392EECAC163E584A9104D99AD0BC
1B1844A0E222653FA481B8809B26A46F4C483A5D7E95816EA6582584156CFEDE
B994ADCFF4645140E3617E4D7E1B0E4541CB9F562E55829B4DD880AABE2229E9
4A9FA259A734D29BBA91BA1E2055CBEA4339BCBFF98D32CEFF11F296225CAABA
DCA10577A5D431B714726C1278D8101ABD1BD8D0BD0174FFF9148F8C61C241D9
2AD360A28616CB4A0670C1BF10591DF32391231FD9ADF097C47DF0B87CBECE1B
8126447EAE1564C1C1A82FEFB61C5F15ADB2502457074DCEE095549FD9D8BC58
757F3BFADBB5865A9F4C6B4E37AE0A3790E79B4A3CC477140D5BFF652B59E400
223C83D4E08A2406824F883A52C6DA76EFD957D5DAB0EB5CB1111B83A6ED56D8
E02845701BFCB7E954FF5CD309C679025FF0FE24F12514DF0FEF86EC20AF9326
7CF08461753843F4E3AC3C486D6AE78F03909D8DFE1BCD5645596A486C156CF9
D549995066A7AE7B22C519ECE348BF3529C95E2D1ECB832C24FCF54C84718CED
6164AD8035CD1E938B7726CB36CBBF34DEC977D42954E88925EC9033EE14BAC6
F9D6B54E85C0EA39EF3A661EE4B82D6F8D529D44C855B642DEE4AD670824A86F
06287DE387927F86F092989624FF57E382429F14903B387E9AB9787CDAA4EB3B
06F3473A63B31C176C03F8C931A5B7B5C47CDFE2068072EF520D355530600D28
04594D8EA0FF6D130231BB08227B4CAD7657791F89549F92C7C0D07E12044BF3
D9EB41E97D064DC781C5E5D76F5F54BEAEB123C53D41663B0C2594354F39D3D5
A3E1397FD2E40D5E6153592AA3F4EDA899BCA86F2935FBC0EB8D826714DB45A3
932C9138908E429806A32A74C464169625F10438F7087BF286C089EA3C6866AD
F44B147B76D3F2968E9704C8AF9F8223DC14873AD224CE1F669D6DDFABD6A26B
DAE2B315DEA91E452DDAD3066F81EA46582C324C6513964A084802A25E211009
E84E722FFF61C769C50BD329B88A5B58FB2C3972A239A35712A06FF1A5F6C86B
E871E32383E6D196683F2CE295C80E3F95459833AA2D4CA6065C2B584B4CCE8F
DC43D607288635D51D2F3F4DDD3C0ED736EDB545E529CA119E937A4E4F77B509
388EA3FD9FA10797B5A2DDFB174B1E1FDD705AF02638B0318BEA32B0D416B27B
9504C889C1FC30A36AF2B2771B685B4D7EFD996442CF47558EF0E566DA0DEE12
7C9E98DCE9C83BE46CF6D4B1DAA2AEE52EEB4F07F80386C872B556B363517608
42271DC8BCC8A7AED0FFA3EC0839B104B3D3399D3C2172D3C2F4A2A6DD033D6A
0D6B362EF493A53C3C1B37349F51BB5EB83237C7A488381A17E3ADE2F3BBAE34
04AF40A5B687B14670190FBB954E10D29A3F0A68C1C2482A0BCDFFD9613AC0C4
6F3D057FB5F47E2DDDF9B56C3617FEA2E7FD05520E996C0B3F3FEEAE3DC36406
0DB581E752429B985F23EBA0C9875AD055D8B1F640D10DB8F40BBF062F476691
EDAA1D05C5591EEDC1B75251BFF8576F1C9CC5C0E521392A2F0D5F869F8AA462
B3883A673A976328E1F0DAA22B80CB7737DE2537E7B54F5E1643E30046E87CF3
8D9A45A973757BC16CC50504033125D2A68A1C97CA095C56B3D62783960780B3
1693596869FAF5692AA8FA6643FCD7F55E72948D2DC55AFC5016FB2C48AF9D85
192393C682B739EB43CAD8C3FD4053B2D53CF911352E2BA87A65F8949B0B7918
EA727DE4A08DE07B71365B8F31103159F65D30A7A318C1056BF638CD20BB56D8
6F22ED3EACC46F750F405FAF96268E80A409CD8AE0F36B68AA8C5FD2E0E871DB
D2628AEC086AAFC9F04CC93440E1A8B0ACC1DCADB778837360339A25C08E3B0C
E768240F0E8CE9FF939E4B1A6365664AAB69761B7A9C7B95BD29B09B930B0D82
F2C39F9BC0B94E56C48DCB22D8F0CA6C633BE68E5977EB3D88103E4230C6A08B
B4FB0CDEA7D44636102D47AB90B92FA42243943EB3E77E6CC38DEDBB2DB8BE77
78936B70FAE12EB1E2913B766CA2BAC3FA555CBADAF2CBF6B7A216FC93470554
2C841542BC1FDB26DBE389CED193E28A19CE9CBA64FCEB47C4D9C7891741E0A1
23FBBE971ED93F797C02EA830678317452481FB78DFEFDB25A3645AD3979D2F4
AA17C624CAB35B85963C6DED262AED5DE92278F31B2E573FD86696D98800443F
32CF695BC103A3ACA687FBB3F42AF9C89123C719005844588667C3DA28AFA523
BAEADF7BED1F3B5D595DF571540D0855FA377DFA6880F525878D6A3D1980C7D1
05554ACC5D07ACEA1E0D27664F6DFB6EFF878D0A68604565D0BF75FD8BE023FA
36D164B7BE25F9F811A466CE04C2CE5A774EE3288A245769B7ED30FCFA10230A
D6C9E809341BF5E55E58F3288F7298D62092922F07027352BC7C9612CFCB7018
B3394AF7EE7076395E67C3CF9B71BE069AE6C6C412F86A496E7C77173A0CDA0B
CC46683C239700CF259CF668B9F5C990DE3196B84BE792F51E17583FD4A83178
989638A37897AA769D74E0B3A299DD94B314F9BAFA7217AC70D8D9D02544A545
F6880EED34399A835514CCB97938F3E012AF4D68C140C6CE231015D93CEFC522
CF56EDA6F3147B3861904FBF8BEE6DB3D2E71479CD3A02BE03C555B0808D40B9
53D2EC56876076A116EE7E81836676237F88C519F8DBF39EC35FE41D78CF1665
E3FFD09C78FFF428AC27BCF0318D0849935822699E31F5115E7854A22F46951A
51F24526F7190B18B313DC58AA2EAF631A48ABE394668C6F1CE9AEADFB56116F
FB38C388F96143BA870537CC8B3E5F2DC39F9B930ECC63475BBB8C5F9A45218D
E05C4E6F250F6E544D6011F65EF4808D3D0158097CDB6E280AA402229A6B78E6
AC615258668BFD3469CD663592BF1214E5EF1C116C4DB47B805E2F60771168CF
79CF10DC2DA8F2BE94869AA570DF2AA5852113C51CFC85C1E41516CE412CB410
BD026231E22A9CD0F664D76D385CC1170476B17BCDA45C640C583F16DA207028
0C58570A966383AA9F7CE59375525369CA6A559BEF0E05F11CA9C72A278C045B
1D2572EC08DE1424D2420D550177794FB3DEBEBE9E4105AAD34FF119AB2483CC
A034A95AF0B24B801710B398D9E9A95138859A819011423AB5921DE8EAC56ADB
58FB18C27A41CE503CAF2E7EA6F673ED5F34F1C1D20B609A152EDECFA26872BC
3C8C802A1517D9C6FDA3474591F19D573EB051F551990D0331B2DEBFA31B5010
3F6332290E522C15C69352124E1051A715399BBD1A6D3704BCBBE1FFF89E56CF
9C3EF605898309C7C3D20DFBFD10DF5FA30F409A76AE8021045DC09C95C9AE4B
4EF735A5414D985F6F79100E7045B930267F0EEA9BE820E13291132AE91118E4
7B8432BD1AD7A9CD912F2BFF83A2C4705A26FCBB7F8E45CB2FD9AA2EA98E381A
01BA4C4E31747123F20A0A721766F9D9A6769FF80B400B1EDBFCAC63CE15283E
72EC447BADD5BD58B053A11BD770399E31FB3B3D856FBCF6235BAD1F0D38E26C
3518FE6411F2A5FD4809C085AC2D60FA311DC99B9100C1A59CEF4C877053161B
59682BF5F2D85F2DA7EA0FE603D477F6E80DEAE0F250811BCC646D8CE2956C78
B897A5000D73AD32BD99B92E6E63BF8D79777859EC0F7FAE47F5A0CA878106F5
5462D3027DEA15E36AACC0E7349C8E60D6F2439E2D50DCB9D96C6C20D11266F7
913970C783EF6D587F638339D1E89A4878ED27E515FED0D26FEEE69602B2BD58
D146C077FAC71FD55A5490C89142F2844CB7E6352B01A448D4BD7A06D8EC0F00
E69984EC55E0B487FDEBB3F7FC3F4093CC6E13B87084E461E23A4D6862F0EEA2
84DAEA8343FE913EA90B9ADC7D025C2B8EA3689D75AA38B5222166C447B82E75
52DE05711B3883394BA9D683C161A48059A0463B17F3DFE8A73B46E913B99D2A
38E7FCC667A5B810B665519E7E1450E00BB9D0279537763ACA5F131550E83404
04E208B9C0B0A118F40332BDBB431AA70981E77AA5E5E76F43E730D9D3D047D0
B3EC66EF1D37916398FB8CE955E12D8A89ADEB1AE1EDCF91BD788D8F261962B4
3870D5928D160218A297BBD3BEA22E12E9C4197D0F3835C0942AD6487F5C9B20
C9A597910685A9BEE4CBA868D352ADC10A564782DF3BD57758FD145E769D4E88
BF43D19050DA58FFD64EB7B1D37BA13752B6C966C7A1397D80160687245269D0
F27E87B2186D931D624120B81967E58ABF5DD66AE39640224A518BF378B5CD26
761D1ECD916FC625A90EE8A7E00080300F0A05D265549982D56614814E10FB25
DA53070C2BBB4411D9608F4FF0B2E171820C734BD20399504F034BFE4C20E7A3
1326783358CF8D4FA48C1AB81741FA70BC0E0A4BBD104C7E5AC05CE49C6375E8
9F0EAB2B56BBB89144CE810C78D8CA02BD7CE2AEF79E27A7CC1D6B68A5B9F504
BED3487D1424CA82B8CC60A0156706987C7D0DB913F1BBF8A7B9A275E3345BBA
213B3DF67C4111E9564B59B724BD65916BFEEFE9BF03AF9D84DD2AB94847F33A
3AB3757D2C8CB688D50EEA68DEAD0613A62C3000C037092ED0A93F8486FDD39C
FCD0E8A6224BFA03E8C6D73F4B8F480327701262285C527828E5E203F328AD95
5AB433987B229534C53061C3350047FB20E3887F514B5897FDF225685D18D679
99974BE93A89999F153727432CFA9D0FEB17D073C904F5426F7148BB8FA709AF
1344271173529372ACDD21882003FDC5DA687CFA43C0D1856C461F97C7AEDE13
08C661A0312C0A930453867D1BDA0D5AE27DE83943B84072FB99578B80935885
6E4E99B28E138E2DB585CAA3CC5056C324BAA2C7919C7E116629E963F00FB88D
12C7B187FC10B4C71E24BCFED96E689908E9D864BE3DDF19BB3922F86224D004
E35AB8A8F503F391632AB92FE41DB9E794630D674AC5510E1A233D02A00DAF51
B816178B4A639FCABFF4EC3BCC994CE1FD48E705F80B009ACC13C7DF2EDF2C3F
52D34947E0964D0E8E89F6043C0D2C9A4ADF9422879682A8D0D249CDBAB31345
F45FCE242025991536E174784D21CA938B31D8127B9B6462C898A3A3E77B061E
721B992A9FC9C9E460A62C80FC2A395F302DF32395A029F7CFAEC61194397D4F
36743FDA257F5BC8DC009E94281EE90448387DC65F1B6E5D964834D39F64F6D8
69729A22714A5F0E7DB43CE31215A0DEACBB95D7D86174295CB49AC66E224B32
478EEF14B427BAEE583F82C3B8E6D1DCB67230EFF3F206ECA7D35A79B6D617CD
92A177852D1A5B12F15CA11F4B64D0006047877997431AD811CCCE9ADDDDCF46
A9F152DEC98F89AF22A114F7C55A7C93BE909C4403FE32ABDFF5A644EF4B35CA
F63FA0A8D22AF65248981941936AE86BBDFEBFACAAC888CDB3EDD5274743493D
05C0E250C677611B6C238124AB0D5F50387CFC2D956561FB10B6A33D034DAD44
34F8B41FD8FBE8A81A0B00ADEFE61F5B97419BD631F67F069577F96C329B88C5
591BEEBFA6459AEDB6C7A968CC62903392EB5CDA753CD11FE7FDB6FDFEF44126
4B8DE48446027A7574E504F98DB9D52D84304ED277398203B6A5B2ABE4A8B54B
457DF7CA439382D1E5941E660086CCFA396053909C6A7377F35F082E3976B95D
E622EE0C057CE8CC71AA4BB84DAD5C8732A428500D51ED238C2267D3F9689181
8B8D08E4964BF5ABE0DA3110FBD87B967378033C85592A0C3497A03C16190EBD
ABB792CA0E1901B4E24F835FCB8686EA2EF7E9C1106573674F33493BA5E68941
93547D1B437DA59E2E6681FC2BBA58FA2850EAB89E23E9B06A948F46D6E175C5
B6F56199CC1DA0D75BE4582B4C98B73630B967E4148136D99ADE0525349D0795
C8583B1FB0BC61C7A26294870255E4A960FA681390026AB9EB1E58C35E4A2C10
DF821DD1B07F793CDE4DF7018BE8DB1EFD7ECB6A9D8CA938A79C81B5A5898CD7
63FC2F876B779DC3E8C553F076877079FE2C27A117CAF39236B06C33F7273ADF
88F587CE89BB27FF745C595CCB2E2A213FA7D4D92C9240057B3C8854C4893EDE
1AE4E9F3C905DC814982B1A40503E899AAA09B2367C396F9FA2DADC766577FC0
EEFABDC23E27AE1BC097F8ABD32116889221A826EC20AC4384A8CFF8CECF07A5
9390BC8B056F4797583A5F1CC5DB3DFA665A46AD11556A9A54255230D00D4C62
F1885A3465B64BBEB2771D9E8A18423703BDCFB578FDC44CA7487E3D39479CA4
76045E4D1C6A7518D86054936C7BF0C028B92D0BF1B02876E523DED83BD9B361
7334857EA92C2DB592CF08B3DE2FFCE5F2124566BC16EC17989C1052F8E18459
0223348E583F4F5880B7D6CA5327DB81FAFE2021B109D7DC8DDB8C58D3F9082A
26EBA06EF157958C9B91F7D8950D44C15EAD5E6A31CB6C8D26215EA2661D1062
70C7F476591F47BC406326CD9E79E7F6B384E235A18DD4178062E8D1B5FF8478
3F3F85772FDDF94D48A9C4A9482E452E3B9297ED3665B84D33519F638D0DCF46
552670790DD6EE29FEACB73088DF117BEA075EC89FBA26EC55D57B5DC09C95C9
AE4B4EF735A5414D985880E681AFCC44A5C176DDF5EFF2C02F57FE5DDAEF20AF
E99337AF4730B348FFE40887C4D1357C69AFE24A19C63F80C3BE760CADC3AECD
739C9CC232A168BA0DD17521100EE16C3AD7E74F63CA69225EAB5ED58CFE209D
1497290B727DDBC487300E4961E43F3E7435C5646DAB4F0BD4DFEB1FEABF885E
08EEC29AB5E814B4D2A7B372645BFA492CDE638D8DD2A6BC796AF520E8EFBAE6
40A2F4B94F244D365B76F897D7BBF7DF9FEDB9745D3C854E48BBE8B79D1D976E
E0632F6CB26B9C95E60D2DC40052D3478EC279E6FF83DDB0C4700D3DCD989022
884FEBEE9FCA1B8B7B45FBB669845F48BBD28B37BD51EAC7264D45CD2BB8B613
7529B1FFDDB7E68AF105D2AF9B22A4875ACB9DE099EF4FE76271D75907B37D04
6EA67E5317B101D4DD8E99CEB625B34F1D296DD7D44B615A6CC13CA81763379F
634CC44BC66B9F4BE1514FFED49364D2E81715E78DF8DFDCA58177C08C29ECAB
193C45F75C84522AB7294F11F5D48A2CB2C3959F7E9B31610B918ACBE641DB97
8FB06AF062BDE75323B5B60B7771DA37C609A831C2C2E0E195CA3728670D8222
20DF7090194147394905192F92465351D7D16966F5C9E5BB07EEE8B933EB1DCB
1BFFC7A1246653E07A2614E51D3DD986B213BB2509E8C7AAA21B870398665A53
B912EA2C1B0D9C8DE6B83A020F0BDEC1ADD34338CCEE1159D7B21C65E834AA9A
B52073BF7D5EE5FBAF3CF3E7189AB59B814D50658CBEB07AC1A10E33FC1E611B
C3142D4A9B58F97102E7A8674843C514549F66AD6BB6C1DE871AD601B48C7E6D
EAE38B3838D7F8D11482A0DFA99F57C171FBC47998037F3CDE2416870588344D
7AF34CE6BC647478C7F3460278A8073A5B40A0BE90965C2C34C42797BA6CD6DB
3BEC3ADA0AF2954F87DB65F4634D0B2A45A71B64D702BE1DD5DAED57882F7885
7C87E574E30710BA9731D8F27AE69D86FA4C7D441AA62D48801769531ED7EFB3
C438EFB1B7FF738F07A43830B823E313133F5880A027C59089DB3C40E5A21722
A92D55AC7449C21E216CE350BC4C84C9067BAD331AE204F3A450A0165F894AD1
36561BF06769FD361BE4EB78C1A95CFEF5D63253821A866F13CE96048971FDD7
DA9A85F106CEA8444F50BE7BCA3BA8093A81F9F00BC11FCA46DC38197B4C4EC3
75FAA5F614C0F5FF6943CE3D65D86376FE392900FA19FEFED037760D1B21C8B8
A2F3041269F715A374FA5F0478D6FBD7F0835871AF9FED9AFE2D1C610195FA32
E61F5D12E43E43F6E03946FA5229410B1866D7A52B5AF7B22EDF4D13C1A0F816
5D2255CE0F492497BACB4DB51595758AFDC9C644CC5BF0521E4D1360C711A40F
E7FE508CDB795A3BFDCC677892BD546B5D84723A0D6B9998821A9350D76CBA16
B7A8654D0ECC960DB25DB41477263A78E3C86FDACF1B88468AB2901A05A5DAB4
C473CC5665A315BF1B163C9BB372A84FD2DADD995E6E2033E6CC70BC0E96636E
AAB676E725F9A4F3B6102F19D4C26C51B773151E91659F532E4CF8E440C8C71D
9F3FFACA55A9F6FB252129274A6B96DDD5D8B64F7222C39F7DF1F31C56A42B79
0C09EE3512A6F26B0ED07D0C0289A1BAA29D449446192F7C387B8BD34B50D6E4
A8C0F905CDFE5ACFD603C74D3C8F83DB12FFA2FEC28A987FA54B40D0C4F9F7A8
1CEACDF18E5C4289867EFEF7237D0E6DFD31C6C5BF230FC69B3106F6FC309582
A8F0D6A9A658BC161394CB9256C0CD4CCE3F8060B700822EB157C4BE8DE0D8AB
3A0AB26006B5C0940459D185813D76680ACB091F0BAF23728151353F493FE4C2
721766428E9B5D3EEE6FA9E8F9AF35C869967507DC148E37E05F6347E8C9AE36
B01A52FC3FF1E48BC962EBB4EBE02B903DC41AE8930680CCBF29A71C3A9DE22F
99A39A8209B01D8D2A36ABA42905DAA81A9FDC83AC5354B668E66877744C9789
DCD73BC1DF88CDE42E115485BB1CEC730E8722A632641B24ED1708008EEA033D
08B6531EE71BA09ACC58A5ACAAA033A9690AA696EE8680F3D4BC8E9167970E1D
356361BFAE3F7F5DF22D8F98C833C6203A5342F4A0C6AC4E4E15345A4CDCD565
D40CF6515225527D6DC793EAD07F6BBC15A883FDF4C04A1EFC027B607D232EA5
942ACE88AE8582BA140101A62893AA919CA865E7B124F886D8AC8881CED68C7E
9ECF4FE40497CF15F95D06470E7CD2B15183F5B3507D7032AA640B6B1423F787
9795A7234CF01F9C9EA95BFACB6F209131458A2F161A38FEB950663D62BBFBF3
6CA5654039F3BFDA83A6CD672E3FE980F059FED86F61EDE3925484E3FA45344C
7FD3D4D3A68B7BB00F6E6C20648F9677A2701944FEE0E51FD5BEB501509B2ECE
4082C1418C66C90D4AEB3FC1FC92FF7B00CE0BA686E468E1C9A23BD060EE6744
37EFE92CE4ADA26D2C9C747D02A567FB66A67AB2E9556E6C9AE40D3CE74A36E3
01E8A3010266862CF39FBBA573AADD91993E707C37BCAC7CD6479A34E1B75657
B41FFDB8AF1C9E3D3CE95949EFFE8706B22FD2E7357992143F65475F26BF0BBC
AF414670AF05EE7FD59641A99D3529DD3B8224D77F85F5C180E125446E5CCB32
5BF943C3D7F32D49651F5744A14E48BD82EE0FEE77A69FE220C5C7838A41D37E
DCD4D5CEE4CB8CAF5B6C5EF38D62BDD9CF7072F2714E97474A53C7F2EDC7FF83
9307FEDFFEC8F435767AC00997A6BBB900B5113FB87655EC865C3BEAD9DEF9F2
F8521C29117D5E0340914BBA7C438FE5130439DD96BAC786787D295DD0996ABB
29FF393770A1670C9EC16CD77225DF91E5452E6C2FB8ED5906ECCFFACADD71EE
0B7C7B67D8C7A9F8B2331C62458523B7EAE820C10BC35D42045E5CEEBECCC064
BC8D00CB1EECA4A9775F022C7C68903B5162176DF7E4BD30FC55296995CD0398
C35E55C781FCFC1E029E64293585DCC8F91CC8B8E94D2D8BE2D9D97717801BFF
29280E8DF8D728D7E1456BCA6134F4964C74301C8435A64C9A456DD6265D8D0D
15BFFD4123C58D7A513E691E7BBA08FAA6A7164425E9A6A9F68CAE5056040A1E
996245BF51EB4895D4358CB69DCD78807398D945A6A4DEBD5431F08FED2187C2
9D1B9B88C659BC4B9F560A2465A0565E91E89D1335338DDC277E4101026AF685
99EF9F21125AB79005BF428B245443934A6F467A225C9710D3594B52234E623A
545ADC9B1493D157CC674BF70310E15E6FAE2219B3E9013472BF89160093935C
D2E08D41269ED78A655718F13DE2756FE91B30682609EA6F7805A0CED7C26E24
B09A5F46C02877AECBBC3B301299FF62F4B6004A6F2F81BA6E4B03157AF42FDB
1FEC10CF0F4808BBC4AEA4881748C0A2F1F9A03CCD801B9FDA3DCF5A465E9F00
2FA79AD452E2CCE8D95B6A5389A6C2E636D5951411C6F46CF31F03D3517A9630
9E02D361898565EC5A3E0ACD13B07D4110C5EF052E53560BB2B24CA4B63A6497
C0B276424F50CB186BBCB369B984A2B5C57327EE8310F8FC87A29AD6D75C4863
DCEAD5EA7A2BA5A4080A732B877EA2DED6026CFA1807B087EAB33F25571FAFEB
EA4F5827DED76AF27796B35D19243C562D1B61BC0CBC2D312B443B447DF41125
FA6BCC772A6A6131C5D60C7E1AA2761AF25BD01C501409DC094980FE395B5DD3
5415BF8CDC08CAAB216004EF466C70EA68992C4A43DBD0291F03932E92CE5320
DC3DA94674E8E633B24D826E4B63F8E9BA65BF43438EF9F52AF893BBDA2157FA
996BB689AC03CA093B8670D02EC066E0186EB4EE898EFFE48D7E3DDD87C11EF8
381CDB4C764F981E33CA2E75F28F98DA8885B49EEB34067BFD6D4B1CD777C88D
FAC259AEEDEA05C43CADCEEC62CDC875177363DC60813985DE281BB7AEABF17F
24254496DA229B295EAB9A6862D8EA1855BB01F74A6CD04E80FE02BE6CDF5629
45445631703726FBE0DEC27F235795800CA8EF1DF411949207E1B884A635A73E
C68C0DD4354282E94D42549B3FBABB9017E6E32739934E2D7802A5BF4C9235E2
01C253C7F86CD8C9489A92093B035CCAC9A2CAA288B2EE242F5ED49550126231
7FEF59FF2CC06304B71259A0E61C1645AC6E7664C434AB0DA3DA27E7A6FC13C4
EDC03B32A69F6972F2E3A7CF3C56A800EBEC5406DF4662CC30B7AE2C8627F0C0
577BFBFDDC9A774445CB9C354E30E717AAC4CEB41D8964D4FCB5E4DD511B6A9D
5A0C7E7001AF0030ED0D0769FFA19112C97076BFF950438DC0E74A880674B8B6
AAE0E2B20B78F4DE13882DF23070B9F01A89B3B60737C546E9A01A591EA3B121
B082110C6BF1BEE6B2EEAD5218376B67951041CB6C3B3F93392705145DF56085
62153DD6A09E462ADBE677E6F550F939257B0C7941D39239CFA195CE54BBFE9F
13E4F119193F61CA4279E92444AE54D5C6FF284FD81E544D200A0A482737F663
27535C49207CB22CD7D371D2156E4C040D7FFCDC641A2CA6C84ACED9E02D9E46
CB2FE2A6C3F956DD97072202A3C381186F39ABF5F90E52A284053108EEA895F8
C126621B61ACD5AF2E7C680A199277F14EA2931D0E7268DD53C3264464FCB881
68ED814934A247C30339F275DE179CA649DEDD316A452509D2804B5BE0F6C5C6
EF9562B15BAC0348706DAD0FEFCF83BA14B4710841BE3B8F49577AB8B77297F6
9E0067FD396E0D6D16A4204F78194259C8FFEC4ADC96CFE4EEE78D7D547A1C57
AACB90A8FD5C40FB22842FE6431E502F512686F02CCC66343D83CA952DF1C685
76FB465DE6A8860E05E535736EA7255D81C4838F3CCBDCFE60878C22EEDC232C
A6A04E928004BD90C2FCDFB6DD8952B09A48122FAB8D553CA6B822A3848DB1C2
BFD00F84449B8DE094B48AE11662FFD3D82CDC8C6B8E693CA78286E09B224B0B
A4B135CC8709B34137EBE447A68F1A9E8FFF3A4230C6A08BB4FB0CDEA7D44636
102D47AB90B92EF812DD92F0686CAF993FDCE0113E5C9A994CF76178972785B5
7B67071A8CFBB6CAC323167D9D96DBE2AB542FD466098EA2EB484D0FF08E196E
FC5F2CE715B765EEB1ED05B8418D0C93AC7EAA9DF793A62FC3E0C50F55A84F62
D68224FE93C933C34C64E6009ACDE37643E89D5BE19951455852341A2636E5F9
1048125A7170E748B5BE09FB1DE627B8433BCD698BFF4B9805B0FAEB53D9EDEB
8583BAF0B7928D3BFD35645B530C49140EA4499885CD9625D40E8D0E067E2A3D
0BE8B2D378E5E3EAAD4EA0CAAC868CA16770B47D01CEA50E0D6555854323FE00
320EE939BEA175652189C87A734F272ADF580BFA27B0E3F70E4918652C11440F
024431328D961B72BF5435880D10FD903C93E69C079DF7B66876301AE9D423EA
39E046EBD6B174DD3F8EF8385B45D44B09A9615DCA767BB4E6E77836292D2C05
B69E55969AE74CD3A31D6E5204F3689194670631B97B3FAF26B96747A8E7DC92
3BA8EF6C9792828F43E837087FE7179E9020062622DE064EC1424A36527C3442
6DF9562D021B182BA2924AA1DD4DAFE4CA472B4C3072662A67D2F5A6F86FFBA5
C6267A2A20B8CC7B4C8E73A11770D4FAD1B1B8D4D0F6BBFD2C717646CFED9113
07947AEAD6D9670DD996AA9FE4D4268A3FDBF8F1ADD14A788AAFEB2E05BB7966
CA5034B8EFD58FC08C1C1A89426CB8C374E0C45BE51CAFEA0A456252D1446648
C730DDC6DA409998114BF92E9A4D8796FB9DBBA8CDF19F356482E8CAAEF1F939
26CA457899A06AC3DD5F51240141C27932518CBCF295C49DD58CF10B322634A4
B9ACF7AC36FE23C9CD10E8EDA5C46A4D25802401138F236121ADAE748C7FD8CC
83AA4C7C9C61A51649E73416E15ECC7E00786D0D9AF799EE987D0C240CCD6046
B4105E3023A31507232339F3FCD771914933CABF613F0F9FA3E203886C3AE6FB
3708C00A4BDE3339EE44F33A75C620A66A5CDE236D480D9250A1EEDEC54A0D75
E0C853808E0E439FA0B8D23F7C9C77D990FECD8CFA96EB61F444122610FD7D23
FE0703A8D69B9C0B4E7B3E0E986592AE7310978733118A584DBD875150EB9A6E
9420FDF50A7DE0827EF64D53EB63496BE00FAAA681420DA7DC25AFA04AD42EBD
38ADAC080E47FBD491626CA771E2B69CE5CAABAAD46B4FCFCA0D01A294276F86
BA1443F753A7BC8B7A60EFE7DA9989DBCD244F0C11087A077D2103E494406B1D
C8129214D9E0E6E79F86DFBA81F68F8C745EE041F16B1315C1D88948D2849734
E5F9DD5CB5BFEA5D7E820D14B94167786B8C6BD6AADD455B5748055DC43666FF
A6D2F55AF41303844285752BD61638AECE7EAEB36A070B070F3BC70B29D31826
0FBC314986223F9EC4DB5B0EF2EF591D0923158454E29255E8846AB1AB9E444B
82AC000DE22644B08E73074D00A184AE6BF52FBC97374956D581BA40E2FF455F
34F89764223F7DC55BA669B8793F48CA8E9B6FE2821415387B024B707616776E
7C37283F3A63DA8055B69718F95AC98AC233A6E65D542FE7142C6AA82E8F6D6E
6867AC612C4A7BA39FAD5682A4E34AB38324133302AD9AEAF5D11607A783874D
716DC73DB1CBA45D323D10229E8FF040BFD4CD3B9F79F1BF79818A68219E8762
4CF29AC54033E2AEA70CE57180265F10B9458B6B78BBA4C9415419E0B7399145
BA7A01B9D57754D643A8EB4948EC59E4C56D3C57E14995A8ADFA51CC6C3A84D3
D5865B2E7DD30C7B3ADCAB60AD76E6CCA5E6E543778DA37AD3996B3C557F2EF9
182692255F7A98CE9B93A645D49A3A64ACE274AA38DDC172B3EF41D65B6506B2
F15DBBA637236A94304A0FF6B67A7C777A1E24E9A65FF1BFDF2E8A03DEF316E1
25358052E874F98BBDA7E4D8F38D8980ABD232BF936527C3F6251DE11B8B5F81
5032AEDFF16B199F5CBE9A74A953D0596E59F9510557EAA9071AFD78A28BB9A8
C848963020A5B15F862E7DCC78F25D7C5644180804D743E635733BE09CDBFDFC
9B81ADB62601A5B6E9A00CC3337A8FC5B541D8F2FA4654D530256D5C330A929B
1D202003469068A5BD2017D3094B67D6A21F2AAFF97025B92E55DD5D5897F13E
DBB3356F9E2B9DE1FC96BE11A7D7613AA7C519BCE1182B6C30F93DD0D7DEAA3E
466BF0AE1EF7FD23C8AF7BC0ADE591EBEAC608D291B1794648B35B9C84FBE4B9
4E616C0BDDB44A1151E2C9182BAEF4DEF28B5FC78F9B26E111583C71D31F7D8F
F7311428D8FDA30485C8416E8156E83E814C7DF4DFE152BFFC89820C82199998
79C1BDB510F36CFA5A1647F7F94728756524C0FABD33553FA71C10A239CCBD57
1161888C517DA5F382ACA7B466770490E25A05B84717C2B0446A6D20012FF6DC
6C558739DDEBBBFF6170BACE74C20492F113BCB3E17E0CE57CC25022A23E388B
7E2CD22F1016A47D65929D199AB424136E7DBFA4BACA9C38641769E074CC978E
88EEA0CA70F49B517973916884B791DB3727ECEA63DE4D8AAC6484D208FA1854
32C09B97FD9803287873BD5D654BC8C65B809321300215973091137859979DED
ADE9D0697AF1F8426A6927D11568D3145B52C8DE98C6E76D4C38D855CC53AB9F
5668272B4E4BCCF9E46C8FB652B00C5A00AB8705257A86E59953642D6C2D25A1
B327C129A4047457D56024D95645ADE0D95DEA7488F9FD1B9B176926F360586A
5C26C99195A6646B1336F71C98605961485103BF3C2DD396E682EB072BFE1C08
7962E93C046C2694DBBAF882F87811A96EDDE55E91EB137EFA1F5D6612F71202
2E25F85D4420B6D1857CFBB80FB43420F5DC38E426811BE86A560B49BA721CD6
3D7853030FC634549DB4DF0C90A4B15CCEB79085BE0B5CB46EBE9CC88042C30A
58B2473A333E603F36F68AEFEF88DB6F5BC3F6D99AE73789CA43DDD61AFD0A6C
1ABC42F11B54F3EBFCC4E3F3D8112A7E8FF270331D2FB475491A543389C0AF87
82C30F4FBCD5010D94DDA30568C75286BDEDDB91A1C10223AF53A16B1DCD7C5D
F152E571C9E734130C61324819BD29B657D61E2BA950218A3AAEA34714C68736
EDBEC14C5256B9940F0800E6DD26001BE1FD4AC611FC7DC2F3A0655EA208F98B
354A29FA9E962DC65C85A4358E0A1B05164210F4453883898DE5BA43091345A3
41C5661CCCBA123B2C56BCA4F1724FD3C64E1B66C5F9EACB50F09C029DFD240D
D11799F2F6B3FC0438504895437E86EB5FE4B3AD545CF2DC302D330A414824E7
D5B0B83F699756F1197D8B120E48C983DB51F4FC23E312D9A5086A47A0EC71D4
169ECC5A9AF15C361F4CA0CB8FA4772988B08711D1C26A6F7FC2E24FD64F7B74
BEE2071B456F1A5E8C10A3A63EFDBE4A15FD0D0C1948BA567357052317086231
63ED2DB636BA33208269330C24A4E66C6C2EDBB23894BC719D68C21A6625E485
18D2E33F823DA4ABDF05D656E52E3959574B0B4BCFA0B9C7B2590D35C78DB2E6
D5109FDE9B405E97ED9527026AFD8C09ADE601B3DB3A00354353B50C9B2DC97A
C798D4FEFE2F2376959E12A6A42C89543196FB8FA21E8894D2C09DA435E56B6F
FF53F447D44E968A8B29A84AA5CE3B159971043F95DD4ADA95093D064B0E699C
59892B661E5A0CF700EFF2E3C4F57847EBC5AF87C86FF819AD0834C9B7DD00A2
37BE928C00E066A03A5781A4173AC93C0F9C6B05D63FEFE3CC6CE631EC7E3D00
412D24271B9FA4FA4233558829E27C86BFD7AE2B988A390BEB352917E28C85B8
6DD43454FACD12B5C689DBE39D73BA8C9C093FF36C00895A83D4A16B2BECF9DC
186E0B3479EC564EB9E63BE5C8748B3C4C1207108F3D4D7AC6BB7F5EBB84447B
363877CB9D377E831E4FD8D7385C115E229FFA8A794F67112CB9305E19AD1D5E
5C5F47775A67C69A80416EDE8726605A030FAF50A76B7BEBA99F7A8167F9AFA3
7A73A0FB81B5A0E9E633BD1AACE6F06A397B5D75289ED307C730A28819DC0C2D
9D95F7E82180B767328BFC532CCF26068F61B7525A740B80BB8B3C209EEAA6A4
B2422F75140C6CCEA99D85192393C682B739EB43CAD8C3FD4053B2D5396C85E8
5A38F4D4F39348B96E5AFC3E8C5493E8FE4A63EF1CA20D44F2E50F091E00982F
4FD83A14682E0D7437748FF301DB98A91C6F34AA573BDF47829A0BD0C1FF587C
759A7C8CB34B040C29B9DF8963000217458FABB58511B2E3D0DC4C2312EC701C
2A55C23A71E12403A443509B05EEB3DCFE4783F5A3DB1C600AAFAD8D61BAF622
2FF896D9F7A5E8A9C1D5460FE747D637C095D3A56B3D3253EFF24B393985E8DA
7768801D9A6515ED7BFAD3CAB8137782B78039D2C3956923C9DD71A04C7A9CF0
32A8B59AE576CA6C311D84D4D071C1465C95E05BD1F6B603ADEFCEADC5B677EF
946A2D806D67A95E1E790BEAFCC312DFA96BE214AC88BF14CB44C210BF44141C
72291EBB1078F38BDB5187DA096589FE1C6AF104DC95DDBD1FA5C057024943F2
FFF8F1BD3BD8F42BB2FC3662D7BDB1472028253082DD7583FE4BC0A3A3064948
6C002BFB9868AAC45FA3889A9481A391152151055D2B2B9DAAA7D85A7963E6EC
BA619FA6C38D9D27307FAC14429AB8FA9A5FA48FE6245DA950A72D479C48D678
16F04AD0E3DC993DC2497A81230D0F8A676B928A8884081996FEA9AEEF420DCE
CAAB8207AB962836E6CD43B3EBBE0FF0E5955E1A80E94DD985D552F7E5DC2335
2FD902BF6F5B5CCC85FE8FDFB26C0FADF9A6C05BE3499567E930F710682B8954
158EE3B8964878C02328BD308424854AFD3AD930AF497BB56E5836FFD27D21F8
92B9AE92E8480F5B8A2AB1B87E1B3A20F58FFF4C5A60CCF5DD51CC3DCE518DD2
10DB18D1B3F0B3DBC36B1AA378E1A78FC7C507BAB3555B26500BA090837CBE55
E8818A643F3F3F88BB227E90541B10EB1C23F4584FBF0D451CACC5142CD5AAC1
2ECEA34350CBBCCF3F71B4C23DC40447A2D21270DD055EA707AD5387988BD38C
ED32B34BD8D1A690B61E603799AF425983DF0C93D4869D4497CFD909531C68EE
FE20CD2B55EFCD4FDF5E4004694D39E05F5E2AEE30F76D51A3CF5FD0371032E7
FE4B7CB450A9C45FCC1397C6B0A86284D5B101EBB0F40B89B07BD04EC6CCC6D5
C4515070E4EB6AD120D9C8508DBA86A2ACDAE6B930FB8DAF846931370FF1C57A
AEFABCF0D09F4F55520E1B0F1C348BAB432579CCA1DC314B08F47527C3D37F28
5153BF1EC03635E0A8F516CE6997307E6B8D0FDA58FED35CC96CFB69C19BA993
44AA3B4986570B6F13B70B356BD4A31C85F7B17599C120A3AB055E62D130801F
34E16CC0C876B0D072EABAB7EF7ECB0390DEBA757BEA45FA3171095052B839F7
A2A9E5C6F80CEC089B5B2A64DC911A05B7D0FBD3BC15657FC974B079B220C48E
9DD4953A244E5AE73B98F8203B2AE21A5331AF98893672C3DEF7A733E839622C
CF93615936A6F058FE825BC54EA5B184716D9B3136AC2E7C2B34D4161B35DC1F
3DA652834955472F18F480491EB93BA363DCBF252EDC8C38AB822AB24BB0E068
DF816983D1F2F63C5B19635E11C8A3D3EFFAC77DED7CC3DD229F1EF1A3516894
87E3C56D4978D17EEB2C720C85A83E3233166576E15CD42C9C12E6298288601F
1E427BC4A6CFBB39A4C3373695A0C5D8C101680ADB729B32E4D7302D0F35DD83
5930CD63B63CF0ED5C715C6ADA552F3A2E3137400337291E3D0B6DD956715C56
2AD838265D0588CCEA7A548B100EB57D779FAEB253EEC77814CA9313C671D2D2
45E0B7309C0CCA919E6E14EBFA7E123020F4F56F23CCBAB86A6C5AF9CBB25974
698A0D30781DC73AD951D31EFC82FC5F5CE2740AD0B02D9BF80CCF10C73708C9
D5AB855F00673200EFFEAD520FA7BDB2C711E3B6BF191A83C27343473FE2C00C
904F86AE911FDF345237C6365FDD62F98D8CAAECD64C7D8468DA6DCF2767A737
6EABA28063EA72DB6C8E32FA349461C1A8946B78E0598CA0B2C2381DDB4F97F8
D526EB04F212B25B5597E6D889FDA3AF67BAD9637C67C9273BD31F78A319C455
4F710517605FD2FCB511BD92957FB6F43B6657645C399246A8637BFF7F254F55
3C2714802B65A80949453E9CD691E36774329B57F73A0F92082A6167AD660444
9AB0172A340CBB4661AA41B3FC5FB97BEF23768CF831460B751938B5E9D1BC49
ACF614D50A54084B7B7EE57969FFB029ED2D66604AF2E84AFA283370152E3A0D
D5B1EF80D23CDBD9B6262A84D5ED2066E0D294D3852D68726B73E7D3BB07C709
2D37CE9C08BDFB7EA28F38734EE1A2CB848D2DA3A86257C5F46CA0679FA92419
B17F95F124C9968C634E7A1A5F5B55B2F7B5598AEC81F035C4B9F3D12C44EFAA
D442B457BA90BDC48598D52932844D137FCFE4F614E2BD7DC429B31DC41BF7CB
13AC4530533976D65606947975F6B2C377C0A464B2614436327CE645C3EC64F8
4011BDB8570A93EF1844AE43D51E57FAECCC6AC6EA71F49F12EB4D96C292C9B7
FA1F362600A4D4CACEC426458435B5EF1C8BA2A8B31613950A4B1705E5DD2793
F56E66A1594C7A6BE759FADE7ADCBC85D6819F75AABC2D48B88111EE5C79A76D
E0E9B0EF200E16BA13E4A36F92147E38CD271718777FE79698B3D2AC24C03566
5DD98E26606CB1A3A8C57A81971CA84B4758B3FD08D95F9EB0F8073462C06AC9
D6486249657B065CA89FB46CB0A2DE2DF0438424BC2D1880E621392A3998CA08
BBED16EC222BE506A2ABCD4D34529CBEB746EACF1FB73C050464CD37804055C7
D15CE25834DCC5614EA4F879F76E5DF5B8ADC33F2D58A1CAC100A22BE6840E74
FBDE254507AEEAF707283A9E311705120CAC421E46322C0B40AB97E5E7B4B32A
D1043D7B65DEBD3ADDC8E8D158FAEF15EA544B0DDF01E9B23BD9FDF894B1C205
6DC680178B7431DBC974AD63D5A4D5C2519FB093C02B4FEB26263F9CB022B809
E74630B71E25E517C60BC448891030BAE0D3B1DF3DFB2FE4E54041F97A726D27
08EDE5A1513CEE9710990D489AFC2D244A5C96FBE9F655600B08FB2669A419BC
0C75361772BE08DFAEF515023AA9EE7C1696169276D974CBCA4C1759320F26DF
C915EAF43F1AB59632C7DEA29B6EAC4938D65380CBA00486C1FD108ED3D5624B
0DD48C2D2DCE1123CD43A7B2B80BB15EE0FE03ED3A85A7F3041FFA7692062181
1C31FAD9B60187597F64C779294F38C4FA2B2D4CD661A5A403E53E148C3F7015
6B8938FDA640CB30724150A9379B1E5038238A03A23B1B4CB13CE190839BC4E3
FAA6E04D40BBEAAC3063B0E652019DA8C9A7838F89AC5F9E8C0E01A1B8EE9BB2
CDA455133F8E7F06D46E1238B59D996158645D8DED5E4E059DA52A17B65A2E3A
509A8E6BF87EF632588760BA39BAEA56C53644FD646F2DE7DF72AEDF9F807D78
4FA801DDEF576F6F78B7CC3CE457AC95DC66B03F59814C53C663B9A0DCA222A8
545895AD28C1FCF6995496CE1E3E2C7D3CB5A0E7F0FB2342274C225BF5F2DDFD
76F2765CAB740E0B80127D68B71E6C344667C30304D077CC5D6874A1FCEE8DAC
243D4F84CD4DC6369B1720D5FD1EC1C2840C7AE3C6D74E85AFF56B0F9630FF48
D6569DC5C166ADC2A48653A9BDEE22D46F9CEC8C17FF66C1F90D8C4E366AF02C
E023C49ADD3BB95D63F623F56F201FF29936422747D6012F16BF51E25FDEDE60
F0532E3B730962F63C8C6346EA0F954AD7D03474A6A82DAF5E1ABDF8CE3C652A
8158056F82DEF5E5DE6C520DFB49F8C9AAC43057DEF5CDA79B1E97A66B2E9B93
7B85A69977BA8352BB68ECCE4ED1B642914AD1214B8BFB43159501BAEAB263FA
F9218480A4709DBC3A4A5914E16F20DEB6E28405DA733CA181ADB38ABAD05F87
B9D8982EBA496C82416E28E04780BBD8A0A1F0B2E33B166BDF7EAA55FF9CA297
182A3982C9DABDB0134E6D6083277D8ACF36FF0BDBE4146ED2D5A49FDD4E92B6
1AC064BF43F064D1A2FE49A02A2E0B75B00A4306CCAABC0774F8A63EEC0E36D1
EDBE356E1CA4AC6D5EC752BDC6A2EBC56A2E82E3C4D85A8C953D3403AE5B6E59
5D990B0ABC6B5C2A2B089C6B7535B0E2A267073B662552382C142CBDE84067D7
54656E1929532101BEA1507B3581BE6E3014B9D2EC666FAD29EB99B8B930F399
B787C939AD3432D0F8E8AF278E8C5870137DCA892C500DCF8128BD3E3F655681
44A7B4D938FD537797668728EF5CA8CF10CC507D4E27BCDB40FE0C276D0B9FD2
75E00B4D439ECB5F49DC10591E4344EA7234D0A3B7344409288D10D72EEA694D
370DA8F07E0B993523892CF3C8706F2B45C0D0E17A30A5F045271922C4039397
4F2D0A93D2E652A0F94D8A01F235C440386DFB0F4EE3D8ED6F50AE60AF3E00B6
E524774D439910ADC4D15417762825775A80924429A4EAA36622D2316F78AF7E
5DDD4315463D662B9274D2E29312ACAA9B901FE80FD8EDBAD8D74DB6E9698459
E3729274AA08B9E769C6BD874360F8EBF20EEC39C37C6FC2087779FCA72E2070
3C32A0A371A51F64CDC4E06F544F2055F67F0ACD49AE6527D6837CEB894FC54A
D1A218DE34716DD5BAC485AC68D74427C914F067479B3A4A7FC0E0823871776F
840A32D065C5F3A6A112882F7F37638E5B2B3893392702F3550DEB0B2F03A7F6
F958B74FCCE89F7821230E27F7E30A4AAEED8322C458C0BAFEF12587147E87FC
B3E665BAA8205BC600ED3C0DF3960598611D5429941B2D40F80954F95A0293EF
3CC0417540B5F1873F22F51B7014263FFBB0AAB4BD8288250804AC5A885463B1
C0F9FC1756EE0BD6BD5423B5C4C0F0053040E40D34A0B2914FBDA4B3EF695BC5
12E973F4736851AEBB3A3A4D865F0DE6C7AF6488D173C2BD0597AFD091C43DA8
9EBC2B015EB8B94A05545B974F452C32429CD081FE922485EB723A5580F972F5
16EB0DACAE21633B045D44EEB00DAF4A9CD1193B01370A84C82D7DC1B020E2F1
113AF8E5B4C1B9064D8DD02ADFE7584F3D26657E7F503C729D0905CB5478EB97
44A8B71F614548F7638DA1EAE01CFE9BD4406327804AE47318848D00D3CCCA28
1C7FD572DDB329DA58AD9F41935A1A31F3B94C10CFF683876ADBBAE35D1C4EC7
EDCF4580211585A3CC7F62EDEC2D97DE829D911CF3634F9AED72F48648845D6B
296784B32636649E5F6E468B436B27E85D9BD1A0B498759B085BD27A7A11FAE6
9C4536D71DE4847E1EA2C7EA6B562AAAFE1CE74489C9049F0F4999FC5108D1AD
0A13333B48BAE8B3FD4009BAC622FB97AF27C33664E1AB525819AD40CA973776
8EBE740AFC9E548F74CD6DDB4AB9FD255B5320193D4259443FF984BF8E9311D3
565B1650FF0DF0C4EB6D71D09CC996D014B6CBFF6D4806C7A24343D5535CCC51
2AE361758CFD2E7DC9936E1D47E4DF3D04F918C85F881124DE871B3CD1B8A6A7
859EE311F92B0CA6010AEDF8390C346F2C10D7B10678BDC865CA2BC270E4E404
F8A08B6EA22077FDDCF0DCE5DB6D4C63A99114EFD23133E2FB8243221A2E8AB1
CFC19C22B5ACF8839490203560EC53F1F43913282D7DD522FD2087FC991638FF
F960D0D38234AA1C9900C092C7070EBE81EAF66A0A030E6741C060A09262425C
9A402E5B9FC521330EEFE173B3C0C54AC0A20438F0184647BB97BEDBBF3EA181
B2D1D4CEB9E40F74E616CB9FEC482D15C768EE94EF2476E6D29CB9AEE890205F
4F50478F7648EA44469728CC40AB716D731352D5FF74E7F77E8F33C94B86D4AB
8C8F1FD93F695B46A2A74927F88E2B9E396B5CD77B4EC7E7CE0C67EAF6BC8B9C
D21D49FB82D48D24E77117473D460C71EDBC4D879C57034D42870603D2AD9612
CAD865E3B0BC29C36A2106E0D47DE5F0C9CBC54BC4CD4695AF7982390C08AB68
95D4F570E449BDD88CE30B5EA1F5BEA1AD589B1906057537F550B8E7DD8594C6
6B71C8B5D3D10DD7EA06E8E4B8FCDD03414F89A7F05A661A9D35FCBAF05DE453
1C01905E075CD64CD13C6427D6837CEB894FC54AD1A218DE34716DD5BAC485AA
FA5D92D7D997842CF3CA6DFAE437D0740605CCC91E2339617E269E4E9516BDC0
7982DEC8AD1ED4C507F8952B95778C7E73746B4845C1ADD96ADA56EDD51EAE46
85F6DB8A0F54F4D95AA1618380D553C319761B79DFE0597A2D89CF91BC7FC402
EEBF5840B75F133B69581CFDB4D99653D2B9A806D5F9E658F77421B434B082F4
6881A8B0F7552CE4E5312C7EBB7108FCA6DFC690EB13B88239CB873186227C64
99DC4E6DE17A43D33DB3BE958098AA8972C33BCE44A458C5F5EF1602C01D3283
CB3A4287350E76654675219ED8A610A82723E3B50BE086BB23FF7DD53E544E0C
41B8098970689B23D558FFCB32BAEAFF57D7A106130512BAE13A13A9573AEB26
2077411083C2E9EDA44426D57006CDADE0409B1A248B52378E7ECCE82FF53B6E
ADCFE52D2A9D0C4C94CB706120B5F5641CDE1F9753D1E914FF9ADD9B3C8745E1
5C012902696AFD064FA1394BDF4FF32CC5BA82DFAEC4C878C506E54F467863B4
2C011498C1DDC488A1BB87169AE303F425D22416CA281DD35083365CF012A4DF
EA96F63D81825655262A18883C4455728D1E4F69D2F9DDADF16CE5C0D3972A61
532EE6B7527E2C2B224892AE4DBC4A130B1A5E5C018D240AE363A57823E711DC
7BA92724A2E9BBBB6631A7766300EA02BAFDE804038B4CD0F47796187D1364EB
31556DD3D4A55973F1662AB779230049FBDB64E8EEABD2B0AEE14150A9353D03
673EFEE5B10DFE99884D7A4C5C8270E109393CF0B5A8F33122ECADE6087BBFBC
B145D6275C46BD780902114583DF1C0E7D72F7FBD50E977B75B60048D2EFAC8D
2CC30B224F62B8F042BC4FA62D0F0B047B18B03D7CD109BD5B3A42EA356D395B
7DB4FCBB481D7909883597AE9479F8C176294E135D1A9982FD492A4E3BB03A5D
0C096BD7214345EC8D1E25B6B2D5CB28C6E4F32DD4FBCF41CCFB2B6FF370DBE1
0BD9D1C47599DA6401D83529EC733484DB6677BA7CD12D8ECED2880F8AAC2C6C
39954AD292E79A639E800958B0297376257EF53603BEEAB3FE7CE7A9122E39AE
D7A194BE43CCCD07663F7E7065EA1ACA0B22F411E04AE47B92F8CBA53970E9B3
1E73863967A4FF7FCCCD04CFD61476B4495F931FD8E03C1A537ED6B29FF9D222
7A5447F002948406AC3C1B3050A47EBE4DD5C1A4A740CE1CF340BF08021FC337
91B6684152C6FDC5D5E551B989AE583C5305D7D01A3ADAAF2C6AB5E2DB571739
092A476FF45FA1A1CF898FEB23ED82B2F9D5CB5D32B93F2CA8FA546DB1A5A2BF
35BA5AD1E89200E4DDC04356ECBF3325A2494B23F4737D6B83C3BC5D64B79E52
DD2048D52A9F08ED1C54F6E91D6AB592D479A99BC2C1E2FD6AFD5FD97EAAB614
956895DDD648D3AF4EAD2703F57CC0F852D6354F0EA9B44083710132C014E7CC
244189592FB944D403458FF43F071DF801ED2ECFC22D86B42FF91FCE7E06435B
B294023287025BB42BDB21F7619180B8C7E0F275BF550881FEFF30F902F68758
90DAF09D18C3EB567019261C42C5D4291BAF0A18EFAB51BA25F77DFA44AC31DE
AF4E4A4F014CE3537FF1D47DE4897284B2FFF95A8A508A19C3281F49B01CC3FC
B3860E9ACAEC0BF95204DBF32AFA9DB2C058F613B1A57E4F424403B407AAF881
01D7E9CC89CBAD30C9D899ABC5B7123EC9D0708FB4A2CCE7CA5591627DBB372C
C1BB9F7FB26DA3444238CC33E2791CABC1DCD0BFC59A202EB74EE66E1D478AA9
DD6DD5B53BAC23802A803D3D98CB9FED3EE73A7EA14958017FFAB0E8425EF42F
7E33F87D014949B54B4C9A19020D5F4C3AE956A21449234E719C2DD135D316B3
85F98526CC1E6222014AB12C0785CA24D2CA93DE0681169A88E0C8C0AF9F135F
7FD494711BDB12C2B9B8923DB092390E4AA069E0BC26B39C6C9C9246F8DFFA8C
EA79A99AB0622795E40F1E43ED4906BC6DC19203559700CD83DCF3EF58FE4886
3B4C321A450E360B5B7C5B6A609FA072B13EC3C093174E4E18DF5C8385DF716D
E8DE763B39EB8C0A4C978003A7CC03888323523B44A0184D35D5FDDF80F59973
42B1D65C72F57B37476D28B54FBA8B3F3A81CBCE5217C8D138D9E07C91552862
0AC3337A8FC5B541D872257D771E3F165820D2CA8AEC016E95579A339DFFB903
77C55FB35B211FBFC513E549C3FCB31DCDA02EEA51FE04ADC08982D829291772
63931A6BF0CF2C4D2EB942BB3D915186E222EF53C533AF3B2736A1252DD82008
1E3821F226D8D45B9E0A9745747E0C16D8AF2D5EDA062C703A602B82325F6EE7
D2BE04AC78D8F633A0EF96C16D45B427465DCB1466D62F4436EC6E92FB62CD88
0C9E803E409065E158DA49560DBF90604CDCE43AC238288C127BBEA082DE33FA
87A83DAB9E23311C4F359A700512C58E83F41C1EB95705A5F87B523A22C0270F
D4EF898C821C238EF04DF7BD7343B7724669B5ECE0DB9D6A3BC37E4E46117BE8
2739BDEE2639DF941C2F8129BE4870FBCDF58BAD19C9CFA9D528D104702E4FC3
E2037784354FCA7569EDCC745125EB802920BD5430F74AFF144E8E2A60BF74DB
72962858D2AD9B66085E1D788B2A0F0A7B9B78FBB9A1D7D70AFD82E09430FC45
8CEB7C4CCE026AFB6F99AE327AFDE181B90C51D70550EBCAF5B2093E36A61F89
CC3B6C73ED2387A1E63212A3C16134D7A15072E61E39663D742EE1B3ADEA80B1
E8FC03664C2A432E1514664240BA7C78226D4E8ECC5B15E9B6FA5421B6DE423A
1EF22B2D0A83C48263F887FD33B0CB93F4C694C124E3C0345394D2ACA81933F3
C9923BF5DBC72EF9EB9AD584935A58676976DDD2B6E118FD1D415E0C2BA0F4CE
D1F847AB15F07EE41E131C730D6B8824190F7CF54F6C86A39390575D5ED4A59B
F74D1818954E523A580D97CC9E7A0AD30AA62480636B595CCD064AAA8E070D20
DAF926714CDAA4F27033991B1F87394EFCAB95D6A135175785DC7B085956E243
31D90B9E85928B70D4482C86EF35DF5534F5F0CE9CCB1575B23140097ED252C7
54F81229EC4513B1BCCE88D89ADE52E7B5996EE6BC32FE658EDF0883371DAAD3
E660F09D52090988A9F06957159A569F6487BBEB0C1D62CF242FCA1485E37412
967A45B574790D727DC68222DFF726FD162A10C8A16B2F5431B34B0B08C970F3
9BB0B33254A1DECA90548361363AEE238D66A94BAD615F1FD662DAE00DB12C5D
E586BCF89071C9EB5BEB228C5A1BDB415F80A4C9A27683AA50996427D25A249F
91DAD0118966EAEF54FA539E5775EDE550F1A02964846FF2536EE22B69969FED
1F5C93333BB80DCBB262079366B9E331D0A0186A6C35CCF2DFEB71B17AB6126C
F6D19AFCE4D32E0DC97C609796A4E605530E75A42B7E1A3749AA9FC4DD0ECF6C
D17A436F8E2C82F045F6C995009C1D967508BCD4064C3A65B38641C2ADE78C30
BFC3C5B148357195613320D2618AC4BD618B14E85CEC3D63192BB5742B728F52
05B1E8D3345EB3D72595DA209994692572B009C222FA80259F623646D8005ABF
69620C1D5FE90A0019633BA3DABB62B946D56AF4DB0EB537E69F5CF890E46CAC
A80FB3E3FF740B5E5AB85EA814559AF7FDF1EDEA389F81A79C847BC4A5F34FA9
5E151D196C5C7FDE64CD4B3C1F84255758FF27A936E7AB8618ED22A9E83B7C85
1A22E44430618F8FB56497612D332FE5F91EA3074576895FB11F3EC763612B2C
CE9DC9B028EAC6538D62DE7A71EA2EFED76512B3F8FE3FF0191A1BBAEA9D4503
94AD4A2DAACA192E92CF195742D5AEE9022A2644AEB12BE24421CDF6F1AB2E63
235155A2E98E9921D5568A5673B23AE113B27C840C2A5C22FB0CAAB9C88CED7B
6433BAB933303A7D07625363424D4E83D3930C04C7760931F63667B79E809F5F
38BABC3D344ECEF6F62101A452D1E085C3BCB3CCCD42B7A552F5C1086B66A6DB
E415E917BCC939A9173870BA379B795551B076A423CD9C7AF68881B70D4C0663
7DDBD2DF45B45106E140A1492D6FFA558B71889E22B6BDB4E27B5535123C1F5C
A7ED0977C38DB1AFDC141FDB3989B4463833B6E499C06F5C2A8748A7F0D4DDBD
C4986620D762B14D45C8693A68A3B87F5E691C0F93D5C6B4614134A226B66760
F4607752DF8677C0397AF9D0BAFDBAE100951944E8205963AD84F305C99A04E9
DE6CF33EA1C2533F09A4B36CA6CB9A4F911431C1BDD2C8142EAF580537FBDDB0
4154DD1C27164288A1ABA66A60E06D85970FA504499BCF9017D11C9AA761F3C6
F69BD096ED62738281D2ECB82FBED648C292D1AAFF87AF82D8258EF529164176
6404CB5CD95D3946B1656F6C1ACB51B108F61A9BFAA3E9D10D4B47F75D05CE2D
81DB06B129721A963BE743865B4771249BC09203462F95B302B8CFF733E1922A
18164803E18FB6CB61F2E6250150868450EF0D06C2ED93F37B1FC1A124D3C962
46F2E4FA72DEE055251218AC451F392D5920CB1A89E2346614DF51FD238AB624
FE17F016DE8232973DA1592AB1E7BED385BA0DCDFC0E46F19C487CAFC05E368D
D03A840FA88B441BBF72EF9EB9F35D6FD0DA57B9BE93E39A4C63D2D2200711E1
FA605A64384C2F529685F965F25D9E0B3809BDA3194425F116B667887F864FE1
4B9986B90BE6C4280377C1302518129151F4039E69F162D67BB5DB67595670D8
2DE5E4797BF8BDE5D7CC3F8237395F6037F0180333B6DDB480D7DD9C0DDFF09E
AFAA8D67F25F80B39F4A584B970E2BA67CCBB423527AECE390C311309580D533
4A523FE90ACE1D6FA74D112B40A94279C7A43D4DA5AE3C6FA14E23676EB1E1E1
F154FE5787538375F51509A8EDBA16200C53E86A2B23B8509D9BB8356D008ADC
4A27736C9E61DB7F0FCC062D4E32B9D21CB37C99457A66D7479F81B25C8B73BE
5EDF2461F63CAC91E253D1DE2FD3AF74232A361060B3AA3DA323D38C5B7C8C4D
DE19EF4D9BCB9388FD2D7D9BDA91A4B78B1DBB94F399DF2E1C1072A355377114
08A0E08D2418F480491EB93BA361712249216898904F052A50EF842158C73C22
AD151107C43972B64E6C35D2EAC05F1901892BE9B537021E9372C4C1353FB4E3
A363CE18EBC3004D1D28ECAA06AAA93D787053C99CD4A4BB936F109F75A241F6
F4AE1AC91793F0254037EAC872D5998FCA87B2BDD8ABD8ABFBA9D53C42A61026
E5BDAF599739777124329B7CD8D07BA01C580A70F81AEF70E88571AC7D8F4E26
2103B3BC5F55E235A90201A826568CF2C21EE1C05AC0D529C5B2F5AA944765B7
D49D7C68A5870CA8EF19BF36BF2645040109A3D2D98CB563D4CEB5C030A7D2F3
B2DF626A01C282FEB8B53E2972147D9EBD179E3D9F163E941531279F61DA43B1
A2A5CF91105E58DF43B5D002B507D203C9F199C8D54B46606807DD209828B487
3035778BA569D674D2F14281A9EEA6B25389EE36DBD01F5352A1054C508674B0
D9833D1E723B764BAB92168011E51D1933ABAF4F6CA5ECF506FAD83A410989B6
F51BB7DDD2AC5E0C3B0637D4B3683E15E89803EA67877FDDED97FD7C9E73DE4D
6D4ED370EFA5B210D548E83258BA5211AF692F13ADA5048B28F82A753782D0B9
3F11E907177CA545CF30FE4E46D2106CBC95F6F3E6285C0BEA68667BCAC92103
EFDDA76049C30D6BD3510CB3E47EEF53A7225FEE727ABAE056847D3433323589
0AB5EC44C53F5D408417DF8D8AE98E2882439FA81903941B363A7D885ED21E6A
A466F61345D046731E6DA80678EC9916BB64EBD31B7D163B7D007B43C1294747
F3ADD403E3C9F6D68F61DF118698B1F3280F90A2FAF82D4125EA3FA457A2B1DA
59BA39BE0765A7728CC8E15684C683D992894DD9C5741EA5E2D1FBF36AD4440D
61C4D899C01A1023D0FA0C9DB06672A6FECD532ABA4DAEF7AAE796B0550FD7BC
C8461190035EDF5DEE6F02CDD1781911E07C871BC80E6252389EAD4DF1F0DBB3
869B74C2373223236E809ABE9617EC5334D964597367A2AD10641BD2BE6FAA00
21141F2ED6373D11EEA2A32700D13B25BC43FCCBC12AD7B5C6FCF0CDA7AC572A
A553CDD41FC44AC1959D8C8EEC585DD4418729EFCBD7E8A707C4DC64731E964C
0A51266454A17DB51B3B89D7A218954721CABDD00A51A9D83D24A24FA57E8E63
3408FF890A4296F3E9B0D405E9DEBF3A788B196F2D32A270159C138B2409D3A7
9E946E568004218FE9FC496127045CA4F140E046E6DAB28FD7BB304B9CAC6B95
F93D4641288A4EAFBB2D0843AFEBED10D99DE4102D5AF94B21675A44F4305854
1FC740549496AA731D318CF15E5DC2EE5CD4FC85CEC5A85A6059067CD3D9020C
E8C03A525E467DF8744A8B6DB57E04C99BF7F56D040889D4DAC9B7B0F3348A1A
FAAE48BE88E0E16B8E33253F5E182C07AA0A48FA9399449616273B7D5CFC9723
D372B505D8299B2AAA7A05FCEF74AADC754D33163A49A7ED668E1A6ABEEB389E
2DF0DF373FE5AD1F7D9D6AE5E08534675AED7935DEC964AEDBC7BEE2EBB7EF55
69EDB5482227E376A7B2A9AF7981250CD828FB3CB34BBA039100AC67510EDE2D
6AB5B07064C07CCE41472971848451A245DE941F3631709D78D7AC50326F1000
E36F3E9E75ED6398F61439CFEAED6935F88625620CE2D7C64250A8F2D0FED629
A90DE4DAEE9941D44D8D1E3A19399F13B93D9B53ED01AF07A0FDB7C9FBC784A1
C9E0506142709DA9971A57FE40506C64D2F5A6F86FFBA5C6267A2A20B8CC7B48
B2DCD0D98EE7E0A553ED1C16769149C157F312E5A74DBF6DB0FBC21015D7E4FF
ACA95D6EC268E5C4E64CBF408D3825FA54222D3F56DD91A409F5C00077A7B5F0
C62D5FB8B197E71BC91760CA2142BEC03AB7FC544C630869DA8886C5917EA8C3
D12C66A4CA6D951C5831F822FB3B519B88EE36BCB784B51270EE6193324087FB
AE1FA98EC276F7A34A8C0FE1F0985292F95A2BF4C1FA978B5AE273333614C085
3B13A2D88CB67CECA9A1D3498D569DE012062EFB4D1984C107C8FD9285F08FC3
C879AE6D42023BE0EF466319C9B1F9D62740A6C1E4ACA130DD76A67920DBB347
F3895CB44BBCFD5FD8B3D978C779AF8848058B25DE0508DCA7C8FF82B7CE2B2A
34C7E0359D0ED47D8BC7564460976101B7018BD702271DEE3CA37C242494FFCF
3D85EB56C1A83904F00C6F8129E347C6489FD4FC798AD861D08F567012568991
AFC0C3D74B014F39C5E151F333B30AC0F5D8FD5B2308CE6072760DC60A58B7C1
575DFFDE9F2E531E7DBCC773CDAA6FE10486B53E5C74A64CC277EC6C98F92E3A
81C8BE23BEE4B7EFC230F62253BC1FAB0FD1FF6E8BE11546D448B07D0D6408A3
845FF656EB95B0FF6D94E602481654E5378C8D137E3A872753CCDD98B4C26B5F
595CADE6F1EDAFB2F2B0B4D2ADF82AEF307CA57F10FDE34C570D7BE76A496A58
242F51E7321386FD2CC75D2FF2B9729D821A95E17988FE9BEAF0FFB4E80D0E8F
E859AA2B6FEE25EA38267E95A205ADD88257D3853E684EB4A9694BF444F28DA1
C82DE8176A0B047CCC1069527F86804DA275D8C6F885EA2753102D21572E18F9
A47F8CDF87E6666CB5E72F5BE5CEDB2C6000683AFED2AF2CA96FE37C42758397
C311E0186C57D118A878A8B1402116797149C20FD36B31583A27459E325B92D4
A4D63EC9131ADB2503521B69B90ECD4E8F51ADF512EF4559B770873C6CBF0A66
D8989A6B0111B8A21238DF70AA3A421603ECC1623D32353CD7684A1DE7648A63
683997CE491CAA407EDCE272CFB83AE2AF6017BF2838BC4C0021571B3CC54019
500DDC798B57B6D2B59A6800D6F7BD0FCCFF837E1CD0A59D88ABE3C8FF2D1E29
3FA7BD5DCFEC68DCAC374CC58F53516ECD13D63281D944E21C27D5FE8A6DE4CE
C6967E6F066F7E02555E16488729BB25ECC6514500A94320944D74EDCDC0095C
2342A0A76A0945347A9395480B808238B4E85B124B81A22696AF0B3C97E0C970
9DF0F438F47031D1A13C84DAAD94BDB31EAFB0F696C4C97E374632D5969859F9
F16E68C2B89A1919AC43A62DE7FC6144F14EFA0AF684D22F4AEA4E3CB1A3204F
03427D0C1ED063F935C93FEC0118A77699953FCE2F06ADCF9E627826E83BEA4E
4804C07814F6384754D714E42CF90800DF87BD77BFD898EF9C75EDB10D6EE6A0
DCE180C8257A3ACC1122CE497D5BF45F01304C5A8D39194EA386994A41063D2E
2E868BBDABD125219528AFC582C8329607108080263EB92C9DF6DAEBA5C2E0F2
A78962E8A8CB29C6584BD23C0C34D077E4EEED50C54D6220E3BD7EF1CBA47227
0B4D082A1E33222F1F99A29F83638E1CEF240677571C65640378033A2EFAC8C4
615FB3095F3C641A68A0EF3B9E260EFE3AECF3C04FD93F34275355A78F07EF72
5DE4996CB55899D4EF57CFC7587962AAD68028B2A5162FAE42F33C6C8ACF74B4
9C313653846346846A9D5A0DE6141FECE531A950C0A07C88F66C2C6D8FDE6BAB
FC4B1D672CEBD691C1F29AFDA105644D65AAA59E6344CCB7E5D3B7978CBCF48F
FAB72B321EE1257B57B775F889B9CE9A310A947B6B42083CBE06F7EACB175FA0
9D2DE49226CB2B2173FDCC7B6FF4DC48DE847AA47FC8A562E91B485C265E3F36
4A4DD82BA880A7A5CD59F8F6000E1978A9E84A3F2A2F0D5F869F8AA462B3883A
673A976328E1F0D54CF3F77A5EC6E370B94F19A54C3ADAF77BFC22A207378443
EF6B051FBBA7EAE4D5967EC3646F547C1BB5DC50F33404F5426F7148BB8FA709
AF1344271173529372AA66D8D7C14095298EDCFA5A018474F811BAA904267AA6
08E5E09EB09A9740013734F63ACF54AB05DE16630667743798CF87A13A3A9771
054905A58B78CAD093CEBAE7ACD81D0B5A2CE1E2C033D0CBB3BF6270622EEEE0
0258C659D2ACDBCF2730C10173C147DD9A770AD2A21749E078A40B353267B2BE
5B8178E6B7889A33771F86276E6954DD2CAEA78801DFF16D0C5CD183D626883D
5D0AD264CA55ED1801D2E1E0890E1A6EC8766C28863DA14FEBA50D6A77DA0A0A
BD46A72802B0912C5C20B3BCDCC053DBFD810CE0F29218B2D628E86983C38600
4EC0E698FD3C70EFAF4DD5FA09F595719871E5212662770E9DED1AB7DFEA1D0D
52C644A10ABB7CBC3AEF2C2D097F970923B9735B1544291233DC94FAB384DE76
2FD19BA0526D38D7A06FF1BEC3E9A6CC520FF3C45BE2077E850D4900222962AE
373487FAC7CD5D43E2B714A4F1AE311FF2EE1313AD425A0B1606AC8BB2B72748
D0ED3FBA42C836B1FFF0904B5E7D9E558D3F664D554AD0EC1866268A8C63765C
5E4FA0FE7042B80B0E772F332A863DD328D3DD0C2258019A15331E5E45AF3416
1186E06076068BA5EA22915297CBE02544DBE77CCFFF9E9C950ACE4909177160
42320E10B3A0886EC6B9E88EEF2F9405E6DA8139686D99F9D6E3F90542E9E515
490079815C2000B856C14AC12D7012BA389FA76416155347AB064A53D346628F
FCB7CDA456B630B21464C962FB52FAE7BB7B1AECBA92325205A7899A68D4F701
65A8DB7B3E80326FBBCA7D915592A91BEEA7BBEA6F27B3C606DFAD347B9B9865
19239BC8740939DCA5E64764502E7A0ADEF99BF5391BB0A2D105A675AB9E5457
B9F9954221EF653D3DF06FDA515515BF52FD45320721CFC3DEA899470B01B60D
700F69B8E1F8786DA07E2E59F26997929BD1F8829CA8D4D2187EBF3D9A4DEFC8
E6D8EBD3CF2055CD24134E2AA759C3FB5C1288DA9B330915405454F341E7B705
B7CA58153FEF6A1A2953EF2921E8BE24A18E7B8F53122060B33CEA29787237EA
3F3B565049E8A84996483EFAB6441086E8F0262FE5AC4D09DE67C7A8FC0A06F5
547575571A9034DD2E643FBCE31CA2C9752717731C4C44EC1B7BBAF5C7A30679
179E122B4760A74DCDD9F013A9CA998EACEAD92807BA24F1D42A74360953DC30
F9F5643B371973644E2D4C0D8D83BACD861AA5F8080B53CDC0DE6DF68B3FB552
D6C681E09F5DDAE10F3DC6403EF0E63A552BAE93341A5EEE215A9235721AD923
F76456CD20A6E891A5322A243DCDF196B2BB9BC8E30AF91261764357A341EF4B
823CEF43E8644DB6B3A2381A9FBDB39F5205DDA0CE49020B37E90E082770C236
E9752B8EA6D2DF8EEF02B2D029B166D01B4443610C3890827F36D843EDA9825A
53CBD2E0B0C061172A638BBDACC51CF223C3C0652F948F5F34DB8D13169A0D1E
1DC5D54F9300B1A5B2611BFA293C0D976391614B1B714AF024E44DE470626B3C
C4C40304AC1EC0BCDFB5F061E46EB4CC354B338282CC701630B46F384190A4B6
0105290FA36EAC0330B9964DAAE7C91D007B49FFA4733CAC55F4D5236628D23A
A451FD417573EA5419EC17D4DC2F8C825AF5856C05DBE93D3D583BE819301481
F0C629CCA58A380B15661572F7550312D788126760043AA1D17F33855F919B01
3793D6544EED5232B131D9DB03B6B204E2A4CE643BF544132D5CB5EC6C1DC9A5
B789811DC4B823F4656D01429EF0DE4648DFD347D332967284EDB1BD89905607
A044921308EE8921E493A268945051B076484B9DA5D2B974375E284995622528
CDAEAB3AED4847AFCD49E7BD0431B82D1A9139850AB387D2066B8F8BC54512AD
907519545756E5867697620E8BA71F30D8D7335EB9563552F76FD095DE103E00
63383AC731287A3D2F2FA7EA944A1FEDED9A2A1841400C78253F048385B8E5B3
ACE55D091E59214398D916D637075013D732621AAEE0CFE2B5B3A50520F405D1
102E6C4AFCBA09C73DD43FE1BD5F570D95907D0EC60B305581283CB27ED6F4BD
CF0E3373C07094B69A30C45E017935384699EDB8A96B31AB79606207219806AD
09C439797D92E1AC6862A39935268EDD927215ADEE39409B207D1A92020E760C
0678EEF70A0C57141A7D0ED44BA1581B137EF5F696334D69EFA73113B80D4EE3
6F8C1D8EAFF2CB0EA7EFBEEE9E9F07E453449B36545EAD1310EF85829859CBE9
0E79239ED9C23CE1CBA8D92E24EA89829769492B501B32422B8D0101B217E00E
DFFEFB4D0D55018D872D68FA19FC72B165EFD3B98B75E468005645283BD9C3EB
C78C08D5A91E39F5EFABE1C780641FFBF85B5C17F688B8AFA1CA77A79A8DE8E2
E4B76933433D5CA15E5B3F741177B3D358AB127B6BCD165190E6CDF9DA6F3E2E
83CE002865FB718877F202487188A7BAFA087DCE70D0653E65E4BFE23F41232D
ADAAEB82F55F67FFB92A7A0082B27C8A0B398D81A09C337B06F20939D3CF1488
C24F3F5A83C0424D3C7EB8AA09CAB4370B8C63D3FEF9656E97DCB877AAEF75D7
E42CFC28C7474753A387E4FFBF647232C0899E99C35F842BE097ED51507B7A72
10E0F6DA26C71CFF6FAB5C6D93847E27B311C9F0CBD07C2D341BF4285CF359CE
F2FBC83347E5AE905F8BC40B48394B3FF700B8C649939C20625D08D88F512800
1D691AF317FC701EB7497813BE3D3E65F76EDB32BEE87C3BA92BF9C2C5621B3C
569A1A42C8F37D63B61907250787BB1A10438458ECC0038426D872409C84CC5A
3290CACC26F4BF1B2BA7CF2C415A7FFC408CFF5FA033D1B5037B5C0B97CE8C01
C0D56AF326F4E0AC14D1C5CA1FEE84EC7B1C381CAC8A4A7F5C0DFF5FB41FDC76
5A82600FCEDADFB2C6D911208BA3132F366F459E5AA3F4CFDE1C073E4506281C
4320BB711F5BBDF2585E14C22EE94DF1FD0488F8AF3D6BA56414E7D4F925B239
738A7ED48D0D4BF90B1844F2D32585F23941F737402AB3C9EC7C756053DF337C
76C2CD111111624227B5449CADECD7F152B2E63CB544750A995094A5FB735306
5AC39BA498A5C6C4ED711F973F0DE9CE0DF5836E0C42CF2B6957C5C19BE22167
17C761A32C7A8EF3EF0AD941735B1DF1083CF9EDE0778C2DC313F2DB78E636A9
A8BEF69D7700F9CF287CE9B1DB849046A2EFD36F9B6DD0CF8A24544416AA86FE
79716B6081D8D1ADD5629E6D46AFE0BE7578B7A68258B467BF9E202B6FCA9E88
424065F5D7909B4DC899719C65729002D63E3102CEC57B8A58D379DBDA1C8010
578F37D66274A68CE7D2868DED687F4BBD9F61B9E5B7EB523E5955F0C3DFB2CC
CBCB1A9A16DA891583A75513BF55E73C5205A3825D457F3E45A50B2788104D0E
BBEF6436AAA3C6FB4AA1F78A204F7ED5FD97D9FA99A969DAFA82D102F48AA949
DCE6F28F677B810085C2C4068894EA433679FFEE4C2E34A98BEB603BCA5F6824
BCF389AA13B477F40C58AD93146B043D62E2A157F5F16D7E37404E35D4DE74A0
D653470BCA7D30C8BA13405EA99D6F67AE66AA0F11448F63994D18C050E59DBD
AC8F03B1028CEF6353AE43D0CC6003CAD702C50DE907FCFF50F7B0DFBD8F7F85
05A28BF137563E708016B6F7BD076848509E9C8BD3A902F9AB900BC823FC
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
%%BeginFont: LMRoman10-Bold
%!PS-AdobeFont-1.0: LMRoman10-Bold 2.004
%%CreationDate: 7th October 2009
% Generated by MetaType1 (a MetaPost-based engine)
% Copyright 2003--2009 by B. Jackowski and J.M. Nowacki (on behalf of TeX USERS GROUPS).
% Supported by CSTUG, DANTE eV, GUST, GUTenberg, NTG, and TUG.
% METATYPE1/Type 1 version by B. Jackowski & J. M. Nowacki
% from GUST (http://www.gust.org.pl).
% This work is released under the GUST Font License.
% For the most recent version of this license see
% This work has the LPPL maintenance status `maintained'.
% The Current Maintainer of this work is Bogus\l{}aw Jackowski and Janusz M. Nowacki.
% This work consists of the files listed in the MANIFEST-Latin-Modern.txt file.
% ADL: 806 194 0
%%EndComments
FontDirectory/LMRoman10-Bold known{/LMRoman10-Bold findfont dup/UniqueID known{dup
/UniqueID get 0 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
17 dict begin
/FontInfo 9 dict dup begin
/version(2.004)readonly def
/Notice(Copyright 2003--2009 by B. Jackowski and J.M. Nowacki (on behalf of TeX USERS GROUPS).)readonly def
/FullName(LMRoman10-Bold)readonly def
/FamilyName(LMRoman10)readonly def
/Weight(Bold)readonly def
/isFixedPitch false def
/ItalicAngle 0 def
/UnderlinePosition -146 def
/UnderlineThickness 60 def
end readonly def
/FontName /LMRoman10-Bold def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 0 /.notdef put
readonly def
/PaintType 0 def
/FontType 1 def
/StrokeWidth 0 def
/FontMatrix[0.001 0 0 0.001 0 0]readonly def
%/UniqueID 0 def
/FontBBox{-486 -295 1607 1133}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA0525392EECAC163E584A9104D99AD0BC
1B1844A0E222653FA481B8809B26A46F4C483A5D7E95816EA6582584156CFEDE
B994ADCFF4645140E3617E4D7E1B0E4541CB9F562E55829B4DD880AABE2229E9
4A9FA259A734D29BBA91BA1E2055CBEA4339BCBFF98D32CEFF11F296225CAABA
DCA10577A5D431B714726C1278D8101ABD1BD8D0BD0174FFF9148F8C61C241D9
2AD360A28616CB4A0670C1BF105A2B97A2545FB4AED6E864068CAFC11C1B6D53
286E0C557881AFF6159BD803AD491E349272C4420D2E2274C589D040CD3285A8
9B4CF82A5D6CDBB3A3687E0643D2A256757CA467EBD41D83C4068B5F571BDD53
8E7B7B28273CEB38BE621F8217E7D0555F034EACCC39DBF40BFD9FA372B08F97
2001D6844E132A16F34B8B7234D5EEF957099FA45E43170CAA6EF70241E1A720
C1322AA56561CAC98CE90766897AC0611464168BA543C5664242BFA41B3D7688
3D1F10E97CAB51F4BE34CDC94C0EAC376AE280720C33DA72613F8C2D823AAE57
05F548DB3DF8D58096A65BD301502685F53ADF37350A323E263CF938292ADE86
4E420919C2AF30A8276BBCE4CFB3684CFD43C529A2C3203616CC19D8C144F695
88C9ABC4B49497A29F2E748D7C8F5637D9C9D7F057BC0A7ACF91BA7809044D7C
28A2C3C0B39DFD381EB48B2811A3B289364B9AD88B05EC6A2B79F841BB4599A2
76A8D31BFF321CDDF6112BF0C2C1E565C889A49EDB7873A2A09E0B2035E8E5E3
E924F96B97B49382EF212BD25A0E1CD7F132B4D69A79D085D4B3B4F7AB8199D7
54C5C273A119FBFDA9F913E211DDCFCE950DAD1CD18206D7A505D1F6F0BDBBC3
C6692C9BE7A04DA687BC96166FFE480FDDC1ADF8DF328CCBE1B11027E05957EA
41C4F0C0F64941E6A006433B78D17D537004045CCD22F9B96D8120CFE40CB7A6
FD8FD92293D3389F42A29F4F61A8D4A782A141035935D0D6DB2BAE585A54CD88
012870FC97E3FDAD1B5100045CBE72B72E82A6E26D2FC22656E4DE50233CC0BC
C7A54B9F67758563267093C77A86ADFB33603FB3A876C770C80B465A53F2F2D5
8112FDE19AB9A4079E0C90855C51249F2C2240B6EC1B5E300C7F388406E4C645
9490E4F6CABAB531EC31521D635B141538F192D31E24E9D288F43A978909439D
7A156AC8F37C032256BB99967897E536D47EA366FBBC2C9105B7434040077762
A7BC54551705281FA3DBEA2D747BF4EC1FE15303621A155454615BA3A24D8550
213E1F557AB8C413E95EA8B6DD3A6346761E89912C75A4DCB7DD77032774ED6D
B52C5BDD31971EC182E6F85DBED1D3913BCA251192A91D5EE109EC89EEFD4DB4
B9B2E9C884A880494F50899D11BE76EC06E5BF85A1A0F45C2285C8FD8AB16B1E
C17403B22A36E5D2CFD0A1D3F3212BD351E35FD0E549FE19DB81C56CD5055CD7
F524CEF0700D89FDFED2693B7F44978B350AE180C2CE885D83DF676B3995976F
D8A571A77B574D6427E846C0BD15A8015D433F8C71D54471DC7736A0C30EA97D
CCB223D7EECAB5A829A7A29C42CD6EBCB1ED62EB09ACD60B440B4B15716DAC2A
A7D4EAEB84E976434D6CE7D221FD1572A0EC8F3D6469EA70C409ED13E78B4C98
3DA122D6BC79EA3A1963B94B9903CD874CF329240E450562D2CCA1906CA660FD
CFB60E1189D7BACF8C6A5CBA3D75F1EFFB112F0A4D9FC5B6A797EF69C179ADE3
33C4CB22B633B70F38D563819330DD52912F3D12415F579F25F6F6C8B0D9FB1B
359EB83E522342753698507BC1668D127A59D1C07943A5C720C4BE1B5AA3E1A0
0E3B6A07408043CBFAD9A3BADDFC68DCCF67E301B6BB94936F23D3C8E3378EC4
76B2556B6F07D62052CF90CF47F56C5D0F76AD6FACFB4EE3207884A85AE50512
84534C1F36D962ABF33DE5A6612AE12C94802E4BC10A55DC4DB309601C4181DB
C8C580ADD685C538E058C6917D4D2261EF3B27F4F84A27603543947CFEADEB6A
24588446552C30CAB001D5F9DA84FA530B8B1DEF1B58D658AEF260EC161B2D95
89EE8C8334F331F8E3CBE52FAFE31266C2CB600E2D63BCE010820E28ED212A9B
5E86CB221DBB7DF956A4BE1571615EEB162F7ED5B36C3AD33E1B31038F25819C
130B7BA3AF2B2D23DB41D95C366B9580053E25009486C377A60DF398D969E599
6187EB83174F748F9F5C6E7C9E45C243FC3929AD9700B3205A433016971AF248
EB257228DF56CFCEEC3CACED14896D6034D50A5444881CD321E40B5916E65AB7
44B6FD259CC8D48D85F6692F09886D982B8E51F67A14B5B2C6F84E9503B6429B
70C9A6700FC0CCD8482EC70CA6A0A4A162381D825F45C11FB049BAF383477600
CD129C1030E90050D3C11DD57AF9F5F1B4DE109C3E06915E3461C79E71BD7FE5
E52687C6198BED338F843FA8349F660C272D54592FA44D9768020D41EAA7F6C1
A9B682B344B7DC94AAEDADFFF0C88F69F5F803FC20B59D8A94F59777FF203C06
3C4C73D95745C61429907F1246475B1ABE516106FEA01630238DBF05300C35CA
A9F686616449FE094A5F910E70B9355E1549DDFA2C1693F085D63D1FFF71113A
DBE363237782E3B2AE143E60069683917D8D87F03634B853E32D9E7581D407EB
E3A42FB15333B86668856DCE1A2ED96EFAD0CCE878AF9550D6F769068B96F2A1
CB79A6FBAD1E171AE3D8D4277E0496F0FF797C86B6651B2647FE0CDE1A2258F0
5CBAC20AE0C9F80EC18CF6B0D1B1310C75AC850FB4C642FA3710C2C990535EB1
4EC4BA6D11343AD3B5D2A864498651C5705B18F8E9D0D833D2160643FE8BD1B2
662AB55A70BE52BDB155F1528EE862FF17A34710083C6F7294C927613AEE08F0
0707EC53E1CF114795631E3B14687B9E351BC7B22CDB96A25ED403ABCA3F1BB1
4DECFB18E5B9676BC1D51ACF5AADB51C830D3375A6841B9EEC3438A7DABAD4BE
A1951EEE0ECF5E0BE575C26270EB3CAD82463F87C0BEACADF4491AF855619D32
6814A1398DC93AAE53445277C899FE86E54B8BDB1490AC76FF84E41E066F8122
9CE2F044729C66D790E9E9BAFE9E1DAF22C5D496ECFD6D06B9A5AFC8C8C46BCF
F335C364E1BBCABC0CEF169B7166EADD48DBBD871AF4056C369F0C0E1EA0527D
FB9564EBAFB4292516657B11080A1AA7E9E52FD0D2CC0989983DFF33B0CDCEF8
101CE47C9775B7A95B3DE028283DAA7F99A55DB028501D5250C1B25D9E59C148
63D38148F0F7F963A4AFDAA2C9B47BA8EBBBF0EFFC0D29E5F2BAEEAC3B948C83
9E2CACA8ED0F93C12431FF2740DA76975D44A6AD0CA0856F18D3914D1C0CAF2F
2A8C3E8248880242AE015219D80BE96851F00D0245484732D41593C3181479A7
C6A44B54797AB7402A7E4EDAF950964E903405EEEAF0EA75D03C6BF5FF5AB60C
B740C9C49ED9DEE46462D609F2B9502AC23422D42CA4924F5E285F62582DFB8E
B4D1AF5FF1D92A82A96482D08296BF2C981B2AF6827CE192481059D8D94FFA70
E5D32BD37893BFB424316E1AA4B38746A4ACA9B0683F08977CEA9816A86BFFEA
C2236B6A115BBB4C4FB26D27B15E61901AE90C61C7BB0BD60BAEB18A4E15591C
0BD58E7284386F6082C2362E4CCF3E66ECC33C744622635D1D65EB1583EBC215
20FAF42680772C1BA775A53A2C644ABABB47914DF3ED2C719753BB1EED9C435A
2906645116C02BA07760B6EB83C36829DECE216E984BFFCAF261538F608C93AD
F044C39BD2A560B752B5EE96F5C3BA6E6CD5AA138B168C23814295B0BCA193C6
F394CD7FA1132EEB0C7442A63B99930B70AF8F895166A469A58C885C06941969
3DCFDAD036FA15EAE44A089393FCA362BC59A995FE5430B39CB5EC916B7B772E
A22AF269313CF93D62BE9F3F102122C52BBFBFD12E47363FC5AFEDE35069E38D
A417B8A345D4C31773431AAA0DCFC1B35B907F5C256B9AE75E6819294AB24E86
067FE0FF1E63EE69BB13FF319B6A7B9CFDCA389F3C1A1D113CB87969B0370D0D
DB829296DCB0FFCEDFFF8BCFDF1D312FC0FC0162F47FB4D8D9034DC92A3CDE05
D1F89C5B497B45B3EA9A479B91525E75308FA25FC81B91DDCE0CA3E5B551096D
D5762189E8B1AA614FBD54B3D4EFBFC63A3364659A91DDBF843D6DDD6AE495A8
72463510543EFFE5DD50FFC2FCDAB71C7DB780BB6D7ADA1E291A67DA9DC8C112
D33C10AA87D2A4676E334934D97ABEBD25542746ADFAE256888405B15E302C92
07A071D513F3D29A2B1CB25103C64803099393336984A0495B5AFDFA147835FE
0BCFC55467387E8262E46827BCB1225493138D2A491E774EB2E384A9DCE4EFC7
89DC62ADB82B0A55BD56905DEEBA41FEFCE4C848E41EFDCB5AA1EE1DB0E3AC05
1E6654EBF16CDEB42D646CFEDAA09CC251C84A48B5AB27BBC9E5781EF5D2FAF0
5C9DCA343FC3CD577C8065C008159E3C8D7BAF0A9F966EB9261170ED04F7433A
928756FC9BE0C90A61324819BD29B657D61E2BA950218A3AAEA34711BB3322C0
AB581D0FEFCECAA1615EE015B4701779D827EC6485043FC6C757576EA0E4C8F0
F14614231A27583317CFACE301EECF257B1E9BA488552799E40E102D9E515F3B
1A95605F8A120A04A3E08D6749F21CE313BD5A82A83EAB22827038D5E2DCF97D
2AB8EAEEF6071317CC36ECC744B40C5D496DCB96A463116389EAFF5982413685
01F2AAA493041F5EE288F248EC0484B3A4671A4AF5750ED261A143A594F23230
43C65EE7E84BE6501F47A6606AC8FD7B4105F597D9EDF534831D51265DD59CF4
A57DDF0D5EB9BFD63AE2F4E6D63AB1DAD6ABC5629CD03BCA5EFA1517DF71812C
ACBDBB947946F13842D10A3E31D8AE65F9EA55FD1298567379438CDF8944DD5A
062D07AF05E398280F4CEEC7C3E03466430807A22023B383E39712D0220E2BC9
7CEE34EB04C672E85C20187803A963282F0D558CABBC3A22CBD878361EEC2872
588478BF941F1F74EB99579B1157769C8BEA7D15C97B4CE10C5EB67388F3B4EC
F12BCDA01C7DFFC210EF91B51F8E013966502FFFDC2801119101F88B511FF838
BF7898278340E29DC7B0593BBEA8EDB0435758B2F912FFE385CCCC64126A40F7
F7C34ED8E719F4442BC91FD47E1BA93B0C8B4BF4C285A2D8EEC6E2A0D03C18CA
4063BCC8EE90AC1756B426A936BAED12384FF7FE6E983CB566D63D97119CB34E
5B87902E04E195A5973FF6491BBF618C94177E99B34D229F4027E09BFE709371
22C49507C2B4F3FA7769DB73CD3BAFF3971137F555CFCDC2DE5A13ED881088B6
B60682F4DD99DD79DA95D4DB3168F736647968BDA608B66BAE07DEC4257E7FF3
43DA2E708ACC998C1BB5EDE3A45AB78996EB94C7691A42DD8E00C8781645BD36
96C4B6A1F1F83F5E5F4EDE5FD2D137F87752CA18F8147E983175FA450580110E
A035A2FD1E4BCD68D656301406C1FD474D98B7555DABF80E2C4B76D00EB27062
F8C5DFC7AE8A3CBF623F5E2985E0D4B1971B19A226EA8995628F77E61D8DA97B
F05D0DDA357D29962E535C4110F79E03C885DEF635AE071BDB178910BF6E72FE
AA21C559B945A22203FAF11FD52ACD583C08E9D4AB856B9CBC75EEEF8D77DCFD
4CD6F5A57A05CE6EDF9639E4256570975B25C6C1F06CFDB2FD90379257FAF8A7
B846D5D7690108E2BDDBB7A29E0E16FBA90A782342120515EF4AB7CD1C0D977A
D77AA3B19AADA4001C0A2C0B8421B2F57E7C59C915927A455F2EE0482F133499
46F115492C8F03055C82927FFAFA6E43AB242633E412FDA41F34B777DA717440
229035A4BFEBFD6D33F1720B0C3F10080C12CC74EB8C5288E168E18C8694A3A0
6ECC9C001359DF6DF52D943BC285B007D1135D87323177CD8EE528457C14B635
AF49AD96F4316349A0C9B58C1025782D7534C5486448FC86B1CD00AC242FB0ED
903117FA2602C71401F776BE0D9A35E67F69AD6794433DFEB1DC996510F6E87E
3B4D75685B2E9BCC9EF5096B43ACE3C469D9A5443BD8E8BD8CDF61FEF2585E48
2EE3E0921925AEF973E3F4E5F1A14EBF827DCA38CBF9A44C755ACDA77A499C6C
2DD120123D8604D4CA0EC412240A49E3F8284CF9E8F505D5DBD7BBE242FE071F
EA0094A55ED28AFDA6DD200D31F6BA872ACBEBA94F1FE5920A18A45BBBA26EB3
0141D2358C0C3F47AFF734D51390E769C29DAE218936D444BDCCB32D592B00EA
16242C2CC6BFCB501897C68FEE49A62BC6787664E7B46DCD8497A7A3EADD8042
A46F65EB765A04C09EA527C1F30FD1CDEE64FBBB41C8C1244D3A0E87459AB709
4ECCD020F2318C9F6924246554DC152B2CD12041A9722DAC7684B9DE9465306A
8D780162C658893808C36FEA6C48899C0A415B7516F04AD0E3DC993DC7B11032
A9CF763141BB17A96BCF4D2590749CDDDFFF1DDE48953D685255A23A4BA8B454
334AE3DDD0CB0D5516F615FE46AB09211EE1C037A69B70D5C06F4D57DAFB1629
719E71B60EC3855E96425AA5F10CA1EF4608FE644DA9ECBF999FBF781BD5C692
82459F75ADA02D7ED5D348F7CB908BEE5A6EC51FD6C3C5A6F475A4B0FCE5CF6A
687785282D0DB3AA7759222A9F55EA7712BB03B500BC04C5AC88D2D809089663
5030197722AB644595F7860F1538363ACD2BEBE8205F2653C608EEC3D845B12F
3975C5EAFB9662D5710083A77BDC82ADA7B15D4FCBB6EEF0D1E8D9575AF9714A
E0B564BEBE2FF35ECC4DCCD14C35346631E44F0D15B92EAFC12BBFC57263DBAF
97EE00178A1972174431ADD9140716CBF1C5624422FB5D2B891586DBA34BB563
43B901F6B601D390E2DC1104F91B54A06D57CA5363756DD226AB585C11A08A3E
33D5F5D10E8177B9BDFEBDBD871065E8C41CEFA4148A2827452E7CB712C1049B
9B2F75C8E8D4ADF7A319E9EAC6238093C798878E5D5588ABCC21E16657398D5D
C47EB68012394F7EEB8B381AC7F2971478ADD828089EF0860DAAEC478B6249A1
25B7746D9C18A32F9AEA4E0604D3A3BE7391815E8D7931191D3F7438E8299397
FBF8455F2746A01CF6C7C802EA68A34BEC8C10EEC80002C330C81431E79A500A
2BDE8304F54DC7AE73C7CD20097C56CCD3F7355899D532F378698BB17CB6118E
FDFA622B219121677E28A4657533588CC643C22513C6F69FDE343CE33E17013D
4D0D00955FD8B9DF74AA62D786A28F95223B0DC0A67446B8164AB288B2B12B3D
D933BDA035B201304263EFF2F25DDC4D5E7C7227C76F79C4261DAC82AE92065F
2FA5D6C720B91E6F4A30F183A66BCD03F71278FB2BF0C8A53F8FFEFB8C141457
531E7E800C56BA3B85B8984CD86C91594F4CE7F52144B2D4AA133851EC300828
31A28816092AB872499B916012CECABF4989E9508EC480AD837EEEC9DD1D0EDD
AF6E7780F00DA62502C94A10EC87F2DBA242052D2B533ECF1EF2168513008BB3
CDCE8EE707017DF7E0245E1F1A6B012114F6CC526A2939FAFB6C30A39AA2586B
22C8D6110A670636BDAFD89171B3A6B28090165A85C2144D78776B1A1D36B43A
7DFCF5FB13840016559DACC58E38EC9F0B780C2988095FC3D498C0915BB7CF1F
14F7F5B818ABBAF1BF0EB39F4DDDDB970B76BE54F1C82740B5912A1A4087B405
85F1CE54AC20A4B455D066247BA1E454EF28C6D432330FEE56133F3C323F865B
4E6598412BCB80AA7307A1C978F414458F9A7EC07EB5F04B017BC06D801AA613
EF09BCB258EAEB5620FCF9193E0748920693615747CA7804791C610BB1ABB2DC
C1FC2B75C715283E72EC447BADD5BD58B053A11BD770399E35CCADB2971A62C6
1CA09986FE882C3C698F135173B7A8AB61A1B4C5E0A1295DFA75CC2C2899BCE1
1AEB19C109B24D3F9B5EEAB01EA2E3783E06B4B229FFB653DD3777D15B746F94
E090DEEA37CAABBEDF919F519EC7B7BEDE7A8C20932280BC552ECD04E2C33B76
A0F6172098AA76C5C86005A1999A95B5B8A42DE5BB1384878378F1C629DF4EA6
3E203F6E03A90ED01EDD1A46782159CD556307DBFB34CB35DBCA03CAE19A98F8
114090E2D39F9B2E13311C3E498D5EC423985F63F7BA5EA703122EF3B16967F4
F0A3B64826CD95F02199EFFCF454A40AC29D2907B598267ED7BA6583A6C2EB5F
2781310B9F71EF1D05A876C705A42EF6FBF55D8A0F6FD9E30E3B040CE6D23102
95DE181C0F5FF73B3F4E335518F14A80C4D80AD24605A9B6C73E8B73549BAE43
FF1AD0810A62F516AF093B9CFC665175F29F181789FDFD66939DCC18BDEB94FE
8B9E0C10914971173E8A833359F48570AFB66310F41FD95827878DED76320080
80C78C427E8E051B99E95D205AD9D59D4D45F0C29BF1E997B92063EB4EA7A857
781F5EE012FFA6A9573F0ADFF57607D1EE51B084AE9319C95757E6A86707E321
95B8310BD109A1ACD027A29847D9E293644551A9676AA0B493D7D546F9D46F58
73F4E40179723140F5B593A0787ACF533199348D11730EFF7C25DD5ACE375895
1D72E8991FD4F07A583179EB3D1309D2476139BD2F22787C49C0D493133C1342
D7AD67C1DDA9A979328898D34837B5A08E55E6319BE14383542B9F6500CD2F69
5C452D4993506570FC63D8AD2EBFB6B8C0EFF6D407E7721D388B5A56C9FF8C4D
4EC2F469549C5E2F6230385099FEC3FD0397C7EDA10C345F5F68747E05DDC8CC
FC5A6D77AAC8583B1FB0BC61C7A26294870255E4A960F9BD22F116D5FAF692F9
CFA48CA59FE74FD4279A33CD350CBA7490B4E649DFC1DAB9EAB216693979AA12
489580229DFEA4CF551103450057E27BFA25D69BCDD03F4BC399F6BC4CC2760F
7973D6FE77F7AB2E72FAB2848E03ED4E13B10FBC49549701D11DD0F209FAD8DC
3A9AD349B8B2ACC2214FCC5FA24D7BD9FE7580E9094A96AFBC940EAF782A3DD9
7E9D9C38B45594AD68EE45E9263EBB3106F54CEB953F0C16D9F1CEF47274C469
0FA0609894FBFBE75603A0A117C1419DF929D29EAF4490A018F37FD17D352B30
3F2518E05CFDC4DFA697683ECBD1A0134F98AD750DD893E306CE5698A8FAD2D9
BA1B570D16F84EFA1E1EA8D93C4F30EA097BC050F20460D409116573C33BCE44
A458C5F5EF1602C01D3283CB3A428732E431DF4322929D8632C4BD136C89169D
45718A88BABD7BD1BC8C59DE0A5C01FE0E5F3EC7EE6E6540D5A2602F157374C3
779C8AE4A89B2B8ADCAAFC569580B22876B58F43DEE23CD2ECF4E48D9C7B6CC6
69411D14C90EB2DF3C37DB89474563B87923D523CFF87D0A87D9C2A2B7BBA377
794F86ACD235A8530DC532B2F8AC036436F7BAF1EC85E6A0988C56A71701327F
3123ED0ECDF2560422F39E72F66FAB78AEA057C18ACF58136C94A428B207C286
DAAC5F4C73B8B78639682E6E7F0409243C6256300F76B4448994AB17E31B58C1
5CC4396CE75BC0580F75B3BDDB59FF642949FB1EE1DEFA6146BFE98336D9D748
7F83F099F2581F14FAA51AE0B81D6AF0602B80FD0E86AC17D66F166F8F8956A8
603E807FF945B24970EC6078E5A0B6F2BC31F75A62F4C02608C2832931604553
5EB920339B4E224493F2F2A1B0D13FDDF7E6129D47AE0428B2086445F0E22A5E
B61F0C232B03C08B27866537A9CA5F4C176B4619A4EE1A5CA99AD4D51FF975CD
8ADBE47F6AB56B419B2DFFD98E311BF3DB0D2F8103C51CB9F50407BC33543232
7692DA3F04D0384963F405F6363F314FB7648B20D9A45F49A8C83174A9AE3F81
71760BB6F16177BA2614CA2367C4A1234AA8AF985A3B1B3AF560AAD8F7A75FC0
7C93E29D4217A1FA558FEFF0485CAF90627DC9C0AD842379B00A5C8564FC9A91
5C85B66EEE33EA460AF2C5BBAC60AB7F8019D9C7CE4B8BDFBAE69307301C2EC8
4FDF118D0DB9EEFAF6FB97D66CE67F532CFD2FF2ECF924E4C182CBE1F42E739B
6485473B414FCCA4D5C10FF388FB215B78478AFF62C3E3342FC26AAA58D46BEC
FF536C70AA8FF8597B279B8FD1B911FDBB4D30735E62DDA88DA65E9A006F8EDB
EB4D0BAF47300B80C3F944CF3C1B16405D187AB30CE153914AF924F674813266
AF9200CD9DD1FBF4E7FCB6EEDDDBD1A72B2B888F7E9C40B98C3596AE3ECE6505
EE8972574CD5EF7C12AE10ABB066C75A2F835A9CD11BC6D7C87ADA05A734DEE0
8CB62CF82CFA510143E7558AAA21C046DBC8AE4C55DD51EB8F2B985C887DE4D7
4BD7D1EEB8100D8946B65A100C133FDC42D654F983F329C433B95DC6920785A3
26592D07637DC90DDC0562164110F3599D8E6CB9E93D141668D361EB443CAE5A
CBDCFC8AFBF4EE5E7A2C6227B341BE13F628CBBD5B901641AC52D310C58FC911
D294EE7E91E866841764A3F3AC2302C08791F29A7831480E17EF470AA749FA5B
EE7840085691FFA140FCC6C598BCACF8A97102819863EE765283CE013C9E099C
3AD560BBC9A72A50B39F367B69D4177FFA919FFB035784ECF6CB66BF597BDE3F
AA2728A20000B2D49835C34DE75CAF4932693BCE009A5806A9C0D52E80C82732
1977F7865D10CE97CA2774F27737D834917C6C2E033240C86703508D2380278F
B9B8E12EE7D8D49DBCAF4C6205808A224EE853AD4E54905F25CAF73B8FF0DC4B
537BE320021EC1102A196BE260790E296EC3F3C7C84F3D397E25A739C61C0844
65A5E6E28BEC27EBDDBBA646816DD1E6EAF6999E13D836C7B0C571107569102F
B29ECAAD60C12F5A152863097FE8153ABA67B43E342D8157822D42F334B8793F
13FB6797C5E5249C7FB050DF4B609AA7E8683F0D72BB9334996DDCB190274C34
D7CAFB950DF5FD1CFDF348B8A1F08379922A6376E30C1F0321B90C4DCB60A818
EE4D33034070935EC99ABCB4EDD5C13502BF3FA332F028FDA591442B82FBABDF
63D110A9A02F36C06FA7B26238CF55340B24BBB424F33F3E9BC28711ABCCCB06
EB5A36E90C1F95286B0C5DBF7CFFD7DA279097919A2254314FCF21D618A11C8F
E5D6E118BDC709BF2F6FC2F82601FD622A05CD8D002862190651A2709D6973CE
3C2DAB27202B6994A1C8118C56646695B4ED5911988ACCD6357281BA2643028A
304E0EEFF77B7771FD3ADA7DEE0A77B08D7963706DB8ABB55A61283116A19742
5EE120A17F7791554750299F7A6109C2683176F4D1CD45E138CA96F307F59BC1
243B45A3FE36D585509C64277A9AFD2339BDAC1F73578793DBC567404DC01766
237587C2DAA253671BC717F41E5F9E3051AFF267F8A99DE3167E4031624F0ACB
218614BE7415679F05B5F1DF3BC7E84A84BCB67061E68D22E825613953308ED8
90E8CD6EF325DCAF76B1833E98F45B76D98F7F115A67578C90CE30A316B6DD47
DC6666BB2350231579E82A4A8EEDED2E000BF8630EBF6445BF8D61754CAA63E5
26980A6F1295C15C74DCF86B093C2A4F6B9F0BE52D4F1F2758EC48370EAB4E1A
28C72509A49BD69E7E6736A1BD7072A987295B3F4241344CE3BFA076C19DB786
990F5ADF4BDAF4FA2F4117210E260E13F3E6B825F861467649D10B4872EFC2B2
56AA04CF6ED8664412597C875D6A18FF85B17C9070C59EE6301D184BCC426C59
1BA22DF38389D183D64EA6EB8BB85F4DDD29B3B4B551C48CF2F739CB2EC7AC3F
669435FC2BDA269E8D4CDB7F92E030156C7AB18411EC8745F5A7598B6D515387
0BDF50F61ECB986B27E37FD67F41027F58B63239EA4B42BD9BDF1CFE6774250E
026264EA6B1BAA2A563E8545D12267B73080D802BE7341B5F4E5D10DCCA259EC
1F94D869B259DD936CA24930E7085F7B9D4EED10BE682F55D46314BE428EAF29
5655A9E39C505CCE63CA5CDE681DBB192993B553048C58C55F0E420DCEA6C0EF
8004033A4C316ABB86A95F8FBDEF27B9FC1AD32775A45E85EC79363ACC8A5F23
4575C256306A3E2B5F688D9A78E431EBCBBD0149BC294A9A29640874F1BC354B
5B55C953F77B5B5AD7E02CCA12A44CAAE0DB157CC788732B3979C77A24D5FC81
E9B9C3FA269C8553905A0D86912C29680C0EF7184211C879D1CFA2AD39885649
8188E47A11E20DF09B4D1B004E09B4CA8677A959917DF9DFE654EBCCDAA30204
CB7959E437397D97A33B2F074210728254824B719C8B575FD784DA7688FA287F
7069D486A58BB3FC059CFB08D27D2924985A7C9DE03ADF4E6D09854679B9E29A
A08A9A1D1C8ACB7BB7DDF90F0B10B9772BB01CCA6555DA1A22700A87C2999DDE
579B60444EAD3B2E0A5C9A1C1B39778132988F62AF56BB1C140022F7F802B907
0C1A92470E3AD7F1CD944E91ADBD1EFF555D1777D2A7A9362E8EDD1141450427
51E6A5DAFD97118A3BED1E9E4CC60A09BEA9A64E0D84BCA80055E57D34FA5594
5139CDAEF7E7417850981E2FC2BB60E3AB70FBF551DA727FC16450E008B9A2A9
C69D704164C36B9E9D4487957378033C85592A0C3497A03C16190EBDABB792C8
943C94DA6FFA490EDBEEC662169655F6D78125EE549DA6680BD629CEE07E06DF
83614E2E11CBA56062181F7A06D3B92F8F73013AD9CCB7B29C953456EBCF09E5
6380095EEEC3A27B18E547B77AB0DD203BA47E66E3B8932511771FA0C386F50D
2C9FC7F252AD669BB39A19492921180D9C11F12C5F8A59DAB86CE7477658A608
CB758F2490957CD4C3CC78C6A226B0717DC7A97528F63B8A148121362CC7D54C
426D3E520704A5B0FD809F2C02709DE2A1A130D56CFE8FC26805B455CAA9BD0A
2A3286810DC5A5821DE96CFDA0CFDFEEC52BF01E44723D3E0C745808D1CFA6D1
2FDC38E3993120E9D60FD5FE71B1AE3D44CBF5774FF4678220E8486A0597950D
6FB6CE60547AD514197C7C2924D1424C444B9D6FDCD0195626B9FF52B0C6D349
4CE7F52144B2D4AA133851EC30082831A288160B9904BB2D09F2A0667A4E0B5D
6BC5439622D0710C5602150AF570A4249E88B67A19036F9CA8F73D54F2F5ECFB
F1586739F883F7465E6C0DDDD8970909777818CD7367E12604F9031566D80E07
F7EBB7770A9F71BC9B99A790B207F5A26B783AFA95962E9438FC3B10239FC8BE
780B5200B6756F2281E0400F776034AA7370C867BDF8F8CA314600EBEB709BB5
71CBD6D51C00B349268DE077F06EC0A06B1DA2D5D8FCD132607964E58D19D831
7B77DCB64CAC9744BB874493329A8428574898A4431060C062AC1A6FF2620BC3
CBCC7B27D9618E04A2EE6E3744D7A34F94201E827D0608A6B90E08CBF44A3066
9AF4E20CD5C1F032F37B225D1A63E440A719CD8CC6D148F1442F138478EA2EF6
7B28A1DD29D10C7BEEDAE714ACF1277D793CB278136861EC7A019D03EB58B34D
C20C8C69325CF4FFD47F5A1FEC0452DB032189B0081F505C6BAE09E9DE0EEA5F
54945D6DC2C09A0F32C2954C689BB04A12A787BF563986E67F166EE0323CA9B4
0F91BCF3D31CB0235F9E888EC3BC5D64B79E52DD2048D52A9F08ED1C54F6E91B
F8FB711E158D13F55A2A587261AF1A2D7EB2E0DE91E4C8FCECD6C57341C2275C
644BCFF020E44A3F8143BCB0749C406B887D83F8776E76346699BD3BF24A57A8
797D1FB03F38D3BCCF435AA6701CE98B48F7E4D1145CFB141F2A8C4B94348E7E
D962708CF7AFCE68CF821605ABD7ADDE70F2E2D71D2B5EE0C3F03A603A161713
216AF97A2BC0A0C703A8479904F0256C5A0B12BEF34533C9C6E9D5689F4F58E4
908EFA20B7551C67CB65DFB3A6A4F465C232143B9672CE2B4E3FE94448F0A8E2
88A3190A2F8C582A1203840F037B4146F2BAB25A95E1B0429A0F9DCA388A6AF6
EB49474FE6289109FB4B754EB4CB28BE158A35FFAB6D1CC91AE662CB73E82E06
DD21A7C173D5BC33CA3121EE6A2AC98D76EB90FD07A2994748A3C7C8B8AE9FBD
8D50429B985F23EBA0C907B6CCB4A57AC0CEA9F5A79AA95E35043900CF3BC8D6
A3496230AAF1232518D2D9139C2EC212D7741D517DCE40C6943373DB96EF2F42
F9853E64564ED0B6A26E6EAD15D1FA727896365ABF45169E554057B9862A1201
62EE8B3F4E8DA71604E693353AA437DE55B277110EC87721D864EF9C47AFF828
B76D3A67DB18149070025A12FCDE44664BF5BD6BFA8A80D078B7DBA591729E12
67D8D7B831C8203FD54703BE1ECB227F8908AFB27EADBB293B26C5C35F7B7281
45D99A8FB4E57D3FF125FB925D71F217A74A0BC2CDC17BBF1B980151F34502EB
AE22FE9FEEF344C5218AD07EBB2F326C7318226FCEB33E58A669E704123CC218
A3E114BDEA9856B28B062696D70B11E726BCB1551DC4A3348F9E2973D51E1147
EB065D30A883FD14933F4B11CC112DE73306E62FA3CFB976C9151056EACA79E2
258D77C2640768156AA589339AB2D94C2709E08CBAD9A1926DD364A1D0A590C2
4F7D4291F449E017A00E84DD26D1356B116DF444344D0C26C9BDBFED4F5F0D7A
56F0A6E0F662104C8DAB1CCA47E44D3355621E4291E8B19372375C5DA4CF8BC6
864D6A30FDA8DE677CCA20E14126A98C80DF80A4AADFF1595F82E9D4AC9B5424
312755C4B74383FD094BBB21769B0FF6E45FE00933038F1BE45766247545BB7E
BD0D5BA0650D889863A10E33C9F736CD0F8361837F4FF9C860E3E90BDE98DA5E
4D2BC78ED4EBA41C83C1D5DA810C7DE0B629E2AF299C26DCD463072AF184A4C3
FF125A06962078AABA9E78D9E4275F04E2BF5463C5A1C471B6B4939E2ACECD06
8ABA3B0FEE759D82A5542CFC4A772D8A45B1ED016C2055BD2614468625F83C27
32EA5C7722C00C1FFFA052985DAA45786E411F8AC6D254E74DC1322B42B3294F
B186AF0593011D448EF8D16283F9B14AB9EA1594F00F44CD3A74129B0234BEEF
B556B3D8DA07F988D1B61D2CA3146C19FA9B1B6B2661D80704753E7B5354F084
95716F72FD4F80E77DFD7E01E9FB8CB1F2B5971514C0F9D7E3FA7FCA7E8558FF
8EDE9B11BEECA6CEAEA9C395E18215311431841DE8187A20D6664348C7A8ADBD
E7378521868D652CBA1DD239AF01ADCB322583134464776AB9D3BF598A13257E
2415596166E303FD2376DB5F53A3490D2E6AA28DCBF3BAE8C7A5ADEB1CEBA885
B22DFA6F43021301D083753323D1726E22C04895627F0054CFFEE6C5742D4AC7
AB941BB9B797E98B0BDD9F99F787215B69A6EC77FD3EEFDC15E662E4E766AE5F
6AD0EDDF19F463239C92F9B480B4B44A27E72826780E48006E52E8A6DEBBA5AB
B133B4E25AB7CCBB2B62C63BB4735631F339CA6FC4604D4C1572EC48939DEFA7
221CFBE92AAAB70A5956B0333D16019A6A972910DAAFFEEFAA0C2F8A1B5A488B
99F89E973C3B209D0EC01BFDFDBAE2E3E4CF624B9BFF61D9A893DA0177CAB77B
B183F54581052B602C703FC5E91602CA0A1F5503AA671C48DF7B405E91CB755C
D930E9021BEA3D463E8FA8B45EA921B9FED12309E6C73E893B0F854BDFC449ED
454D197E8B3820AF578ECAE15FB293F86FD9F644C0D8C8FB99DBB010E78DD13B
AC80209F1234B69484C237E2D1E2E64C0D48329329A834F45B44FEB6FA4349A1
80D0B4BB20F582D459481331629711A8DE68CCAE80B0FFF87E514ABCF5B87853
A39109574DD12744AD2BDFE788A6FCB393E69BE17EECF31A8EDDEBE52F670153
C12D459B6D919E9782026DC6A0B1C8B4B5AE2D6FF99C5A65AF5D9F1D5A2F3574
35AE71B1DF46362BF3559056E31AF7320D8223226EED52626EC063253806F30D
13DC8B1A60616CB434CDE7436FBE5D67D8C427444311964F88706BD4BF54A5A2
16F2EED84DCA3C94388711AA514EF8111BD249F14C41BBB36ABC6291B6299555
DB7E62A74F7AF17554C9818684AC2CFF3C2CB42051BDA2FB7C6992B79CD83E40
292315B0EFE711C5446E24C768AF07829359D9585E64390C25DE13AC5F07F589
B108A61F2B9B09CDFE5866948199CA27C1838AD125F2AAB9F2E527373DAF483D
0CECDA8EF1A082C93DD016C993F210B495B3DE7C70854B3BFF083A22D936D634
0377139BA9397B57CD7CAC1B9E570FF69A6A7A1BC4B9A2CDD13A373A18A00181
0E42B57078E36F74D030289125A0BA5A982B317D8BA90F3F44F6CACB1FCE05A6
CB8353490D48F5FCD8601FA561B0D9B1117596E6FFDF4E2105605C3838D79475
F488283E17D379F989E79E2A618B94D724F053A56FE4CD666050B4554CCED753
DB52D6ADF13BBB37343980D51CDD3524F0B146BB99BAB1D6B998639A03A4B5CB
CCDFEEFC01872476101D65E487A587B9139012525061EDF9DB348304CE2D5349
3AEFE8B0CA70B8BA20AD06744BAE758B478EFE5CBBAB5138D6E4ABAE23A72E6E
372DDBEE44AA952CA42668A93FC84298A559C0734F5108CE1FB984C9C5B21CF8
236154D849C83E34D061C68E37F09083C2B38C0A2F839FD639DB0FAD86145402
3728391BA228211C06AA1096232D7603A06ADE57D040875E3A7F03DC50F41C46
57934151303A0733B90A29D2D4914D53B8EFF347467DF545E945F3E231D1BB00
17A92CE792F5C883A8D0A79774CF420783677F886641031043428217F4AF4C6D
56F6CBFE383E29ACFF6841A3A9D41A7CF33A7B5905412A63F288F85645B0DE47
D1F957988C63DA36A3577710E1BF34F0A215736C4C76625769D808103E9C5487
5B2146E9F849F9E4AC043A1A15AE68BD6F0FAC105EF2FD4C3E73C6003F3356AB
44A01ECACFBFE4CAECA175260290D8B0FBA6DE7DDD436420D7218127A814668A
98FB02720B0A0688426C0C1D3743456D1CBA4A622EBDEA00FFFEB8C51B57F75E
CFE7238BDE6BBD7453154FFDDD3322A2B0FA0C1AB82116D999DBF4C70D9A3F8B
72B95440914969A1F2D001A5D7C9A8DD9089A4992A9C06619AA6CCBC3DD8120A
E66A6A6A8862CB12A1135043A04BE41F18B2CD19AAC871DF4CCABC332ED0FF85
4BE70311218D1226787AA0A3FD23E2890634946F4B2AD5E5514CA68BB67B6D0D
AD8CC299A8CB22ACF60F9474792EE1B00CE037E54B6EBE4A725144D8941A9671
A2AABB0CCBD932A4C517BA7C024CE791E9E85821EC8EFB624618239067AB0D70
008BB2ABCF06E283F5507F6F94CF68C2588CE112A6D2ABD44B748AFED5F42AEC
B986050371CE273F61F89C86DE2F31382706EA33D769A6AE2E9D189076CCFC5B
D40026EE4F33793041E83EF250D858F61AD28EA488D1ED74D515766E53D53A3D
170218D3F3CD67D52C6CE4D2A88834CEA8080C90A3D588D03883FEB4F3E7D363
C7296984A2980195E373EAF1B7B910D3B232244986E26AA8396D696EBD94E6EF
1F3ACA5708D5656854704294478B4C661D4A4E9FA155F8AEC542E985D4BD95E9
57EE45E70BB821363368D41EF321F1FD66935B9C91E225D0AED56107BD6F4565
A426421AB1F43F6F95270FD6274540476E3BBBA96B3FF82F13A246D7A1708E45
EA0F954AD7D03474A6A82DAF5E1ABDF8CE3C652A8159D3255479B96DDEE53455
F41AB052F11C588936C0D4CEBF509848CA84C2B35ECC10DE1D4A063CE605C925
F841AE01B286AE295A1A0CBC029245E94EA10FFB437FDFB1DDF2DC4B8D59F781
ED48E700F5B35BA0CEC0EE57B9DD9F9AFAC453F01520EAD132A69E350E84241D
F40DEC391901EE6BD0BB9994FCF95D431D6AE0483414B9C10D50909123BCA3DD
FA0ADC2283C623DE81693159167C12BB3DB07AF11F67EF792A25D4AE27807648
B4302DFF36415917829F413DBF6B1AF5A3923521AF702F2FB7382F9859D4C890
589C7FFC9F6EF171A9A4FA400DB65787641CDB2B39A9370330D258EE8515E8CB
C0DA34E79D81B34454797AB7402A7E4EDAF950964E903405EEEAF0E94F8A4FD7
D591A617EC7403730DC7FDC3F6298C4728CD096F595E9A52B3D8AC1E8FC11E22
707E26253E1AA5708EB8B2AD79C1A84009407BE4EEA0E6E0851A59590D83B6F5
7428F5D92F0D318ABB61FCBEE8E8B0B00C0CD02E91B7A7B638AD6B9A54234FE3
45E1F0CE798DC546A503581846F239D6F7BC4BDEAB3579B57030F0E4B1F2BB05
95786E87D240911DF09A7B362D7CBEB0CA28A1E598EB9F847D6DFD21EAD729CD
B7B378CEDD34262B37A194EA49C428E91DDFBEAF65EB7B28D41FC2ACFEE9D6D5
5AA9AB5F777E2FFF6F8BD0DDDA24F9A1F4CC349ED95F66B71F96F259E0895B44
F511485B30A84709054F39D5251058E8856D6433253D3165DC740B8FF333791E
A89B9173E5658CBE626B87CF0AF0211035F415C5B593CA786F561E18E3F23AA9
141013647112E7616A831618F824E55486CAC5FAC631BF4ADFC1940B9EABF694
93BD455D90B591B7BB13704FAB1D14CD28C79B1EBFB02B5FBDB45797322DE068
028FD1D21375E31FEFE8D364436E2BED55952F380E4B986E4CFFDC3C6F786054
8479E2D65903D4947A3041E0C92467E7329FB931D67ED7BE9D523A6B56796BED
E767B48BEEB3BCC090D990E7A12A38A89BDC4DF24BE5BEB40B796AD36F4FA86F
331E4BC14C95C482DA02BF106AC063E2B8EEA19EC3ADE5245DD627628FF455F7
80E2D981F02DE8123781C31E557D56A54FD35468C968A27D4EA53FCBE67F1885
53AA98F8F2F93797E81A9A0AB15334D99DB727A758A924BE0D051BB73DEA2B8C
75178B57F4DE855DE567BF2A377CBA7931BA7412D4FAF53F99F1FC7750466189
2F60E5A560333458DD227E6557712989E311B03130ACA988305882A38AE0E119
15AF58D68ABD60567F307D6EC471F99B03CC7B5E8140DC03A211CA527546F059
9F0977CFDFA594116E4FB1CEC55B6568317559332B34FB651CC92781B4882D36
D3C1FE65BEB1E0D1EC6BD197D2FBC30A1D6064E2957B001530E51FE91FF192AF
561E7AFB4C6710520C895701EC10BF0345A50C5ED0923B060EA6EEA5B735D0D6
2E41842C07B34642E929A44135D556625B52750D9902A9FB77DD43CA9E5424AB
76A214B401F6E1DF2E0F680C6DFCDE0AE9FFDE2812B04580233972D92119549C
BE53B0896667EC7F8ADF92CA9F5B7E841DBC5A75CE61456C0CA380F054C338BF
95E957EE45E70BB821363368D41EF321F1FD66935E2AB436C58A28CD0FCA766E
CE69CC4A60829A626190360DD3CAFE48B040D71A55004B6570C850B55F5AB7CB
0C38339A72DD46EF815CF944AF37CC5A43AFFAADDDBE3C4CABD78D79FF72FC0E
92F4903CFD05856F457DD15F521AA73964C470E1FA471436D8C6E44AC4C50101
57D89C5A0C8D10D99B443B1CB9294FD84C265B934A0857A9AE8C427561EAC1CF
4EC54D29A0B9DBBAF10B53AAAE6376A1C4955C7691B72AD442BDDAD18F30DB19
0E4D004744086A083E8592BC01483D8DE50B9A6AC86F872ACFC94E4DD5C4C52C
626E5DDEC00A1C9E7A650438AF260A4353F034845C6313BB0B4C5EC4889FC8C0
F634CABABB7F981ACB4B01156666C7005ED540FEB0DFD0661D9FD2FB7F4392B3
D6E82E049F4EDC7D7F5B4F3B5F633645BCB792457DDEB103FF247068EF9B9B43
A951DC93BDAEF84466B935395BD8CB1E8273A55216313CB926B3E294194A81CD
78AC3ADF0223DA6C547263340213128BC9D5A34B32D8E8E9F01A276C94347B16
33DE00663BC920D6EDD21B7FDA8E024D71908160B1EE7C648F246AA8FB60C78C
A42BE38FB7611FE9041575AD1FB8FE35479E20CDDDE0D141AF959531FB2A32A4
C0367FBCBAE27D39E48732953F6A40602DCE249AC8E5BDBFDA09E3690E8CCEFC
EFEFDC124A168929CFEBB326CB0DB95669A32F4FFE973529B1FDC52A97A6FA50
63DB8544C98B81658B900BEAA1EF3FB862F9AE40F58AE62F66986E23FCC0B2CA
47DE26DE432ABC8F6D946D8FBED344CB30F555634425B334011FBBC2A5CA7ABD
86E736D52B75FCE3C8D5D0F6C89BBABF49EEA8A49C672D8B86C23DF95F6CEA46
42F2409E506EDBFE9AA1854BFFF469BE383F47BB8E249300A4E2A66056BB18F8
C29A87E85AEADA1D290708A8224C649D3021CBAB14E58205A2F6E650529A568F
66A773ED695588D7914A09C0184C1FB7347FF6E9BE216CB5DE5D367EE01C8086
04D058C07BC2C7B2486D61BED35C2AE04107B03CE274EFE7CCC5DAC73355C845
32F7A083D5DDD9A52A0E8E38C858441575949C41999FA96E8674AEF974C20405
4B3D7DDAC86DB682D869034B3F80AD2AD5D411E183E9D493B1219FA0016C05C7
924BF808BFF73AD1666C5F1A736D732E9B419FFB2D7BA106700361B38299B39C
3B44C43A535F6A798B59E0A598A85BABF0AFA855D0230C74B138FF7C2F9B79EF
6630855FC4078080CAE6F40C7488EB3F157A742E6BAF67BFF73F9DFEA01EF662
1E675181856E1EEF4C95B5A7A7EC73BEF1F46F2338FD98D505AF03796FC55D75
3125E93457FE72A92DA232227768ADEAA48BC391C7F6D0BCF705CEFCC8187F06
C8B4B22B55605847ECC0FD7784A185F30C8A53FC6F8B065C026E1C4712985DFB
AE3A9F015D6AC9CB4E4BC1D7C2248A8F6E5A7695FE9B0A14B937BA57C1A71D2F
9FC755C4798E56CE6044AA1958EC63C64F6B4AB90F5DFBB48002662A7740AB84
FF4B39C7B8DF84C5CCE36B514621B20180FB027918D1DE118AD70710CF8FAC62
06177C0115684DDB9D90FE2DC91047BEB8DB2EA880F4D89EE687F83508A96E33
0F6043EEB5B5AEBB050C11C5237974880793610FF90B5FB8631DEFB9843C3798
63857D8DA321738EE1080DE466AE8A508BCD6117FADE95A4B84027DD9CC23388
D465E53466FDEF6E4D4FEB7A2FD4E789818F8474AC309F07010EB0E6EEFF2799
2747ED46E67410144A520F7F66B64A927F0A67BB54F96AB20FD6F05AAA14D659
52774531A01D08AF8F6280EF02B3C4E44D55AAB8FA8635C06B486739CE5265CE
421E2CFFBE254FC47E726FFAAE2C2A15063C65B5636B616D9B1F87B638C5B191
EB96BD1CA41D6D36E8D75702D8DC3A179BDFE2B99F1FD6385F6AE9C3CD154A4A
8B21E67D6AD39C75A7A6B01A80C25B0832405DEC309A4EEA0D60FB157000259E
2A2C731FD40EB8D0C475D44BC6553D1F4A8B32C34AB3279DA33F642F5DE17842
73D95745C61429907F1246475B1ABE516106FEA1CD02BC0452FB99C4190B4297
DFC9B4A2CF19A4AC6ED3BE47E7764362A220AAA68E2CEEE203C7902489D4F4C1
1E98251686696A7A3DC4DBE0138393426D1B91093F991EBFF1786B432C43F3C7
361171FF479FB4FDFFC814716E8FD92C3919755C48B4F711372AE3B7BB1090E9
EE6E45F4321DE47E229F38C9420958399CB35137F6825D300A5DC4BB5E507C9F
D85B65CC1B53B2921BC4B68373229E0BD78E51415C1BD6694F203DC7EC6CE32D
227A9530C97ADE4619505809407145D7148F40B8FA1D9F0DF621DB3D970B8459
39275655F39F9C368D414EEC20824BD6BE014178A03A3D1129C1204E95D0F19C
0E9A42DF89694183030ED6F378C43DBEE7A6450C83A736479DF26E89500AFD8E
4AE5D7ED9EADA8081239775D89C1D1836F6F5B7A0F97394DCCF42E5DB57AEF5C
1F15464D43E2A627A1FD7E4DF116E24E0B2C3DACF2BB4D4F11C5FE4243E3402B
0A8959D899C05E423C089EF4C750437A96608C14C8B07859B61CE89F8184AD68
42FF56F27AA97073B3E8EA6E27A57DF0B4CC9D118666C78DD383D722EC2C9127
C2DFD58A4E7668ED6054923188627F7C9D623037D39A829FA0E949007DCF8453
E70E60A519674D305523D33CA72C09974B99C3A0363AA5CAE125EF0F3B74E355
60D5A3CAA24DA5F010E6D580C3BA5308F9180171E06B8DDFBF2ADCEAB5FDB951
6E8F04567E70E8F2AC629B39946E5CAD0838806C965228715A35D8C7887C7637
4C1C424EAF8C6809813EAF27D51349DE00E3FFB283B1F17EF1456540F8978390
F72AB65858B859427724D09F803119934626238EF01754016A12EFF81B4467D3
5C951A90ED6E4473396A9E0C75F5F4AF235A76B190B7C820DD8F5FDE234FD261
FFA8DD0BED83D99CD39BE14C09475F81CDC3D98F403E6E145EEF8AC9C176225B
3737CCBEFE80D4325B01DCA311A0ACA9380919BB7EFCF84433ECDC982117EE77
08706A1A9F9128841698D39D7A6620558C0F4ACA1012F691487872585C17344C
C47AC7862F32859E7D254B5869D52A5481D024538265DC641FD60725E18E2BEC
8C63A414680F9176A05F32B350E2CF46BA0E8D0120BA28CA538DB8CF06364C18
D0B14473491ECC44B826A0231917FA2783DCEA90AC383E4446746FC85E9B1D81
7C9F6450BE2DF9CA920E1C9E27FE6C9D4D841359D93CC99B103AD3DA2A47FC87
C5E3CF18CE4227ED29B9A8CF29DED73078707B01BCBBB9B720B4DB591254AE4F
45B4060C8E4FB2C4E569A1AF7B997F72685DAABFE2728E8C858DBCBD97807170
F11E547FC3D3A09261C3D3798EDA35F508CC8D07A5D43B48D40D3DE3B9062DEB
FA016CF35B353BC2CB5AECED9B0651A8A70127A7B6D6928D6393D855AFFE7665
96D923DE6A4819F3DDB1411C376787DCCC469F795F35F75835683515AF6CD0E7
31942B25D5FA8C7ADC5181FA6EDB08674679A39EC0A7F739BC533CF7684AEA17
55945C76CCA4F116849294DD8EA089FB3950BDA46D0EA2A06E998BC239F96D24
325048BACC9ABDA9206AFAA0DF92EE50089F30F3C4ADE4D307305271D998208E
DE8F3303CD4307DB36449D0F5968CA48EFA4D189AF40F82331E60E5F8652CDAC
1C07FB4D3CF9F916F915395564D090F986977994BDC068A61B0DD5FF9CA58278
2EEFEED4AB9B6BD24C39E1432DBE8566D73CAA5BC2885F0C046321C4B1ADE33F
D14670C66F070D8CF7E7607B46F2D0C890B0ACF56291130D4859BD3323A0B709
F40562D443C96DB597E896938B584450D9D80131C2DAE12E58F6D6B030C44C7D
3C57D1BE473815AD5A141AB5FCBD7DBC7F8E14193687FA6850469794AC10F646
088FFA3A237101EB114A7230D44D8911F60949C075630D5E29912CD7E6362E52
8BFE884E44A16A51FBC10F2F4BD0EB7475E396C85116AD2E1B2983F1E3EF1848
1EAF1EFEDA0068BCBDB28A7FC07F5649B004C475B44AF584CD94B6036638EBE3
3CB1F72C636A662F091CFB2CB3BC136D0AAA7AF6559396A793BC6D2C529DA22A
5A9F0AF66B44344F1DF681219626CC3302ADC8A7AED0FFA3EC08393469FDE6EA
A3E54E66E8F26F46E21A6CF7145AB813EE98B34C06CB861E9F83EF3AEAF43103
54B314CBF25CBEF5549621415E462F8508A489864B26FD4FB797AEA8DDB09C30
79A5D2A5948C7DAD558D4FA61CAF475CB31F758C0B8E40B5DB7A470EB9ED9E66
7094025A81C470D33021157B3FB3580922A191239DE0D26635EF19DE46063E62
5CE293703A8778C8C392A02C263614D142436C0FF38F25E56D193ACB420996BE
7032BA42DEB3D488D806400AB4CECB54173FA3C5588A14412A264B827C6050DC
CE777B796B6807D66738BCB61B03E6DE126317ACD924D5A61FC31713BDA87945
3320DCE8EDE7ED1918294062582DFB8EB599305B1E6A133B6C9AC1E9461009C0
A078862017B2A0C114B49BD9220AE366C07D824749D453FCE317F53A0336E9D5
201AFE350331379CBFE17C14503DC1AF1FFF37D3E2E8E17902A5728F9AEFC3DB
3E81B5EB263B967745D73FD54070C80AF82DC8CCC76C007B90466167D1AB73E1
2ADDCC2A5D4F1C948FD5F508EF79A6E58394BD8312A0F3E3C576E45B9145C661
4172A38A90C448FDC45A9D6DB5F53CB1041DDA059BBC1CD1305A3BA4B31B29DC
AF25A32AAB25258A6FB58A9FB1545F9A501ECBA1C6E90C726DBFB011B6C12327
592F8B086ACDB860B1B84DB9B95B901641AC52D310C58FC911D294EE7E91E866
8417605A488E43CEB5C4BDA5A093F493F51B52788B4525A50C15B7E0A3E10B00
9E48968EC723C6DECDFDE76C4A7E71F8B6A93C5A22632DD205AF0786A79AFDDB
23227CCD9926CCE11857D69CEED6B67979C723818FDE9363FC7DC757F4B4B8DD
91CB69558534CCE31AE7E157D0B060877D31D71B331A026E3D72A9FC0E15EE51
F97141125A74C661C41F4D7A2CEF0B8831E122CF9CE05CA2B7A039D3C057ED1A
A32731BC537433771CD44420F8EFFDFE6A6C0190712B73B455F1A1C1C551CF57
17EFDD7E6A78274B5677D68469C4C63C5E0C06E54E7126C3703E86784CF13225
3C51B9E6E27E63511004A58EFD38E703B129C39ED7DAFE7AA2AAF8B31211F9F8
4B7C1C08FAE1A37C57B2253F632FE978DDAF5E0A70C2137B983B1A5B45BBFED9
DBE2E0970EF2443DBC653EAA60868049AFD5623BDE3CD408714E8E7C016ED719
D6A4D045FA24AD853617F331B7C82C17C2806104EF6C23FE114747EB3CF5D303
AA38E2F36A0C5AE69E84EF52EC5EB1D04367A1F530BC5E310182F66B217FD6CC
9B23CD9DBB08CE4B28C0ECAF347B4F9354DC900685CE73A8D5738C2BC3A5CAAA
DC7D7A02A6CC5310ECA24348652BF62276DFED27FA17139314DF8F5DA10E7729
AEFF7D3CF49ADA55F1F20E71529CF0DCF6CA9C06832E0BCDBD641B9E673F20AF
E5D6600286A39A30F903FCED1D163C9E7EBD76815B0E7D7F958B781B7F571EBB
DC53A4272568BDBE227C15BF212E54E37449557E04D2F8464643A22795588239
F92743A2052BD1EBB7000206028D073AE1483307DB3ED0285C3F45243ACABA08
135064785DB25707F42025C8B07931A1929FB0258ADE88E101BAB5F27882399A
8BB9FB8515B2935F21351F42CEB4203F46DD2D9DAF8F90CF4F43A8558889B8A6
715B00D1495B99CBA96ABA9147ECEF29D69BD30ECCC4EC77B4356BF8281F2D2B
9455F611A4113AB278EC13EE5DCA91CD03E726B1EA1DA0D2D3A0C45ADBA04631
3115E2C2823903980506A9F523F673BA8CF49FF6291E02C577FA15398CF62096
6AE73D22C7312708911CCBACD6658146E8E615D349ED779B787232605BEB3834
6E339D1FE4E872F3F494398B881FD0AC7B10B67EBC2E67876D10C05C74F992A7
8703081772B16091B3FB2C085ECF30A0086A47A0EC71D4169ECC5A9AF15C361F
4CA0CB8C1BC8211E004B3AA0690A4194719604D655F83392CE829FAC59B22403
C1F1B08901EBE7607A0A86C523C36EE7B2C0B913741254040BC520FE1C36A447
96BDB5DF0FF41685AF8FF5387F0F57089A2DDEC2A5205FD3CD2015A5651A2FC2
9AD6067C60D1CC7AB83FEC19C5ABD83BED1077C1D558D47FD0D0331085614FB0
69CA8D80059115F1926B65493243EE607CC5E8C7189E78D019562D5C0EF80712
C36D91336AE0304148313B27E1641665CDC62F4C5D58F281ACE8DFD6D48A5453
00D111C681DF8126C4B55CCBF6C5421CAE132B0C35181C92FDD6246567D3300A
7936B7A9714834A884A4957B1168D1E1F46742DC29B82660DA5648ECE74BDA1B
A604872AD6C5271FA89B438C641D8C4F4CD1931F0531799091E33346B8D187E6
ABAEF57E2C3A3FC082B0DF92B1175F139CCD692C12AFF155AF2A78641424814F
2BCF083E0B5BCC7BFF6D08F61C99AA70B202EA5032E362E2C41D66C018D4F1A8
5667A384C775B0E13ACF52AA36995D5C32937BA288E6F7F5EF5EA5A9249F0F94
B0BBBDC8F9165DDCFFF01039D5E0F17B2F015B09906DD2A1FA3458D37F8CD2E8
51947683E055BCF5EB5C69C1005B864AD5B757C661F15531E735F35CA26A1710
5A2469DC27876F4035544028390706CF1ADFF7F276605E119D5DEED4875CAA0D
85A9CBD90DD7BE02655C49B289A9B088BD9EC3B6580F2817D63DE90FD71F3E12
A39406D73E24E5E04C6E0ED12E15FF74ACF68FD830BBDCC9F4E8F100FB3AE710
F79091EAF4D42CF6A8DC62A991B5583768198AF9E8856D7DD159EC22E6191681
A1EF12402DD96FD53B69AE8BEEBF522EDA7D73501452B34834A3A78F5B436CF0
00514A8E7BA6FB5B44EC192F91124171A9CE391BF6D85443E394086F1DE6749F
F3C3A3E412FE1AC1AC380F35CB7D1A99103E110E0CDDFD00F53C19D310CC10E9
080C619F102E6C0EE4F80F05C1AE0934A5471E6F4BD470436D8B767C3AF36B66
0E675335CE8B002A944ADDDBD28F1D81C8BC557943467AAA047755650CAF0760
C2A23A3D4C306556730E3E8985968F63B3D05F76F471A46E9D3171D22426F200
FB8824E27D3B1F736466EF878BC99C1415EBF54C4625875B72920956E2CA57CE
FF63AA910DFA42A963FDC006DD6544A13A283363FABB71AEB4A34DEED8868CE2
9857AC764A19824E49578AEBD9108BF825F2CC4E77F6BBDC352DDD6E3A3EE287
FF27B773081B813369F6EB3AD5A1FE45117A0C41ACBC43774A411033924B25F5
8B6C3937F7A3D8165EDF4C74CBB662283EA73600ACA6C99A0C9920CE6B42AAFB
C28BF1A25BB7E76A3AD041B35C4ED46D104E5A8928286996E809925295388BC0
29925BE5E43D9E9731AAD07B020D3CCBFC275E75D4E3959317DFBAF837DCB81B
F77BDC45E4E6250D89672CE4FD7C40DE0224F61857D6D1EDF135A35A8E10E17B
F7800E9342674F814BAE3BBDFFCCAA3EFA2BF0762C94A262CE0650766E29A79A
D6ACAE003485A4C21B389F4750C6152A769B76E0C0329C0FAB54D836A5923D3E
6DA2EABC198EB076A4029497905BD4FE34394358212CB5E09927FB2AC1875835
9E92F6E5F49819178A985CF7B2AE424EFEA5D9EA2F610ADB9AE7757B2307A1BB
9D6797DFA807FCC6345DF34AAA57C2F64F2AEA6BC668325DD0328F82CD0D12BB
1878198F8AD9741387FAD81CBF4B916C3E5107D7FB93D4FACFA45E68A2453EE1
95441C0322F5A31CB85E51ADE05F6461CD7ABBF7382327A2F9AD203ABB77D72F
0059E35DFEF5A8F444C41D300E540D53723DE16EAD24F497D993A4B132A6E7DE
5D7F399867841793101D1848133C2DD1CD525F4943E97917C37315BF6F93492F
B073004DC08552B28BB3769FC5A368C75E39517E4A1EDC0FE5F0495F54931E74
E8794276F856200CAA41DCC95A27A0AA6E874293E89DC1292F3A57FD6F3A111F
FCC7CE24D66DF5DBE2E04E25627838C93E0ABC541422736B99BC3B1CC6D379B0
5809BB83D175B1DA90C2478FBE3EC12FE90865168B0EED71019D6AC49CDF27B0
F24E818BDC3BD70EB627D06BB45DA78C776FB0386158298F5E68A1486CDEA9EE
0EE9B475088985727690C1AD441B483359935B388CF75B423EDFBC4680B3A107
EA9167B06FBC36135D9BD2741BD5A40FB00BA9C014DA2144FBE2F55E392478A3
2E11CECAEAFB7D4C6127C4A26EAC47FA91BED7E787DD83DBED95F86B97E1E9D8
0D9E991753E48A06930693B782764422692D98FA836012F1BA77AE80B046AA2C
6DD59F4CB5511FBAE3C48B1B02C98798499841B1BB1EDC8EA7AE9EF32168ABB3
E97D8D4885EA1EA01C61A57BACB87E33C95AA6961B7B77EF39FD6F498C953FB1
BE0128C6BD41CF3FEA5F22474EEF2FF1C792213126DD78A45D3BD72F01DE892B
72098784F1E01467DE5917873A449E4ADE2DDDDEBAD4BEA1951EEE0ECF5E0BE5
75C26270EB3CAD80EF010AF18760DE738F9AA02A86EF23D5F28C1F1C53B41A88
436901C08079E59BE74DBF83018ED58B882B96DE52EB59766DBB262C06251069
578D528B25856958961002CDB55C1CFB942952C5F2D227B7A94085C657D1C6E6
0858449A392E7CC944A3871301FF9B6D68D84C4B1054B5035D47B5B0A3725EC5
101252F708A3F3B5CFACD77BF7E6FB528CB4E8CFD3A1B17BCD1A2D9695130DFB
4452DF05C044DE8B99D6205FECE23D72A9F61619E09C92992A71D5D669EF4E79
4EF6D6320109A4205CFD1917BB11DB27ED503815316CCEC391025FFF8E6838E9
2AEEF0B531A4418AA997C16C2988EF7E0148A1DF74DA038B9479EB79FE033996
830841499F9FC73B628F01A5522C067809746D5702B990E6FA40628CB0FE77CD
3E7AFE2BCBB614EF3ACD646C1B9E0113A1C09295667F372F2176DB8093872453
B19A9664C864AE888FBD4734ADD05ED3388DDF915094EDB97DF199549D54852A
A8217E48B2B0BAB97245F57A5FE2380BE8DA45A7FD3452FC17F10A319F4D3C61
EEDBF89EED28653FD3657DD2B1531CCE1A08A96685DD3BF414A6130DD97211D9
5408F88F138D4968B8358244516D156D282BB7BDFC55B4522C394B3A54415980
FAE5FE82CD6AA69212F7C45DD001CDD50B27558998745F9BE431A9B3E3471C60
9BFFD6A27A96351DC61E31A1E2FA87D613121F0796E257FDB8D61E033D083625
FFC1453AA5165F1DFA12AE5B99CA89CE76DF92F2B1FCB718702E4B7116517ED5
96F3F7BD651D9AC4C4AF100F187D10611E17C5DD710E6DE3B94D853362CCB153
8C5D066F5DE7A883D850F4F7E5F3A3B3D2F64D8C9A780CE75C127E4985A6D16D
469A20CE3D0401A7B165F5271B585DFFAF181CBD18EC07707515C98EBDA57984
3F0D561FD770A4A620798630A442403E8832A4DE2BB999F2E444BB59FF84B9E7
E3262FB036E14786E95527306363AD0CBBD64F40B2D7D14C175F6EBE6B3B88C7
C508D56F5684A218719DBE52947CAF49A78171821E7571A21266B87C8385923A
59A5E06C8485A682B12598BEA06E0D4290F2D600FE363BC5E777D703DA7A4239
F59776D65F0A6D9E5088AD245098A9CFAE5B4E396213694C3D2833B34AF40511
17B57C6836EFF6B800784C0A5985C52EAD472487C1AEA2A650841A85F6228E50
1D68D32CA4729DA8992CCF1CF6F156A0A00C38F5967AC996A3448E91B2DAF784
23D4178B20E3987EC7AE0A8933CD43374BDDEFB6092A54D21372FCFC3215D2B0
A352B3959F9E731FB1C840B9F34A3195EEB878397D996A7E372F8BAF17891917
EBE7133230F3D1884F98429FF873E0A88BB1A26D5C0587DF5510685413A72CB7
907B76688BC1A0E609339DA47C57DF2F0C16900F273E283A3C49B047BB1491E8
72C4BBC064CAF598CAD8932F19EFA7E4AA3A5336AD7333A02BC5584DBC68DF18
B166E2510CAE7E38CE5D07C58A741E0B4DD7B4BF37D53CC9B3A20280EA7A242C
C6CC5A18EEE6FB61C5AAC1BED5BA1F339FC98197599D481BE172D65D6248BE24
64CF4F410CBAA0B7379EB6C5F0D75C2C85EC0C5B4712D00CE1ACDB2B5D8AAF2C
BF57A128D43EC711959DB736EFE14A3DECE47CD4B45CE3FE965B7EE2C766BB7D
0DDE4DFA605B592E7548C31D2B25D33145E650EC84FE8C2E96A9F2C14021C0AE
EDD7B8A6026A1EEA02679BA97B6956D19FD9BE6CAFA096FC232D27625BDE8442
49513F0C28D6D0B0715907E0FC824C947F67D492E6D986BA910BAE372D47CEA6
4006DB3BE06066FE1E096E3885C0CED910FB63BCE2ECF7358787D7B5695918C2
B3C3F6C7C0D1E3FFF27FC2C2CED30C4647A221BBE2C5D94D027982839BAA13F3
ADCF7B60CAF75285767CF63453F623CF9EF41CF4A075816B71EFA3D9137DF428
A5636581D4F5803ACE07039CE6DC900335E377C303FE38EE3D070A67BF2FD446
58196D1706138F67198412C65456042683C5EFC4A34D136CCD64746A510258D3
216FCE73D553EFC3CFC0870D14708BFCDFD2BCB90F557696636C99F82644DF0A
5A238DDA2B6D802A6592C153A595DA1D9D872AF83379EEAAF9A71415DA923CA1
314F419F911DF216519CD7B0BC352F0065DA9885C15EC6D9041E2348A01EDC62
1122AB2FDA7F0F7BBC1F248AE88AA14B01B44FC91AAB403C4D3CCACE1B8E4FB6
5FA8EAB977F331CA04413B369277F09362F7A948FFB8BC488BB25CFE13BD1F11
0B9E6F7B9D6597FD45DAAF07674145E8553E1E7C0118FD1F0CAB246AEFFC90E6
7CB761579541A7C5CF4CD2F07B9F70171D1E2D3196DD536C8BC9CFA0931C2F0F
6702334E4C
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
TeXDict begin 40258437 52099151 1000 600 600 (examplefull.dvi)
@start /Fa 119[65 136[{ enclmts1 ReEncodeFont }1 83.022
/LMRoman10-Regular rf /Fb 134[59 1[81 1[62 44 44 46 59
62 56 62 93 31 2[31 62 56 1[51 62 1[62 54 25[88 70 4[85
1[53 16[31 46[{ enclmec ReEncodeFont }24 99.6264 /LMRoman12-Bold
rf /Fc 135[50 5[39 2[48 53 4[27 1[48 1[44 3[46 19[91
77[{ enclmec ReEncodeFont }9 83.022 /LMRoman10-Bold rf
/Fd 134[44 44 60 44 46 32 33 33 44 46 42 46 69 23 44
1[23 46 42 25 37 46 37 46 42 7[62 1[85 62 1[60 46 61
1[57 65 62 76 52 2[30 62 65 54 57 63 60 1[62 1[39 9[42
3[42 2[23 1[23 4[23 5[23 4[46 48 5[42 21[{ enclmec ReEncodeFont }53
83.022 /LMRoman10-Regular rf /Fe 134[71 4[52 1[55 2[67
75 112 37 2[37 75 2[61 75 60 11[139 2[94 6[128 7[88 1[97
33[41 33[{ enclmec ReEncodeFont }18 119.552 /LMRoman12-Bold
rf end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 600dpi
TeXDict begin
%%BeginPaperSize: Letter
/setpagedevice where
{ pop << /PageSize [612 792] >> setpagedevice }
{ /letter where { pop letter } if }
ifelse
%%EndPaperSize
 end
%%EndSetup
%%Page: 1 1
TeXDict begin 1 0 bop 0 0 a
SDict begin [/Producer (dvips + Distiller)/Title ()/Subject ()/Creator
(LaTeX with hyperref package)/Author ()/Keywords () /DOCINFO pdfmark
end
 0 0 a 0 0 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 0 a 0 TeXcolorgray
506 125 a
SDict begin H.S end
 506 125 a 506 125 a
SDict begin H.R end
 506 125 a 506 125 a
SDict begin [/View [/XYZ H.V]/Dest (page.1) cvn /DEST pdfmark end
 506
125 a Black 0 TeXcolorgray Black 515 440 a
 /pssetRGBcolor /setrgbcolor load def /pssetCMYKcolor /setcmykcolor
load def /pssetGraycolor /setgray load def
 515 440 a
515 440 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 515 440 a 515 440 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 515 440 a 0 TeXcolorgray
515 440 a
SDict begin [/Count -4/Dest (section*.1) cvn/Title (\376\377\000W\000e\000l\000c\000o\000m\000e\000\040\000t\000o\000\040\000t\000h\000e\000\040\000T\000i\000n\000y\000M\000C\000E\000\040\000e\000d\000i\000t\000o\000r\000\040\000d\000e\000m\000o\000!)
/OUT pdfmark end
 515 440 a 515 440 a
SDict begin [/Count -0/Dest (section*.2) cvn/Title (\376\377\000G\000o\000t\000\040\000q\000u\000e\000s\000t\000i\000o\000n\000s\000\040\000o\000r\000\040\000n\000e\000e\000d\000\040\000h\000e\000l\000p\000?)
/OUT pdfmark end
 515 440 a 515 440 a
SDict begin [/Count -0/Dest (section*.3) cvn/Title (\376\377\000A\000\040\000s\000i\000m\000p\000l\000e\000\040\000t\000a\000b\000l\000e\000\040\000t\000o\000\040\000p\000l\000a\000y\000\040\000w\000i\000t\000h)
/OUT pdfmark end
 515
440 a 515 440 a
SDict begin [/Count -0/Dest (section*.4) cvn/Title (\376\377\000F\000o\000u\000n\000d\000\040\000a\000\040\000b\000u\000g\000?)
/OUT pdfmark end
 515 440 a 515 440 a
SDict begin [/Count -0/Dest (section*.5) cvn/Title (\376\377\000F\000i\000n\000a\000l\000l\000y\000\040\040\046)
/OUT pdfmark end
 515 440 a 515 440
a
SDict begin [/PageMode /UseOutlines/Page 1/View [/Fit] /DOCVIEW pdfmark
end
 515 440 a 515 440 a
SDict begin [ {Catalog}<<>> /PUT pdfmark end
 515 440 a 515 440 a
SDict begin H.S end
 515 440 a 515
440 a
SDict begin 12 H.A end
 515 440 a 515 440 a
SDict begin [/View [/XYZ H.V]/Dest (Doc-Start) cvn /DEST pdfmark end
 515 440 a 600 x @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray   gsave 0.  1 1 0.0
 0.0  translate scale rotate 0 0 moveto (test string) () /qrcode /uk.co.terryburton.bwipp
findresource exec grestore  end
 
@endspecial 515 1364 a
SDict begin H.S end
 515 1364 a 515 1364
a
SDict begin 18 H.A end
 515 1364 a 515 1364 a
SDict begin [/View [/XYZ H.V]/Dest (section*.1) cvn /DEST pdfmark end
 515 1364 a Fe(W)-11 b(elcome)45
b(to)h(the)f(Tin)l(yMCE)g(editor)h(demo!)515 1596 y Fd(Please)26
b(try)h(out)h(the)g(features)f(pro)n(vided)f(in)i(this)g(basic)f
(example.)515 1696 y(Note)21 b(that)g(an)n(y)g Fc(Mo)m(xieManager)g
Fd(\034le)h(and)f(image)f(managemen)n(t)g(functionalit)n(y)h(in)h(this)
515 1795 y(example)g(is)g(part)g(of)h(our)e(commercial)h(o\033ering)f
(\025)h(the)h(demo)f(is)h(to)f(sho)n(w)g(the)g(in)n(tegration.)515
2077 y
SDict begin H.S end
 515 2077 a 515 2077 a
SDict begin 14 H.A end
 515 2077 a 515 2077 a
SDict begin [/View [/XYZ H.V]/Dest (section*.2) cvn /DEST pdfmark end
 515
2077 a Fb(Got)37 b(questions)h(or)f(need)i(help?)p 0
TeXcolorgray 616 2281 a Fa(\210)p 0 TeXcolorgray 41 w
Fd(Our)p 0 0 1 TeXcolorrgb 911 2281 a
SDict begin H.S end
 911 2281 a 0 0 1
TeXcolorrgb Fd(do)r(cumen)n(tation)p 0 0 1 TeXcolorrgb
1451 2223 a
SDict begin H.R end
 1451 2223 a 1451 2281 a
SDict begin [/H /I/Border [0 0 0]BorderArrayPatch/Color [0 1 1]/Action
<</Subtype/URI/URI(http://www.tinymce.com/docs/)>>/Subtype /Link H.B
/ANN pdfmark end
 1451 2281 a 0 TeXcolorgray
46 w Fd(is)46 b(a)f(great)g(resource)f(for)h(learning)f(ho)n(w)i(to)f
(con\034gure)719 2380 y(Tin)n(yMCE.)p 0 TeXcolorgray
616 2480 a Fa(\210)p 0 TeXcolorgray 41 w Fd(Ha)n(v)n(e)27
b(a)g(sp)r(eci\034c)h(question?)36 b(Visit)29 b(the)p
0 0 1 TeXcolorrgb 2011 2496 a
SDict begin H.S end
 2011 2496 a 0 0 1 TeXcolorrgb
-16 x Fd(Comm)n(unit)n(y)e(F)-7 b(orum)p 0 0 1 TeXcolorrgb
2702 2423 a
SDict begin H.R end
 2702 2423 a 2702 2480 a
SDict begin [/H /I/Border [0 0 0]BorderArrayPatch/Color [0 1 1]/Action
<</Subtype/URI/URI(http://community.tinymce.com/forum/)>>/Subtype /Link
H.B /ANN pdfmark end
 2702 2480 a 0 TeXcolorgray
Fd(.)p 0 TeXcolorgray 616 2579 a Fa(\210)p 0 TeXcolorgray
41 w Fd(W)g(e)28 b(also)f(o\033er)g(en)n(terprise)f(grade)g(supp)r(ort)
i(as)f(part)g(of)p 1 0 0 0 TeXcolorcmyk 2510 2596 a
SDict begin H.S end
 2510
2596 a 1 0 0 0 TeXcolorcmyk -17 x Fd(Tin)n(yMCE)g(En)n(terprise)p
1 0 0 0 TeXcolorcmyk 3276 2522 a
SDict begin H.R end
 3276 2522 a 3276 2579
a
SDict begin [/Subtype /Link/H /I/Border [0 0 0]BorderArrayPatch/Color
[0 .5 .5]/Action <</S/GoToR/F(www.tinymce.com/pricing.pdf)/D[0/Fit]>>
H.B /ANN pdfmark end
 3276 2579 a 0 TeXcolorgray Fd(.)515 2862 y
SDict begin H.S end
 515 2862
a 515 2862 a
SDict begin 14 H.A end
 515 2862 a 515 2862 a
SDict begin [/View [/XYZ H.V]/Dest (section*.3) cvn /DEST pdfmark end
 515 2862 a Fb(A)37
b(simple)h(table)g(to)f(pla)m(y)i(with)515 2935 y
SDict begin H.S end
 515
2935 a 515 2935 a
SDict begin 12 H.A end
 515 2935 a 515 2935 a
SDict begin [/View [/XYZ H.V]/Dest (table.1) cvn /DEST pdfmark end
 515 2935 a 1448
3041 998 7 v 1448 3134 a Fd(Pro)r(duct)168 b(Cost)99
b(Really?)p 1448 3182 998 5 v 1448 3275 a(Tin)n(yMCE)g(F)-7
b(ree)112 b(YES!)1448 3375 y(Plupload)138 b(F)-7 b(ree)112
b(YES!)p 1448 3426 998 7 v 515 3691 a
SDict begin H.S end
 515 3691 a 515
3691 a
SDict begin 14 H.A end
 515 3691 a 515 3691 a
SDict begin [/View [/XYZ H.V]/Dest (section*.4) cvn /DEST pdfmark end
 515 3691 a Fb(F)-9 b(ound)38
b(a)g(bug?)515 3894 y Fd(If)26 b(y)n(ou)f(think)h(y)n(ou)e(ha)n(v)n(e)h
(found)h(a)f(bug)g(please)g(create)g(an)g(issue)g(on)h(the)p
0 0 1 TeXcolorrgb 2820 3910 a
SDict begin H.S end
 2820 3910 a 0 0 1 TeXcolorrgb
-16 x Fd(GitHub)g(rep)r(o)p 0 0 1 TeXcolorrgb 3280 3837
a
SDict begin H.R end
 3280 3837 a 3280 3894 a
SDict begin [/H /I/Border [0 0 0]BorderArrayPatch/Color [0 1 1]/Action
<</Subtype/URI/URI(https://github.com/tinymce/tinymce/issues)>>/Subtype
/Link H.B /ANN pdfmark end
 3280 3894 a 0 TeXcolorgray
25 w Fd(to)515 3994 y(rep)r(ort)h(it)h(to)f(the)h(dev)n(elop)r(ers.)515
4276 y
SDict begin H.S end
 515 4276 a 515 4276 a
SDict begin 14 H.A end
 515 4276 a 515 4276 a
SDict begin [/View [/XYZ H.V]/Dest (section*.5) cvn /DEST pdfmark end
 515
4276 a Fb(Finally)39 b(.)19 b(.)f(.)515 4479 y Fd(Don't)37
b(forget)f(to)g(c)n(hec)n(k)g(out)h(our)f(other)g(pro)r(duct)p
0 0 1 TeXcolorrgb 2209 4495 a
SDict begin H.S end
 2209 4495 a 0 0 1 TeXcolorrgb
-16 x Fd(Plupload)p 0 0 1 TeXcolorrgb 2534 4422 a
SDict begin H.R end
 2534
4422 a 2534 4479 a
SDict begin [/H /I/Border [0 0 0]BorderArrayPatch/Color [0 1 1]/Action
<</Subtype/URI/URI(http://www.plupload.com)>>/Subtype /Link H.B /ANN
pdfmark end
 2534 4479 a 0 TeXcolorgray Fd(,)i(y)n(our)d
(ultimate)j(upload)515 4579 y(solution)27 b(featuring)g(HTML5)g(upload)
g(supp)r(ort.)512 4728 y(Thanks)j(for)g(supp)r(orting)g(Tin)n(yMCE!)g
(W)-7 b(e)31 b(hop)r(e)g(it)g(helps)g(y)n(ou)f(and)h(y)n(our)e(users)h
(create)515 4828 y(great)c(con)n(ten)n(t.)512 4928 y(All)i(the)g(b)r
(est)g(from)f(the)h(Tin)n(yMCE)f(team.)p 0 TeXcolorgray
1926 5255 a(1)p 0 TeXcolorgray eop end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF
